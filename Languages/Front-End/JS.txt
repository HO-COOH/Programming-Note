-1.包管理
    npm是Javascript的包管理软件，在安装node.js时已经自动安装了
    node.js的更新频率不如npm，可以通过npm install npm@latest -g 命令来手动更新npm
    在Windows中，默认下npm下载的包的位置在：C:\Users\Peter\AppData\Roaming\npm\node_modules\npm
    可以通过npm --help来查看
0.什么是Javascript，什么是ECMAScript
    ECMA（European computer manufacturers association）是一个国际标准化组织
    这个标准化组织指定了许多不同领域的标准，这些标准以ECMA-xxx命名，其中xxx是数字
    其中ECMA-262标准，制定了一个ECMAScript编程语言，换句话说ECMAScript这个编程语言所基于的标准就是ECMA-262
    目前为止ECMAScript这门语言迭代到了第11版（在2020年6月标准化）
        ECMAScript 2015 -> 6th edition -> ES6
    Javascript是ECMAScript的一个变种，在ECMAScript的基础上添加了额外的功能，可以看成这样的关系
        Javascript = ECMAScript + DOM(Document object model) + Bom (browser object model)
1.变量
    定义变量有3个关键字：
        var，在函数内为函数作用域，在函数外为全局作用域
        let，块作用域
        const，块作用域
    当定义变量却没有赋值时，变量的值为undefined
    使用var定义变量时，该变量的作用域会被提升到当前作用域的顶部，即使此时没有赋值，所以此时其值为undefined
        console.log(x); //undefined
        var x = 3;
        console.log(x); //3
    变量的类型有8种：
        Boolean
        null
        undefined
        Number  整数或浮点
        BigInt  任意精度的整数，例如很大的整数
        String
        Symbol
        Object （也包括函数）
        除了Object，其他类型在赋值时都是复制，即拷贝，Object在赋值时是复制引用
    JS是动态类型语言，意思是可以对变量赋予不同类型的值
    作用域
        使用var定义的变量的作用域不受代码块限制，例如：
            var x = 1;
            {
                var x = 2;
            }
            console.log(x); // outputs 2
        使用let和const定义的变量作用域受代码块的限制，应该避免使用var
2.字面值
    Array
        是用方括号[]扩起来的一些值，用逗号,隔开
        如果有连续的逗号，则被省略的值为undefined，但注意不要在数组字面值的末尾加上逗号
            let animals = ["Lion", , "Angel"] //animals[1]===undefined
    Boolean
        true/false
        评估为false的值：
            false
            undefined
            null
            0
            NaN
            ""空字符串
        注意Boolean变量与Boolean字面值不同
            var b = new Boolean(false);
            if (b)
                console.log("b true")       //b true
            else
                console.log("b false")

            if (b == true)
                console.log("b == true") 
            else if(b == false)
                console.log("b == false")   //b == false

            if (b === true)
                console.log("b === true")
            else if(b === false)
                console.log("b === false")
    Floating point

    Numeric
        0o或0O开头表示八进制
        0x或0X开头表示十六进制
        ob或0B开头表示二进制
    Object
        是用花括号{}扩起来的一些命名的属性，属性之间用逗号,隔开
        属性可以是任何字符串，不一定要符合标识符命名规则
    Regex
        是用一对斜线/扩起来的正则表达式
    String
        普通字符串字面值
            是用一对单引号或双引号扩起来的字符串
            JS也使用其他语言中常见的转义字符
        模板字符串
            是用一对``括起来的字符串
            相比普通字符串，模板字符串增加了表达式插入的功能，用${表达式}将表达式的值插入到字符串中
                var thing = "world"
                console.log(`Hello, ${thing}`)//输出Hello, world
        原始字符串
            用String.raw和一对``构造一个原始字符串，原始字符串不转义反斜线\构成的转义字符，同时也支持表达式插入
                const filePath = String.raw`C:\Development\profile\aboutme.html`;
                console.log(`The file was uploaded from: ${filePath}`);
                // expected output: "The file was uploaded from: C:\Development\profile\aboutme.html"
操作符
    delete
        delete操作符用来删除一个object的属性
            delete object.property
            delete object[property]
            delete object[index]
        delete操作成功时返回true，否则返回false
        注意访问一个不存在的属性时返回undefined，但将一个属性赋值为undefined并不会删除这个属性
    typeof
        typeof返回一个对象的类型
            typeof object
            typeof (object)
    in
        in判断一个属性名是否存在于一个对象中，并返回一个布尔值
            property in object
            propertyIndex in object
        例如：
        // Arrays
        var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
        0 in trees;        // returns true
        3 in trees;        // returns true
        6 in trees;        // returns false
        'bay' in trees;    // returns false (you must specify the index number,
                        // not the value at that index)
        'length' in trees; // returns true (length is an Array property)

        // built-in objects
        'PI' in Math;          // returns true
        var myString = new String('coral');
        'length' in myString;  // returns true

        // Custom objects
        var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
        'make' in mycar;  // returns true
        'model' in mycar; // returns true
    instanceof
        用来判断一个对象是否是属于一个类的实体，并返回布尔值
            object instanceof type
        
语句
    for in 用来循环一个对象的所有属性
    for of 用来循环一个可迭代的对象，例如容器
        for(var object of someArray) {...}
2.函数
    与使用var定义变量类似，函数的作用域也会被提升到当前作用域的顶部
3.注释
    //单行注释

    /*
        多行注释
    */
Object
    构造：
        可以直接用Object字面值的方式，即一个花括号{}来初始化这些属性
            var myCar = {
                make = "Ford",
                year = 1969
            };
        也可以先创建一个空Object变量，再赋值，此时相当于向这个Object中添加属性
            var myCar = new Object();
            myCar.make = "Ford";
            myCar.year = 1969;
        也可以先定义一个构造函数，然后使用new来调用这个构造函数
        如果构造函数无需参数，可以省略调用new时的圆括号var object = new ClassName;
            function Car(make, year)
            {
                this.make = make;
                this.year = year;
            }
            var myCar = new Car("Ford", 1969);
        也可以用Object.create(obj)方法利用现有的Object作为prototype来构造新Object，新Object的__pro__将指向obj
            var Car = {
                make: "Ford",
                year: 1969 
            }
            var myCar = Object.create(Car)
            但要注意，此时新Object内没有定义任何属性，即没有自己的属性
            console.log(myCar)  //输出为空
            这个机制通常用于实现继承
    方法：
        将函数放到Object里，称为方法
    getter和setter
        是一种特殊的方法，用于获取和设置某个成员的值
        定义一个getter：
            get myGetter()
            {
                return thing
            }
        定义一个setter:
            set mySetter(parameter)
            {
                this.thing = parameter...
            }
        然而与普通方法不同的是调用getter无需加上圆括号，调用setter则直接放在赋值符=的左边
            console.log(obj.myGetter)    输出obj.thing
            obj.mySetter = 1            obj.thing = 1
    访问：
        符合标识符命名规则的属性名可以用点运算符.来引用
        如果属性名不符合标识符的命名规则，则需要用方括号来引用
            var unusualPropertyNames = {
                '': 'An empty string',
                '!': 'Bang!'
            }
            console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
            console.log(unusualPropertyNames['']);  // An empty string
            console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
            console.log(unusualPropertyNames['!']); // Bang!
        Object可以在定义后随时添加属性
        对一个Object添加属性时，使用相同构造函数创建的其他Object不会有这个属性，即每个Object都是独立的
        不存在的属性为undefined，不是null
        由于函数也是一种Object，所以也可以给函数添加属性，也可以将函数赋值给一个变量
    this关键字：
        this指代当前作用域的Object对象，即使当前函数没有直接定义在Object内
            function myMethod()
            {
                return this.val;
            }
            var obj1 = {
                get: myMethod,
                val: 42
            }
            var obj2 = {
                get: myMethod,
                val: 3.14
            }
            obj1.get()          //42
            obj2.get()          //3.14
            myMethod.call(obj1) //42
        由于this指代当前作用域的Object对象，所以调用已定义的对象的方法时，this指代的是那个对象，而不是本对象，所以可能出现问题
            var answer = {
                get: function()
                {
                    return this.val
                }
                val: 42
            }
            var firmAnswer = Object.create(answer)
            firmAnswer.get = function()
            {
                return answer.get() + "!!"  //错误，answer.get()将返回42，而不是下面设置的3.14
            }
            firmAnswer.val = 3.14
            firmAnswer.get()    //"42!!"
    基于原型的继承:
        与其他面向对象的编程语言基于类和对象不同，JS的继承机制是直接基于对象的
        JS中不区分对象、父类、子类等等概念
            function Base()//基类构造函数
            {...}   

            function Derived()//派生类构造函数
            {
                Base.call(this) //调用基类构造函数
                //...初始化派生类的其他属性
            }
            Derived.prototype = Object.create(Base.prototype)
            Derived.prototype.constructor = Base;
        当使用new运算符时，JS先构造一个Object，然后隐式将内部的属性__proto__设置为构造函数的prototype，并将构造函数的this设置为这个对象的引用
        当需要使用一个属性时，JS先检查这个属性是否直接存在于对象中，如果不存在，再到内部的prototype继承链中向上寻找
    多态
        要重写继承而来的成员方法，实质上就是对prototype中的同名属性重新赋值一个新函数，即
            Derived.prototype.memberFunction = function() {...}
    性质：
        Javascript中的Objects都是引用类型，只有当两个变量都为同一个Object的引用时才会相等，两个变量具有相同的属性和相同值并不会相等
            var fruit = {name: 'apple'};
            var fruitbear = {name: 'apple'};
            fruit == fruitbear;     //false
            fruit === fruitbear;    //false

            var fruit2 = fruit;
            fruit2 == fruit;    //true
            fruit2 === fruit;   //true
class
    ES6后JS加入了更接近于传统面向对象编程语言的类和对象机制，并引入了class关键字来定义一个类，extends关键字来继承一个类
    class实质上就是Object的语法糖，基于class的继承实质上就是Object中基于原型继承的语法糖
    使用new ClassName定义生成的对象仍然是一个Object，可以随时添加其他属性
        class ClassName
        {
            constructor(parameter)  //构造函数
            {
                this.member = parameter //定义数据成员
            }
            memberFunction()    //成员函数，注意无需function关键字
            {

            }
        }
    定义一个对象
        依然使用new关键字
            var object = new ClassName(arguments...)
    getter和setter
        定义方式与Object类似
            get name() {return ...}
            set name(parameter) {...}
    继承
        使用extends关键字加上基类名表示从基类继承
        在继承一个基类时，派生类的构造函数必须在使用this的成员前先调用基类的构造函数
            class Derived extends Base
            {
                constructor(parameter)
                {
                    super() //以及所需的其他参数
                    this.thing = parameter
                }
            }
    多态
        派生类中要修改的基类函数直接重新定义即可  
内置Object
    String
        可以使用字符串字面值，或者字符串构造函数来创建一个字符串对象
        构造函数：
            String(thing?: any) //参数为任何可以转化为字符串的类型
        属性：
            length //只读属性
        方法：
            string charAt(index: number)        //返回指定索引的以UTF-16编码的字符，当索引超出时返回空字符串
            number charCodeAt(index: number)    //返回指定索引的以UTF-16编码的字符的编码点，当索引超出时返回NaN，当字符不能使用一个UTF-16编码点编码时，返回其第一个编码点
            number codePointAt(index: number)   //返回指定索引的以UTF-16编码的字符的编码值，解决了charCodeAt()当不能使用一个UTF-16编码点编码的问题
            string concat(...strings: string[]) //拼接字符串，返回拼接后的字符串，最好使用+=运算符代替
            boolean endsWith(searchString[, length])//如果提供了length参数，则只从本字符串的前面length字符查找，length的默认值为str.length
            boolean includes(searchString[, position]) //如果提供了position参数，则只从本字符串的position开始查找，默认值为0
            number indexOf(searchString[, fromIndex])  //如果fromIndex小于0则设置为0，大于str.length则设置为str.length（此时肯定找不到），找不到返回-1
            number lastIndexOf(searchString[, fromIndex]) //与indexOf()类似，但从后往前找
            string toLowerCase()
            string toUpperCase()
            string[] split([seperator, limit])
                当seperator为空字符串时，返回每个UTF-16的编码单元（字符）
                limit表示返回的分割后子字符串的最大数量
            string substring(start[, end]) //返回[start, end)子字符串
            string trim() //移除字符串中多余的空白字符（例如空格、制表符、 换行符），单词之间的空格只保留1个，返回新字符串
            string replace(searchValue: string | RegExp, replaceValue: string)
    Number
        是一个双精度浮点数的wrapper
        JS中的所有数字字面值都是浮点数
        构造函数：
            注意使用new Number()和Number()的不同
            new Number()是构造了一个Number对象
            Number()是一个转换函数，将参数转换为一个number原始类型
        静态成员函数：
            boolean isNan(value)    //当value的类型是Number且值为NaN时才返回true
            boolean isInteger(value)//当value可以表示为一个整型数时为true
                Number.isInteger(999999999999); //true
                Number.isInteger(5.000000000000001); // false
                Number.isInteger(5.0000000000000001); // true
            boolean isFinite(value)
            boolean isSafeInteger(value) //返回value是否在[-(2^53 - 1), 2^53 - 1]之间
        方法：


    Math
        静态属性：
            E       自然对数的底
            LN2     ln(2)
            LN10    ln(10)
            LOG2E   log2(e)
            PI
            SQRT1_2 sqrt(1/2)
            SQRT2   sqrt(2)
    Date
        Date实质上是存储了一个Number，表示从1970-1-1以来所经历的毫秒数
        然而这个Number并不是IEEE754的标准，而是ECMA-262的标准
        构造函数：
            Date()  //返回一个表示当前的时间和日期的字符串，等同于new Date().toString()
            Date(value: number) //value表示从1970-1-1以来的毫秒数
            Date(dateString: string) 
            Date(year, monthIndex[, day, hours, minutes, seconds, milliseconds])
                当year为0-99时表示1900年-1999年，其他范围的数值为其实际字面值年份
                monthIndex为[0, 11]
                day表示日期，为[1, 31]
        静态成员函数：
            number now()    //返回当前时间，即从1970-1-1以来所经历的毫秒数
            number UTC(year[, monthIndex, day, hour, minute, second, millisecond])  //同构造函数，但表示从UTC计算时间
        方法：
            number getFullYear()//返回用4位数表示的年份
            number getDate() //返回一个月内的日期值[1, 31]
            number getMonth()   //返回一年的月份[0, 11]
            number getDay() //返回一个星期的星期值[0, 6]，星期日为0
            number getHours()   //返回一天的小时值[0, 23]
            number getMinutes() //返回一小时的分钟值[0, 59]
            number getSeconds() //[0, 59]
            number getMilliseconds() //[0, 999]
            
            number getTime() //返回从1970-1-1 按UTC开始计算的时间的毫秒数，负数表示在此日期之前的时间
            
            number getUTCFullYear()
            number getUTCDate()
            number getUTCMonth()
            number getUTCDay()
            number getUTCHours()
            number getUTCMinutes()
            number getUTCSeconds()
            number getUTCMilliseconds()

            number getTimezoneOffset() //返回UTC-当前系统时区分钟的差值，负数表示正时区，负数表示负时区，例如北京时间为UTC+8，所以返回-480

            number setFullYear(yearValue[, monthValue, dayValue])
            number setDate(dayValue)
                将dayValue[1, 31]设置为月份的日期值，如果dayValue超过这个月份的日期数，则依次设置到下个月后的相应日期
                如果dayValue为负数，则设置为之前月份的相应日期
                返回从1970-1-1以来到重新设置后的新日期的毫秒数
            number setMonth(monthValue[, dayValue])
            number setHours(hoursValue[, minututesValue, secondsValue, msValue])
            number setMinutes(minutesValue[, secondsValue, msValue])
            number setSeconds(secondsValue[, msValue])
            number setMilliseconds(msValue)

            string toISOString()
                返回一个ISO 8601标准的字符串：YYYY-MM-DDTHH:mm:ss.sssZ
                console.log(new Date('05 October 2011 14:48 UTC').toISOString()); // -> "2011-10-05T14:48:00.000Z"
            string toString()

    Intl
    Array
        构造
            构造并初始化
                let arr = new Array(element...)
                let arr = Array(element...)
                let arr = [element...]
            构造非空Array，但不初始化
                let arr = new Array(length) //注意这个重载的参数只能是数字，否则将构造只包含一个元素的Array
                let arr = Array(length)
                let arr = []; arr.length = length
            构造只包含单个元素的Array
                let arr = Array.of(element)
            .From()
                从其他类型的数据结构构造一个数组，例如Set
        赋值
            可以直接通过给数组没有的索引位置赋值，此时数组的长度会自动增加到要求的索引位置，未填充的元素为undefined
                let arr = [1, 2, 3]
                arr[5] = 0  //arr == [1, 2, 3, undefined, undefined, 0]
        方法
            .forEach(callback(currentValue[, index, array]))
                接收一个函数对象，并应用于对数组中除了undefined之外的每个元素
                currentValue为当前元素的引用
                index为可选的当前元素的索引号
                array为可选的当前数组的引用
            T[] .concat([value1, values...])
                接受一些值或数组，与当前数组合并在一起返回合并后的数组
            string .join(delimiter=',')
                将数组中的元素与delimiter合成成一个字符串
            number push([element1, elements...])
                添加元素到数组末尾，返回添加后的数组的大小
            T pop()
                返回并删除一个末尾的元素
                如果数组为空，返回undefined
            T shift()
                返回并删除数组的第一个元素
                如果数组为空返回undefined
            number unshift(value[, values...])
                添加一个或多个元素到数组的头部，并返回数组的新长度
            T[] slice()
            T[] slice(start)
            T[] slice(start, end)
                当不提供start时，start为0
                当不提供end时，end为arr.length
                当end超过arr.length时，实际使用arr.length
                返回一个新数组，包含原数组中[start, end)的元素
                start和end可以使用负数作为索引，负数的绝对值表示倒数第几个元素（-1为最后一个元素）
            T[] splice(index[, count, elements...])
                删除原数组中索引从index开始的count个元素，并替换为elements...
                当不提供count时，count为(array.length - start)，即删除从index开始后面的所有元素
                当count为0时，相当于将elements...插入到index索引的位置
                当不提供elements时，相当于删除从index开始的count个元素
                返回被删除的元素的数组
            T[] reverse()
                颠倒一个数组，返回颠倒后的数组
            T[] sort([compareFunction])
                对数组元素排序，返回排序后的数组
                这个方法接受一个可选的比较函数
                该比较函数需要接受两个参数并返回一个值，形如：
                    function(a, b)
                    {
                        // return -1 (or any negative number) means a<b
                        // return 0 means a==b
                        // return 1 (or any positive number) means a>b
                    }
            number indexOf(element[, startIndex])
                从数组的startIndex开始向后搜索元素element，如果找到则返回该元素的索引，否则返回-1
            number lastIndexOf(element[, startIndex])
                从数组的startIndex开始向前搜索元素element，如果找到则返回该元素的索引，否则返回-1
            T[] map(callback(currentValue[, index, array]))
                将callback函数作用于数组的每一个元素，并将返回的结果存储到一个新数组
            T[] filter(callback(currentValue[, index, array]))
                将谓词函数callback作用于数组的每一个元素，返回一个新数组，其中的每个元素满足谓词函数
            boolean every(callback(currentValue[, index, array]))
                如果每个元素都满足谓词函数callback（callback函数返回一个布尔值）返回true
            boolean some(callback)
                如果部分元素满足callback，返回true
            T reduce(callback(previousValue, currentValue[, index, array])[, initialValue: T])
                callback函数应该接受一个参数作为当前的值和另一个数组的元素，形如：
                    function(accumulator, currentValue)
                如果未指定initialValue，则第一次调用callback时的参数为数组的第0和第1个元素
            T reduceRight(callback(previousValue, currentValue[, index, array])[, initialValue])
                与reduce类似，但从数组的最后->最前
    BigInt
        代表任意大小的整数，尤其是用于大于Number.MAX_SAFE_INTEGER的整数
        构造函数：
            可以使用在数值后加n的字面值来构造，也可以使用BigInt()作为转换函数来构造（注意BigInt()没有构造函数，所以不适用new关键字）
            const previouslyMaxSafeInteger = 9007199254740991n;
            const myVar = BigInt(123);
        注意通常不要将BigInt直接和Number类做运算，会导致BigInt隐式类型转换为Number，导致精度损失
    Map
    Set
        用于存储独一无二的元素
        构造函数：
            Set([iterable]) //使用可选的可迭代容器来初始化Set
        方法：
            Set add(value) //返回添加后的原Set的引用
            clear()
            boolean delete(value) //删除Set中value的元素，删除成功返回true
            boolean has(value)
            IterableIterator values() //返回一个用来迭代Set中元素的迭代器
    WeakMap
    WeakSet    
迭代器
    任何对象只要定义了一个满足条件的next()方法即可成为一个迭代器
    next()方法需要返回一个具有以下两个属性的对象
        value：返回下一个值
        done：返回代表是否迭代完毕的布尔值
    一个简单代表数字范围的迭代器：
        function makeRangeIterator(start = 0, end = Infinity, step = 1) {
            return {
                current: start,
                end,
                step,
                next: function () {
                    if (this.current <= this.end)
                    {
                        const tmp = { value: this.current, done: false }
                        this.current += this.step
                        return tmp
                    }
                    else
                        return {value: this.end, done:true}
                }
            }
        }

        let it = makeRangeIterator(0, 10)
        for (let result = it.next(); !result.done; result = it.next())
            console.log(result.value)
Generator
    Generator是一种特殊的函数，在调用这类函数会直接返回一个与其关联的迭代器来简化迭代器的定义
    声明Generator函数需要在function关键字后加一个星号*
    这个函数使用yield语句代表迭代器next().value，并自动设置终止条件
    例如上面的数字范围的迭代器可以改写为
        function* makeRangeIterator(start = 0, end = 100, step = 1) 
        {
            let iterationCount = 0;
            for (let i = start; i < end; i += step) 
            {
                iterationCount++;
                yield i;    //作为value
            }
            return iterationCount;
        }
可迭代对象
    可迭代对象就是一个定义了Symbol.iterator属性的对象
    
异常
    异常机制由try catch finally语句构成
    finally语句块无论异常是否发生都会执行
    try catch可以嵌套，内层的try如果没有对应的catch语句，则必须有一个finally语句块
    标准异常
        Error
            通常作为用户自定义异常类型的基类
            构造函数：
                Error(message?: string)
            属性
                message
                name
                    默认为"Error"
        AggregateError
            通常用作一些Error的集合
            构造函数：
                AggregateError(errors[, message])
                    errors为一个异常数组
            属性：
                message
                name
                    默认为"AggregateError"
        EvalError
            在全局的eval()中遇到异常时抛出，现在JS标准库已经不再抛出这个异常，只用作向后兼容
        RangeError
            表示一个值不在允许的范围内，例如数组越界
            构造函数：
                RangeError(message)
        ReferenceError
            表示一个引用一个不存在（已销毁）的对象
            构造函数：
                ReferenceError(message)
            
        SyntaxError
            在JS引擎执行代码时遇到非法语法时抛出
            构造函数：
                SyntaxError(message)
        TypeError
            在类型不符时抛出，通常为以下的情况
                函数实参与所期望的类型不兼容
                运算符的操作数类型不兼容
                修改一个不可修改的值
            构造函数：
                TypeError(message)
            
        URIError
            构造函数：
                URIError(message)
模块
    模块文件名常以.mjs结尾，相比.js能更清楚的表明这是一个模块，然而TypeScript不支持.mjs文件
    export
        要导出模块中的功能，在要导出的对象前加export关键字
        可以export以var，let，const定义的变量、function、class
        但不能在函数内export
            export const name = "square"
            export function draw() {...}
        还可以在一条export语句内使用花括号{}将所要export的内容括起来，一次性全部export
            export {name, draw}
    default export 
        一个模块文件可以有一个default export的函数
        该函数使用export default function() {}定义，不能有函数名
    import
        要使用一个模块的功能，使用import关键字加上花括号{}括起来的一系列用逗号分隔的名称，加上from关键字加上模块的路径
            import {name, draw} from "./modules/square.js"
        所导入的名称就像是在本文件内定义的一样使用
    import default
        import一个default export函数时的语法与import普通名称一样，然而由于一个模块只能由一个export default，所以无需花括号
            import something from "path"
        import模块中的default export时相当于给这个函数一个名称
    与普通script文件不同的是，模块文件：
        自动延迟装载
        自动使用strict模式
        只执行一次，即使它被多个<script>标签引用
    解决命名冲突：
        如果import了多个模块，其中包含相同的名称则会造成命名冲突
        可以在export时加上as关键字给所要export的名称一个新名称
            //module.js
            export{
                function1 as newFunctionName,
                function2 as anotherNewFunctionName
            }
            //main.js
            import {newFunctionName, anotherNewFunctionName} from "module.js"
        类似的也可以在import时加上as关键字给所要import的名称一个新名称，这是更常见的做法
            //module.js
            export {function1, function2}
            //main.js
            import{
                function1 as newFunctionName,
                function2 as anotherNewFunctionName
            } from "module.js"
        更好的做法是将一个模块内的所有export都导入，作为一个模块文件
            import * as MyModule from "module.js"
        然后使用MyModule作为module.js模块中导出名称的名称空间
            MyModule.function1()
            MyModule.function2()
    合并模块
        将多个子模块合成为一个模块集合，并导出为一个名称空间
        例如新建一个.js模块文件，并声明以下export
            export { Square } from "./shapes/square.js"
            export { Circle } from "./shapes/cicrcle.js"
        然后在main.js中只需从这个模块集合中导入各个子模块
            import {Square, Circle} from "./shapes.js"
    动态导入
        import("path").then((module) => {
            //Do something with the module
        })
异步编程
    回调函数
        在老式异步编程中，需要异步运行的函数通常接收一个回调函数作为参数
        当异步操作完成后将执行回调函数，例如addEventListener函数
            button.addEventListener("click", () => {/*回调函数体*/})  
    promise
        promise是一个代表某个异步操作完成的对象
        对一个promise调用.then(function)方法来设置这个promise执行完成后要执行的操作（应该是一个返回promise的函数），其结果仍然是一个promise
        所以可以使用.then()方法来连接多个异步操作，形成一个异步操作链
        promise有可能执行失败，所以可以使用.catch()来设置异常处理函数，如果异步操作链中哪一个操作发生异常都会直接跳转到异常处理函数
            doSomething().then
            (
                function(result)
                {
                    return doSomethingElse(result);
                }
            ).then
            (
                function(newResult)
                {
                    return doThirdThing(newResult)
                }
            ).then
            (
                function(finalResult)
                {
                    console.log(finalResult)
                }
            ).catch(failureCallback)    //异常处理函数
        使用箭头函数，上面代码可以进一步简化为：
            doSomething()
            .then(result => doSomethingElse(result))
            .then(newResult => doThirdThing(newResult))
            .then(finalResult => console.log(finalResult))
            .catch(failureCallback)    //异常处理函数
        当promise链完成后可能希望运行一些其他的代码，可以使用.finally()方法，这个方法无论promise是否成功都会执行
            myPromise
            .then(result => doSomething(result))
            .catch(e => handleError(e))
            .finally(runFinalCode)
        静态成员函数：
        .all()
            接收一个promise对象数组并返回一个promise，这个promise在promise对象数组中所有的promise都产生结果时才会执行
            这个新promise的.then()方法同样接收一个函数参数（应该是一个接收原promise对象数组的结果的函数）
                Promise.all([a, b, c]).then(values => ...)    
    等待函数
        注意这些函数的执行都是异步的，即在主线程空闲时才可能会跳转到这些函数来执行
        setTimeout(function[args...], [delay], [args...])
            在等待delay毫秒后执行函数参数function，这个函数可以接收可选的参数args...
            如果delay未指定，则为0，表示不等待，当主线程空闲时立即执行function
            函数返回一个对象，可以在delay到达前调用clearTimeout()取消这个任务
        setInterval(function[args...], [delay], [args...])
            每delay毫秒内执行一次function，这个函数可以接收可选的参数args...
            由于delay包含函数执行的时间，所以delay应该大于执行function所需的时间
            如果需要经过一段确定的时间后执行某个操作，应该使用递归调用setTimeout()的方法，例如
                setTimeout(function run()
                {
                    //...
                    setTimeout(run, 100);
                }, 100);//每过100毫秒执行一次run()函数
            函数返回一个对象，可以调用clearInterval()取消
        clearTimeout(timeoutID)
            取消执行timeoutID所指定的定时任务，timeoutID应该是由setTimeout()所返回的对象
        clearInterval(intervalID)
            取消执行intervalID所指定的定时任务，intervalID应该是由setInterval()返回的对象
        requestAnimationFrame(callback[timestamp])
            类似于setInterval，为优化动画显示而产生
            这个函数将尽可能以高帧率绘制动画，但是当动画不可见时则停止执行来优化性能
            callback是一个需要定时执行的回调函数，在绘制前执行，函数可以接受一个可选的参数timeStamp来表示时间信息，例如：
                function draw()
                {
                    //drawing code
                    requestAnimationFrame(draw);
                }
                draw();
    async/await
        基于ECMAScript 2017，JS引进了async函数和await关键字
        async函数和await关键字基于promise机制
        在函数的function关键字前加async关键字使得函数的返回值变为原先返回值的promise类型
        在箭头函数中的圆括号()前加async关键字
            async function sayHello() { return "hello" }
        在一个async函数中在另一个async的函数调用前使用await关键字，可以使得这个函数调用变为异步，即代码暂停，直到所调用的函数返回的Promise对象完成执行
        在async函数中要处理异常，使用普通的try catch方法
        使用async/await机制可以使得异步代码类似于传统非同步代码
        注意一个常见误区：当希望多个并不互相依赖的函数实际上并发执行时，不要直接对其使用await调用
            await doSomething()
            await doSomethingElse()
            await doThirdThing()
        会导致其实际上是顺序执行的，因为doSomething()执行完才会继续执行doSomethingElse()
        应该将他们返回的Promise对象存储到一个变量中，然后对这些变量进行await
            const promise1 = doSomething()
            const promise2 = doSomethingElse()
            const promise3 = doThirdThing()
            await promise1
            await promise2
            await promise3
        或 await Promise.all([promise1, promise2, promise3])
严格模式
    在一个文件的开头加上"use strict";字符串将使得本文件执行在严格模式下
    在一个函数内加上"use strict";字符串将使得本函数执行在严格模式下

JSON（Javascript object notation）
    静态成员函数：
        .parse(text)
            将字符串text按JSON来解析，并返回一个对象
            如果字符串text不符合JSON语法，抛出SyntaxError异常
        .stringify(value)
            将对象value转换为JSON格式的字符串并返回
HTTP（Hyper text transfer protocol）
    服务器<->客户端间的通信协议
    Http请求是无状态的，意思是每个http请求之间都是互相独立的
    要记录状态，需要使用本地存储local storage、cookies等技术
    HTTPS（hyper text transfer protocol secure）
        数据使用SSL（secure sockets layer）或TLS（transport layer security）技术加密
    HTTP请求方法：
        GET
        POST
        PUT
        DELETE
    状态码
        
REST（Representational state transfer）

文件IO
    FileReader
    

TS
1.变量
    变量的类型用:写在变量名的右边
        Boolean
        null
        undefined
        Number  整数或浮点
        BigInt  任意精度的整数，例如很大的整数
        String
        Symbol
        Object （也包括函数）
        除了Object，其他类型在赋值时都是复制，即拷贝，Object在赋值时是复制引用
        let isDone: boolean = false
        let decimal: number = 6         //十进制字面值
        let hex: number = 0xf00d        //十六进制字面值
        let binary: number = 0b1010     //二进制字面值
        let octal: number = 0o744       //八进制字面值
        let big: bigint = 100n

    TS中新增的类型
        数组：
            let list: number[] = [1,2,3]
            let list: Array<number> = [1,2,3]\
        元组：
            元组的类型声明后就不可改变，不与元组类型兼容的赋值会出错
            元组的类型写在一对方括号中[]，值也用一对方括号[]括起来
                let x: [string, number] = ["hello", 3]
            访问元组的元素的方式与数组类似，都使用方括号加索引的形式
                x[0]    //"hello"
        枚举：
            定义一个枚举类型
                enum Type{
                    //values
                }
            定义一个枚举类型的变量
                let myEnum: Type = Type.Value
            可以在定义枚举类型时给其中的一些或枚举值赋数值，没有赋值的枚举值将从最后一个赋值的枚举值后+1，以此类推
                enum Color{
                    Red = 1,
                    Green,  //自动赋值为2
                    Blue    //自动赋值为3
                }
            然而不带赋值枚举值必须要么放在最前面，要么放在常量枚举值（可以在编译期计算的枚举值）之后
                enum Thing
                {
                    Thing1 = GetValue() //非常量枚举值
                    Thing2  //错误，需放在非常量枚举值之前
                }
            枚举值的名称可以作为string使用，引用枚举名使用数组下标语法，索引为需要引用的枚举值
                let colorName: string = Color[1]    //Red
            常量枚举值
                将enum声明为const将禁止非常量枚举值的赋值
                使用常量枚举值时，编译器会完全抹除这个枚举值的信息，直接使用其值代替
                    const enum Direction {...}
        unknown:
        any:
            any类型将迫使Typescript编译器停止类型检查，使用any类型与Javascript类似
            与unknown不同，使用any类型时可以使用其可能存在或不存在的属性、方法等
                let anyThing: any = 4
                anyThing.toLower()  //Typescript编译器将不检查此处的toLower()是否合法，虽然其实不合法
            由于any类型降低了类型安全性，所以应该尽量避免使用
        void：
            只有两种用法，一种是用于没有返回值的函数
                function DoNotReturn() : void {...}
            或者是undefined和null类型的变量
                let unusable: void = undefined
                let unusable: void = null
        undefined
        null
            只能赋值给其对应的undefined和null类型还有void类型
        never
            只有一种用法，就是不返回的函数（函数永远抛出异常，或者是死循环）
                function error(message: string) : never
                {
                    throw new Error(message)
                }
        object
            非number, string, boolean, bigint, symbol, null, undefined的类型
        字面值类型
            可以使用type关键字把字符串、数值、布尔值作为类型来使用，得到类似于枚举类型的行为，例如：
                type Easing = "ease-in" | "ease-out" | "ease-in-out";//声明了一个Easing的字符串字面值类型
                type Dice = 1 | 2 | 3 | 4 | 5 | 6
    类型合集：
        有时需要表达一个对象可能是几种类型之一，使用逻辑或|运算符来表示
    类型并集：
        有时需要表达一个对象同时满足多个接口，使用逻辑运算符&来表示

    编译期类型转换：
        有时可能需要将变量做类型转换，迫使Typescript编译器将其作为另一个类型（如果有充足的理由）
        此时编译器将不检查其是否真的可以进行这样的类型转换
        由于Typescript编译成Javascript后类型实际上不存在，所以这样的类型转换并不会产生运行期性能损耗
        有两种转换的形式：
            将所要转换的变量加as关键字和所要转换为的类型
                let someValue: unknown = "this is a string"
                let strLength: number = (someValue as string).length
            在一对尖括号<>中加上转换为的类型，后加变量名
                let someValue: unknown = "this is a string"
                let strLength: number = (<string>someValue).length
    keyof关键字
        keyof Type返回Type中所有的属性名的类型合集，例如
            interface Person 
            {
                name: string;
                age: number;
                location: string;
            }
            type K1 = keyof Person; // "name" | "age" | "location"
            
3.函数
    函数的类型
        函数的类型由参数的类型和返回值的类型决定
        形如下面的函数
            function FunctionName(parameter: ParameterType): ReturnType {...}
        其类型为：
            (parameter:ParameterType) => ReturnType
        其中parameter可以随意，但不能没有
        例如:
            function add(x: number, y: number)：number
            {
                return x + y
            }
        其类型为：(x: number, y: number) => number
        所以它可以赋值给一个相同类型的变量
            let myAdd: (x:number, y: number) => number = add
        Typescript可以根据return语句来自动判断返回值的类型所以无需写返回值的类型，所以上面的add又可以写成
            function add(x: number, y: number) 
            {
                return x + y;    
            }
        Typescript还可以根据赋值变量的类型来推断函数的类型，也可以根据函数的类型来推断要赋值的变量的类型
        所以将一个函数赋值给变量时，两端只需一端明确类型即可
            let myAdd = function (x: number, y: number): number //由函数推断变量类型
            {
                return x + y;
            };

            // myAdd has the full function type
            let myAdd2: (baseValue: number, increment: number) => number = function (x, y)  //由变量推断函数类型
            {
                return x + y;
            };
    可选参数
        与接口的可选属性类似，在函数参数名后加问号?表明该参数是可选参数
        可选参数必须位于必须参数的后面
    默认参数
        可以用赋值的形式给函数形参加一个默认参数，当实参个数==形参个数时使用实参的值或这对应实参非undefined，否则使用默认参数的值
        默认参数不要求必须处于必须参数之后，然而如果调用时要使用默认参数的值，需要显式传递一个undefined        
        默认参数的类型与可选参数相同，即使用默认参数的函数与可选参数的函数类型相同
        例如下面的FullName和FullName2函数的类型相同
            function FullName(firstName: string, lastName?: string) {...}
            function FullName2(firstName: string, lastName:string = "Smith") {...}
    可变参数
        用...Parameter: Type[]表示默认可变参数
        Parameter是一个Type类型的数组
        可以传0~无穷多个实参给这样的可变参数
            function add(x: number, ...args: number[])
            {
                return x + args.reduce((lhs: number, rhs: number) => lhs + rhs);
            } 
            console.log(add(1, 2, 3, 4, 5));    //15
    重载
        函数重载的方式是先声明所有要重载的版本的类型
        然后在定义中将参数和返回值声明为any类型，在函数体内使用typeof来判断参数的真实类型来使用不同的实现
            function add(x: number, ...args: number[]) : number;
            function add(x: string, ...args: string[]) : string;

            function add(x: any, ...args: any[]) :any
            {
                if (typeof x == "number")
                {
                    //...
                }
                else if (typeof x == "string")
                {
                    //...
                }
            }
    接口就是满足一些条件的类型，例如包含某个符合类型的属性、某些符合类型（接收某些类型的参数且返回特定类型）的方法
    Object接口
        匿名接口
            可以直接用类似于定义Object的语法定义一个匿名接口    
            function PrintLabel(labelObj: { label: string})  //函数接收一个匿名接口类参数，这个接口类需要有一个名叫label且类型为string的属性
            {
                console.log(labelObj.label)
            }
            let myObj = {size: 10, label: "My Object"}
            PrintLabel(myObj)
        命名接口
            使用interface关键字定义一个接口
            如上例的匿名函数参数接口可以写为
                interface LabeledObj
                {
                    label: string;
                }
                function PrintLabel(labelObj: LabeledObj)
                {
                    console.log(labelObj.label)
                }
                let myObj = {size: 10, label: "My Object"}
                PrintLabel(myObj)
            可选属性
                命名接口中的某些属性可能是非必要的，在接口定义中这样的属性名后加问号?表示该属性可选
                    interface LabeledObj
                    {
                        label?: string
                    }
                在判断传入的参数是否具备这个可选属性时，只需使用一个if语句，条件为可选属性的名称
                    if(labelObj.label)
            只读属性
                只读属性是定义了对象后就不能再修改的属性，类似于const对应于对象的关系
                在属性名前加readonly关键字声明一个只读属性
        然而，如果作为实参的Object不存在接口中的任何属性也会发生编译错误，即使接口中声明的属性都是可选属性
        Object字面值的强化检查:
            当以Object字面值作为实参时，字面值中不能有接口中未定义的属性
            即Object字面值的类型检查比Object对象更严格
            比如
                PrintLabel({size: 10, label: "My Object"})将无法通过编译，原因是size未在interface LabeledObj中定义
    函数接口
        满足一定类型要求的函数也可以定义为接口
        一个函数的类型由：参数的类型、返回值的类型所决定
        参数的名称可以随意
            interface SearchFunction{
                (source: string, searchString: string) : boolean    //接收两个string参数并返回一个布尔值的函数接口
            }  
        声明了函数接口后，即可将一个函数赋值给同样类型接口的变量
            let mySearch: SearchFunc
            mySearch = function(source: string, searchString: string)
            {
                return source.search(searchString) > -1
            }
        由于接口已经描述了函数的参数类型和返回值类型，所以可以在赋值时省略
            let mySearch: SearchFunc
            mySearch = function(source, searchString)
            {
                return source.search(searchString) > -1
            }
    继承接口
        接口可以相互继承，形成更大的接口，即派生接口中包含所继承的接口中所声明的所有属性
        继承一个接口使用extends关键字加接口名
            interface Derived extends Base{...}
        一个接口可以继承多个接口
            interface Derived extends Base1 Base2 {...}
4.类
    Javascript中的类数据成员只需在构造函数中使用this.赋值即可
    在Typescript中类的数据成员需要先列出其名称和类型
        class ClassName
        {
            member: Type
            constructor(data: Type)
            {
                this.member = data
            }
        }
    可见性：
        可以在成员名（无论是数据成员还是成员方法或构造函数）前加public private protected来修改其可见性
        类成员默认为public
        private关键字使得成员对外不可见
        protected关键字使得成员只对派生类可见
        将构造函数声明为protected使得该类只能由派生类构造，对外不能构造这个类的对象
    快速声明类成员
        先声明所有数据成员，再在构造函数中对数据成员赋值，会造成代码重复
        可以在构造函数的参数中直接将参数加上可见性修饰符，使得该参数即成为数据成员，无需前向声明
            class Person
            {
                constructor(public name: string)    //name即成为Person类的数据成员，可见性为public
                {}
            }
    getter和setter
        如果一个属性只有getter没有setter将自动成为readonly
    静态成员
        在成员名前使用static关键字将成员声明为静态
        要访问类的静态成员，要在前面加类名.
            class Point
            {
                static origin = { x: 0, y: 0 };
                constructor(public x: number, public y: number) { }
                distanceFromOrigin()
                {
                    return Math.sqrt(Math.pow(this.x - Point.origin.x, 2) + Math.pow(this.y - Point.origin.y, 2));
                }
            }
    抽象类
        抽象类只能通过派生类继承，不能定义对象
        类似于接口，但是可以提供公用的实现
        可以将方法声明为abstract，派生类必须提供抽象方法的实现
        没有提供实现的方法必须声明为abstract
    类也可以作为接口来使用
        class Point {...}
        interface 3DPoint extends Point { z: number }
        let point:3Dpoint = {x:1, y:2, z:3 }    //注意这里不能用new
5.模板
    函数模板
        在函数名后加一对尖括号<T>表示这是一个模板参数并引入了一个模板参数
        可以引入多个模板参数，用逗号隔开
        普通函数：
            function identity(arg: any): any { return arg; }
        这个函数的类型为：
            (arg: any) => any
        这个函数符合这样的函数接口
            interface identityFunction
            {
                (arg: any): any;
            }
        模板函数：
            function identity<T>(arg: T): T { return arg; }
        这个函数的类型为：
            <T>(arg: T) => T;
        这个函数符合这样的函数接口
            interface identityFunction
            {
                <T>(arg: T): T;
            }
    类模板
        在类名后加一对尖括号<T>表示这是一个类模板
            class ClassName<T>
            {
                ...
            }
    模板限制
        函数模板中只能执行模板参数T本身所支持的操作，即所有可能的T所共有的操作
        在没有对T进行限制的情况下，能执行的操作非常有限
        所以需要对T进行限制，使得编译器知道T所能支持的操作
        这通常需要借助定义接口来实现，然后限制T符合这一接口
            interface HasLength
            {
                length: number
            }
            function LogLength<T extends HasLength>(arg: T)
            {
                console.log(arg.length)
            }
DOM
    Document
        .getElementById()
        .getElementByTagName()
        .querySelector()
        .querySelectorAll()
    HTMLElement
        .style
        注意在Javascript中style的属性是驼峰命名camelCase，而CSS中是全小写加连字符lower-case
    <input> 使用.value属性来获取输入的字符串
    Canvas
        首先捕获一个<canvas>的引用
            const convas = document.querySelector("myCanvas")
        然后使用.getContext(Mode: string)创建一个绘图的上下文环境，mode可选"2d", "webgl", "webgl2"
            const context = convas.getContext("2d")
        坐标转换
            所有绘制的坐标默认都是从canvas对象的左上角为原点，向右为x轴正方向，向下为y轴正方向计算的
            如果需要转换坐标，例如将canvas中心点作为原点，使用.translate()函数
                .translate(x, y)
                    将原坐标(x,y)作为新的原点
        绘制矩形
            .fillRect(x, y, width, height)
        自定义绘图路径
            .beginPath()
            .moveTo(x, y)//绘制直线路径
            .arc(centerX, centerY, radius, startAngle, endAngle, isCounterClockWise)//绘制弧线
            .fill()     //填充路径
            .stroke()   //只绘制边缘，不填充
        绘制文字
            注意绘制文字的坐标是从左下角开始而绘制其他图形的坐标都是从左上角开始
            .fillText(text, bottomLeftX, bottomLeftY)
            .strokeText(text, bottomLeftX, bottomLeftY)
        绘制图片：
            .drawImg(image, x, y)
            .drawImg(image, x, y, width, height, imageX, imageY, imagePartWidth, imagePartHeight)
                x, y 定义了所要绘制的原图的
                imageX, imageY 定义了所要绘制的原图部分在原图的左上角的坐标
                imagePartWidth, imagePartHeight 定义了所要绘制的原图部分的
        动画

Ajax（Asynchronous Javascript and XML）
    是指用XMLHttpRequest()这样的函数来直接向服务器发起Http请求从而更新网页的部分内容而不必刷新整个页面的获取数据的方式
    XMLHttpRequest:
        首先构造一个XMLHttpRequest对象：let request = new XMLHttpRequest()
        然后使用.open(method: string, url)来创建一个请求
        最后使用.send()来发送请求
        请求默认是使用async方式执行的，所以如果需要在收到应答后执行某些操作，可以给.onload属性赋值一个回调函数
    fetch():
        fetch(url)返回一个Promise对象
    blob（binary large object）

Vue:
    计算属性
        有时候想在template中使用一些逻辑，如果直接使用js表达式，可能会导致template冗长难以调试
        可以在导出对象中的computed属性中加入函数返回一个值，在template中按访问属性的方法来调用这个函数得到返回值
        export default
        {
            ...
            computed:
            {
                myComputedProperty()
                {
                    return {...}
                }
            }
        }

        <template>
            <span> {{myComputedProperty}}</span>
        </template>

        计算属性用起来与methods中定义函数类似
            export default
            {
                ...
                methods:
                {
                    myComputedProperty()
                    {
                        return {...}
                    }
                }
            }
            <template>
                <span> {{myComputedProperty()}}</span>
            </template>
        但计算属性有缓存机制，避免不必要的重复计算
        但如果在计算属性中使用不带通知机制的对象，例如Date()，则意味着下次调用不会更新它的值，这时需要改用methods
        计算属性默认是只读的，如果需要可写，需要显示定义一个get()和set()
            computed:
            {
                fullnName:
                {
                    get()
                    {
                        ...
                    }
                    set()
                    {
                        ...
                    }
                }
            }
    绑定
        数据绑定
            字符串插入
                使用{{字符串名}}来引用data()函数返回的某个变量
                    <span>Messgae: {{msg}}</span>
            HTML插入
                如果使用{{}}语法，会导致直接插入原始HTML字符串
                如果需要将HTML字符串解释为DOM，需要使用v-html=""指令
                    <p>Using v-html directive: <span v-html="rawHtml"></span></p>
            属性绑定
                要在HTML的属性里插入字符串，需要使用v-bind:<属性>=""指令
                    <div v-bind:id="dynamicId"></div>
                简写
                    由于属性绑定使用频繁，所以可以省略掉v-bind，只写出冒号后的内容
                        <div :id="dynamicId></div>
                绑定布尔值
                    布尔值的绑定原则依据JS的真假值
                        <button :disabled="isButtonDisabled"></button>
                绑定对象
                    例如要在HTML属性中绑定多个属性，可以直接使用在data()中返回的一个对象
                    export default
                    {
                        ...
                        data()
                        {
                            return {
                                objectOfAttrs:
                                {
                                    id: 'container',
                                    class: 'wrapper'
                                }
                            }
                        }
                    }

                    <div v-bind="objectOfAttrs"></div>
                动态属性绑定
                    要绑定的属性也可以是用方括号[]括起来的动态的字符串变量
                        <a v-bind:[attributeName]="url"></a>
                        此时attributeName和url都是一个变量
                绑定class
                    使用双引号+花括号"{}"将class的值括起来
                        <div :class="{active: isActive}"></div>
                    vue的class可以和普通html class并存，这是因为普通html class没有v-bind:
                        <div class="static" :class="{active: isActive}"></div>
                绑定style
                    使用双引号+花括号"{}"将style的值括起来
                        data()
                        {
                            return {
                                activeColor: 'red',
                                fontSize: 30
                            }
                        }

                        <div :style="{color: activeColor, fontSize: fontSize + 'px'}"></div>
                    也可以将style绑定到一个JS对象
                        data()
                        {
                            return {
                                styleObject: {
                                    color: 'red',
                                    fontSize: 30
                                }
                            }
                        }

                        <div :style="styleObject"></div>
                    也可以将style绑定到一个JS的对象数组，此时数组中的对象将会被合并成一个对象
                        <div :style="[baseStyles, overridingStyles]"></div>
                    
            使用表达式
                在可以用绑定的地方都可以用JS表达式
                必须是一个单一的JS表达式
            
        方法绑定
            方法事件处理器
                使用@<html事件>="方法名"的语法
                    <button @click="onClick"/>
            内联事件处理器
                也可以对方法增加参数，使之成为内联事件处理器
                    methods:
                    {
                        say(message)
                        {
                            alert(message);
                        }
                    }

                    <button @click="say('hello')"></button>
                内联事件处理器可以使用一个$event变量，在调用事件处理函数时，该变量为原始的DOM事件
                    <button @click="warn('somgthing', $event)"></button>
                
        运行时选择渲染
            v-if="value"使得该node在value为真时才渲染
            v-else 使得与v-if配对的node在value为假时才显示
            v-else-if
            v-show="value"使得该node在value为真时才显示，否则隐藏，实际上是通过CSS的display属性来控制的，所以总是会存在在DOM中
                所以当元素可能经常要切换显示/隐藏状态时使用v-show
        v-for
            v-for绑定到一个JS数组
                data()
                {
                    return {
                        items: [{message: 'Foo'}, {message: 'Bar'}]
                    }
                }

                <li v-for="item in items">
                    {{item.message}}
                </li>
                v-for还支持第二绑定参数，绑定到当前元素的索引
                    <li v-for="(item, index) in items">
                        ...
            v-for绑定到一个对象
                按JS for in循环的方式迭代对象的每一个属性的值
                data()
                {
                    return {
                        myObject:
                        {
                            title: 
                        }
                    }
                }

                <ul>
                    <li v-for="value in myObject">
                        {{value}}
                    </li>
                </ul>
                v-for在绑定到对象时支持两个绑定参数，此时按<value, key>的形式迭代对象的属性
                    <li v-for="(value, key) in  myObject">
                        ...
                或三个参数，按<value, key, index>的形式迭代对象的属性
                    <li v-for="(value, key, index) in myObject">
                        ...
            v-for绑定整数范围
                <span v-for="n in 10">{{n}}</span>
    组件
        组件注册
            全局注册
                在App.vue中注册的组件可以在整个app的任何一个.vue文件中使用
                调用app的component()方法注册全局组件
                    const app = createApp({})
                    app.component(
                        'MyComponent',
                        {
                            //实现
                        }
                    )
                MyComponent放到单独的.vue文件时，需要import再注册
                    import MyComponent from './MyComponent.vue'
                    app.component('MyComponent', MyComponent)
                .component()方法可以串联调用
                    app
                    .component('ComponentA', ComponentA)
                    .component('ComponentB', ComponentB)
                    .component('ComponentC', ComponentC)
            局部注册
                在某一个父组件的.vue文件中注册一个子组件
                在父组件的components对象中添加要注册并使用的子组件
                    import ComponentA from './ComponentA.vue'
                    export default{
                        components:
                        {
                            ComponentA
                        }
                    }