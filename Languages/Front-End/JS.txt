-1.包管理
    npm是Javascript的包管理软件，在安装node.js时已经自动安装了
    node.js的更新频率不如npm，可以通过npm install npm@latest -g 命令来手动更新npm
    在Windows中，默认下npm下载的包的位置在：C:\Users\Peter\AppData\Roaming\npm\node_modules\npm
    可以通过npm --help来查看
0.什么是Javascript，什么是ECMAScript
    ECMA（European computer manufacturers association）是一个国际标准化组织
    这个标准化组织指定了许多不同领域的标准，这些标准以ECMA-xxx命名，其中xxx是数字
    其中ECMA-262标准，制定了一个ECMAScript编程语言，换句话说ECMAScript这个编程语言所基于的标准就是ECMA-262
    目前为止ECMAScript这门语言迭代到了第11版（在2020年6月标准化）
        ECMAScript 2015 -> 6th edition -> ES6
    Javascript是ECMAScript的一个变种，在ECMAScript的基础上添加了额外的功能，可以看成这样的关系
        Javascript = ECMAScript + DOM(Document object model) + Bom (browser object model)
1.变量
    定义变量有3个关键字：
        var，在函数内为函数作用域，在函数外为全局作用域
        let，块作用域
        const，块作用域
    当定义变量却没有赋值时，变量的值为undefined
    使用var定义变量时，该变量的作用域会被提升到当前作用域的顶部，即使此时没有赋值，所以此时其值为undefined
        console.log(x); //undefined
        var x = 3;
        console.log(x); //3
    变量的类型有8种：
        Boolean
        null
        undefined
        Number  整数或浮点
        BigInt  任意精度的整数，例如很大的整数
        String
        Symbol
        Object （也包括函数）
        除了Object，其他类型在赋值时都是复制，即拷贝，Object在赋值时是复制引用
    JS是动态类型语言，意思是可以对变量赋予不同类型的值
    作用域
        使用var定义的变量的作用域不受代码块限制，例如：
            var x = 1;
            {
                var x = 2;
            }
            console.log(x); // outputs 2
        使用let和const定义的变量作用域受代码块的限制，应该避免使用var
2.字面值
    Array
        是用方括号[]扩起来的一些值，用逗号,隔开
        如果有连续的逗号，则被省略的值为undefined，但注意不要在数组字面值的末尾加上逗号
            let animals = ["Lion", , "Angel"] //animals[1]===undefined
    Boolean
        true/false
        评估为false的值：
            false
            undefined
            null
            0
            NaN
            ""空字符串
        注意Boolean变量与Boolean字面值不同
            var b = new Boolean(false);
            if (b)
                console.log("b true")       //b true
            else
                console.log("b false")

            if (b == true)
                console.log("b == true") 
            else if(b == false)
                console.log("b == false")   //b == false

            if (b === true)
                console.log("b === true")
            else if(b === false)
                console.log("b === false")
    Floating point

    Numeric
        0o或0O开头表示八进制
        0x或0X开头表示十六进制
        ob或0B开头表示二进制
    Object
        是用花括号{}扩起来的一些命名的属性，属性之间用逗号,隔开
        属性可以是任何字符串，不一定要符合标识符命名规则
    Regex
        是用一对斜线/扩起来的正则表达式
    String
        普通字符串字面值
            是用一对单引号或双引号扩起来的字符串
            JS也使用其他语言中常见的转义字符
        模板字符串
            是用一对``括起来的字符串
            相比普通字符串，模板字符串增加了表达式插入的功能，用${表达式}将表达式的值插入到字符串中
                var thing = "world"
                console.log(`Hello, ${thing}`)//输出Hello, world
操作符
    delete
        delete操作符用来删除一个object的属性
            delete object.property
            delete object[property]
            delete object[index]
        delete操作成功时返回true，否则返回false
        注意访问一个不存在的属性时返回undefined，但将一个属性赋值为undefined并不会删除这个属性
    typeof
        typeof返回一个对象的类型
            typeof object
            typeof (object)
    in
        in判断一个属性名是否存在于一个对象中，并返回一个布尔值
            property in object
            propertyIndex in object
        例如：
        // Arrays
        var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
        0 in trees;        // returns true
        3 in trees;        // returns true
        6 in trees;        // returns false
        'bay' in trees;    // returns false (you must specify the index number,
                        // not the value at that index)
        'length' in trees; // returns true (length is an Array property)

        // built-in objects
        'PI' in Math;          // returns true
        var myString = new String('coral');
        'length' in myString;  // returns true

        // Custom objects
        var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
        'make' in mycar;  // returns true
        'model' in mycar; // returns true
    instanceof
        用来判断一个对象是否是属于一个类的实体，并返回布尔值
            object instanceof type
        
语句
    for in 用来循环一个对象的所有属性
    for of 用来循环一个可迭代的对象，例如容器
        for(var object of someArray) {...}
2.函数
    与使用var定义变量类似，函数的作用域也会被提升到当前作用域的顶部
3.注释
    //单行注释

    /*
        多行注释
    */
Object
    构造：
        可以直接用Object字面值的方式，即一个花括号{}来初始化这些属性
            var myCar = {
                make = "Ford",
                year = 1969
            };
        也可以先创建一个空Object变量，再赋值，此时相当于向这个Object中添加属性
            var myCar = new Object();
            myCar.make = "Ford";
            myCar.year = 1969;
        也可以先定义一个构造函数，然后使用new来调用这个构造函数
        如果构造函数无需参数，可以省略调用new时的圆括号var object = new ClassName;
            function Car(make, year)
            {
                this.make = make;
                this.year = year;
            }
            var myCar = new Car("Ford", 1969);
        也可以用Object.create(obj)方法利用现有的Object作为prototype来构造新Object，新Object的__pro__将指向obj
            var Car = {
                make: "Ford",
                year: 1969 
            }
            var myCar = Object.create(Car)
            但要注意，此时新Object内没有定义任何属性，即没有自己的属性
            console.log(myCar)  //输出为空
            这个机制通常用于实现继承
    方法：
        将函数放到Object里，称为方法
    getter和setter
        是一种特殊的方法，用于获取和设置某个成员的值
        定义一个getter：
            get myGetter()
            {
                return thing
            }
        定义一个setter:
            set mySetter(parameter)
            {
                this.thing = parameter...
            }
        然而与普通方法不同的是调用getter无需加上圆括号，调用setter则直接放在赋值符=的左边
            console.log(obj.myGetter)    输出obj.thing
            obj.mySetter = 1            obj.thing = 1
    访问：
        符合标识符命名规则的属性名可以用点运算符.来引用
        如果属性名不符合标识符的命名规则，则需要用方括号来引用
            var unusualPropertyNames = {
                '': 'An empty string',
                '!': 'Bang!'
            }
            console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
            console.log(unusualPropertyNames['']);  // An empty string
            console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
            console.log(unusualPropertyNames['!']); // Bang!
        Object可以在定义后随时添加属性
        对一个Object添加属性时，使用相同构造函数创建的其他Object不会有这个属性，即每个Object都是独立的
        不存在的属性为undefined，不是null
        由于函数也是一种Object，所以也可以给函数添加属性，也可以将函数赋值给一个变量
    this关键字：
        this指代当前作用域的Object对象，即使当前函数没有直接定义在Object内
            function myMethod()
            {
                return this.val;
            }
            var obj1 = {
                get: myMethod,
                val: 42
            }
            var obj2 = {
                get: myMethod,
                val: 3.14
            }
            obj1.get()          //42
            obj2.get()          //3.14
            myMethod.call(obj1) //42
        由于this指代当前作用域的Object对象，所以调用已定义的对象的方法时，this指代的是那个对象，而不是本对象，所以可能出现问题
            var answer = {
                get: function()
                {
                    return this.val
                }
                val: 42
            }
            var firmAnswer = Object.create(answer)
            firmAnswer.get = function()
            {
                return answer.get() + "!!"  //错误，answer.get()将返回42，而不是下面设置的3.14
            }
            firmAnswer.val = 3.14
            firmAnswer.get()    //"42!!"
    基于原型的继承:
        与其他面向对象的编程语言基于类和对象不同，JS的继承机制是直接基于对象的
        JS中不区分对象、父类、子类等等概念
            function Base()//基类构造函数
            {...}   

            function Derived()//派生类构造函数
            {
                Base.call(this) //调用基类构造函数
                //...初始化派生类的其他属性
            }
            Derived.prototype = Object.create(Base.prototype)
            Derived.prototype.constructor = Base;
        当使用new运算符时，JS先构造一个Object，然后隐式将内部的属性__proto__设置为构造函数的prototype，并将构造函数的this设置为这个对象的引用
        当需要使用一个属性时，JS先检查这个属性是否直接存在于对象中，如果不存在，再到内部的prototype继承链中向上寻找
    多态
        要重写继承而来的成员方法，实质上就是对prototype中的同名属性重新赋值一个新函数，即
            Derived.prototype.memberFunction = function() {...}
    性质：
        Javascript中的Objects都是引用类型，只有当两个变量都为同一个Object的引用时才会相等，两个变量具有相同的属性和相同值并不会相等
            var fruit = {name: 'apple'};
            var fruitbear = {name: 'apple'};
            fruit == fruitbear;     //false
            fruit === fruitbear;    //false

            var fruit2 = fruit;
            fruit2 == fruit;    //true
            fruit2 === fruit;   //true
class
    ES6后JS加入了更接近于传统面向对象编程语言的类和对象机制，并引入了class关键字来定义一个类，extends关键字来继承一个类
    class实质上就是Object的语法糖，基于class的继承实质上就是Object中基于原型继承的语法糖
    使用new ClassName定义生成的对象仍然是一个Object，可以随时添加其他属性
        class ClassName
        {
            constructor(parameter)  //构造函数
            {
                this.member = parameter //定义数据成员
            }
            memberFunction()    //成员函数，注意无需function关键字
            {

            }
        }
    定义一个对象
        依然使用new关键字
            var object = new ClassName(arguments...)
    getter和setter
        定义方式与Object类似
            get name() {return ...}
            set name(parameter) {...}
    继承
        使用extends关键字加上基类名表示从基类继承
        在继承一个基类时，派生类的构造函数必须在使用this的成员前先调用基类的构造函数
            class Derived extends Base
            {
                constructor(parameter)
                {
                    super() //以及所需的其他参数
                    this.thing = parameter
                }
            }
    多态
        派生类中要修改的基类函数直接重新定义即可  
内置Object
    Number
    Math
    Date
    Intl
    Array
        构造
            构造并初始化
                let arr = new Array(element...)
                let arr = Array(element...)
                let arr = [element...]
            构造非空Array，但不初始化
                let arr = new Array(length) //注意这个重载的参数只能是数字，否则将构造只包含一个元素的Array
                let arr = Array(length)
                let arr = []; arr.length = length
            构造只包含单个元素的Array
                let arr = Array.of(element)
            .From()
                从其他类型的数据结构构造一个数组，例如Set
        赋值
            可以直接通过给数组没有的索引位置赋值，此时数组的长度会自动增加到要求的索引位置，未填充的元素为undefined
                let arr = [1, 2, 3]
                arr[5] = 0  //arr == [1, 2, 3, undefined, undefined, 0]
        方法
            .forEach()接收一个函数对象，并应用于对数组中除了undefined之外的每个元素
            .concat()接受一个数组，与当前数组合并在一起
            .join(delimiter=',')将数组中的元素与delimiter合成成一个字符串
            .push()添加一个一个元素到数组末尾
            .pop()返回并删除一个末尾的元素
            .shift()返回并删除数组的第一个元素
            .unshift()添加一个或多个元素到数组的头部，并返回数组的新长度
            .slice(start, end)返回一个新数组，包含原数组中[start, end)的元素
            .splice(index, count, elements...)
                删除原数组中索引从index开始的count个元素，并替换为elements...
                返回被删除的元素的数组
            .reverse()颠倒一个数组
            .sort()
                sort()方法还提供一个接受一个比较函数的重载版本
                该比较函数需要接受两个参数并返回一个值，形如：
                    function(a, b)
                    {
                        // return -1 (or any negative number) means a<b
                        // return 0 means a==b
                        // return 1 (or any positive number) means a>b
                    }
            .indexOf(element, [startIndex])
                从数组的startIndex开始向后搜索元素element，如果找到则返回该元素的索引，否则返回-1
            .lastIndexOf(element, [startIndex])
                从数组的startIndex开始向前搜索元素element
            .map(callback)  返回一个新数组
            .filter(callback)
            .every(callback)如果每个元素都满足callback（callback函数返回一个布尔值）返回true
            .some(callback)如果部分元素满足callback，返回true
            .reduce(callback, [initialValue])
                callback函数应该接受一个参数作为当前的值和另一个数组的元素，形如：
                    function(accumulator, currentValue)
                如果未指定initialValue，则第一次调用callback时的参数为数组的第0和第1个元素
            .reduceRight(callback, [initialValue])与reduce类似，但从数组的最后->最
    Map
    Set          
迭代器
    任何对象只要定义了一个满足条件的next()方法即可成为一个迭代器
    next()方法需要返回一个具有以下两个属性的对象
        value：返回下一个值
        done：返回代表是否迭代完毕的布尔值
    一个简单代表数字范围的迭代器：
        function makeRangeIterator(start = 0, end = Infinity, step = 1) {
            return {
                current: start,
                end,
                step,
                next: function () {
                    if (this.current <= this.end)
                    {
                        const tmp = { value: this.current, done: false }
                        this.current += this.step
                        return tmp
                    }
                    else
                        return {value: this.end, done:true}
                }
            }
        }

        let it = makeRangeIterator(0, 10)
        for (let result = it.next(); !result.done; result = it.next())
            console.log(result.value)
Generator
    Generator是一种特殊的函数，在调用这类函数会直接返回一个与其关联的迭代器来简化迭代器的定义
    声明Generator函数需要在function关键字后加一个星号*
    这个函数使用yield语句代表迭代器next().value，并自动设置终止条件
    例如上面的数字范围的迭代器可以改写为
        function* makeRangeIterator(start = 0, end = 100, step = 1) 
        {
            let iterationCount = 0;
            for (let i = start; i < end; i += step) 
            {
                iterationCount++;
                yield i;    //作为value
            }
            return iterationCount;
        }
可迭代对象
    可迭代对象就是一个定义了Symbol.iterator属性的对象
    
.异常
    异常机制由try catch finally语句构成
    finally语句块无论异常是否发生都会执行
    try catch可以嵌套，内层的try如果没有对应的catch语句，则必须有一个finally语句块
模块
    模块文件名常以.mjs结尾，相比.js能更清楚的表明这是一个模块，然而TypeScript不支持.mjs文件
    export
        要导出模块中的功能，在要导出的对象前加export关键字
        可以export以var，let，const定义的变量、function、class
        但不能在函数内export
            export const name = "square"
            export function draw() {...}
        还可以在一条export语句内使用花括号{}将所要export的内容括起来，一次性全部export
            export {name, draw}
    default export 
        一个模块文件可以有一个default export的函数
        该函数使用export default function() {}定义，不能有函数名
    import
        要使用一个模块的功能，使用import关键字加上花括号{}括起来的一系列用逗号分隔的名称，加上from关键字加上模块的路径
            import {name, draw} from "./modules/square.js"
        所导入的名称就像是在本文件内定义的一样使用
    import default
        import一个default export函数时的语法与import普通名称一样，然而由于一个模块只能由一个export default，所以无需花括号
            import something from "path"
        import模块中的default export时相当于给这个函数一个名称
    与普通script文件不同的是，模块文件：
        自动延迟装载
        自动使用strict模式
        只执行一次，即使它被多个<script>标签引用
    解决命名冲突：
        如果import了多个模块，其中包含相同的名称则会造成命名冲突
        可以在export时加上as关键字给所要export的名称一个新名称
            //module.js
            export{
                function1 as newFunctionName,
                function2 as anotherNewFunctionName
            }
            //main.js
            import {newFunctionName, anotherNewFunctionName} from "module.js"
        类似的也可以在import时加上as关键字给所要import的名称一个新名称，这是更常见的做法
            //module.js
            export {function1, function2}
            //main.js
            import{
                function1 as newFunctionName,
                function2 as anotherNewFunctionName
            } from "module.js"
        更好的做法是将一个模块内的所有export都导入，作为一个模块文件
            import * as MyModule from "module.js"
        然后使用MyModule作为module.js模块中导出名称的名称空间
            MyModule.function1()
            MyModule.function2()
    合并模块
        将多个子模块合成为一个模块集合，并导出为一个名称空间
        例如新建一个.js模块文件，并声明以下export
            export { Square } from "./shapes/square.js"
            export { Circle } from "./shapes/cicrcle.js"
        然后在main.js中只需从这个模块集合中导入各个子模块
            import {Square, Circle} from "./shapes.js"
    动态导入
        import("path").then((module) => {
            //Do something with the module
        })
异步编程
    回调函数
        在老式异步编程中，需要异步运行的函数通常接收一个回调函数作为参数
        当异步操作完成后将执行回调函数，例如addEventListener函数
            button.addEventListener("click", () => {/*回调函数体*/})  
    promise
        promise是一个代表某个异步操作完成的对象
        对一个promise调用.then(function)方法来设置这个promise执行完成后要执行的操作（应该是一个返回promise的函数），其结果仍然是一个promise
        所以可以使用.then()方法来连接多个异步操作，形成一个异步操作链
        promise有可能执行失败，所以可以使用.catch()来设置异常处理函数，如果异步操作链中哪一个操作发生异常都会直接跳转到异常处理函数
            doSomething().then
            (
                function(result)
                {
                    return doSomethingElse(result);
                }
            ).then
            (
                function(newResult)
                {
                    return doThirdThing(newResult)
                }
            ).then
            (
                function(finalResult)
                {
                    console.log(finalResult)
                }
            ).catch(failureCallback)    //异常处理函数
        使用箭头函数，上面代码可以进一步简化为：
            doSomething()
            .then(result => doSomethingElse(result))
            .then(newResult => doThirdThing(newResult))
            .then(finalResult => console.log(finalResult))
            .catch(failureCallback)    //异常处理函数
        当promise链完成后可能希望运行一些其他的代码，可以使用.finally()方法，这个方法无论promise是否成功都会执行
            myPromise
            .then(result => doSomething(result))
            .catch(e => handleError(e))
            .finally(runFinalCode)
        静态成员函数：
        .all()
            接收一个promise对象数组并返回一个promise，这个promise在promise对象数组中所有的promise都产生结果时才会执行
            这个新promise的.then()方法同样接收一个函数参数（应该是一个接收原promise对象数组的结果的函数）
                Promise.all([a, b, c]).then(values => ...)    
    等待函数
        注意这些函数的执行都是异步的，即在主线程空闲时才可能会跳转到这些函数来执行
        setTimeout(function[args...], [delay], [args...])
            在等待delay毫秒后执行函数参数function，这个函数可以接收可选的参数args...
            如果delay未指定，则为0，表示不等待，当主线程空闲时立即执行function
            函数返回一个对象，可以在delay到达前调用clearTimeout()取消这个任务
        setInterval(function[args...], [delay], [args...])
            每delay毫秒内执行一次function，这个函数可以接收可选的参数args...
            由于delay包含函数执行的时间，所以delay应该大于执行function所需的时间
            如果需要经过一段确定的时间后执行某个操作，应该使用递归调用setTimeout()的方法，例如
                setTimeout(function run()
                {
                    //...
                    setTimeout(run, 100);
                }, 100);//每过100毫秒执行一次run()函数
            函数返回一个对象，可以调用clearInterval()取消
        clearTimeout(timeoutID)
            取消执行timeoutID所指定的定时任务，timeoutID应该是由setTimeout()所返回的对象
        clearInterval(intervalID)
            取消执行intervalID所指定的定时任务，intervalID应该是由setInterval()返回的对象
        requestAnimationFrame(callback[timestamp])
            类似于setInterval，为优化动画显示而产生
            这个函数将尽可能以高帧率绘制动画，但是当动画不可见时则停止执行来优化性能
            callback是一个需要定时执行的回调函数，在绘制前执行，函数可以接受一个可选的参数timeStamp来表示时间信息，例如：
                function draw()
                {
                    //drawing code
                    requestAnimationFrame(draw);
                }
                draw();
    async/await
        基于ECMAScript 2017，JS引进了async函数和await关键字
        async函数和await关键字基于promise机制
        在函数的function关键字前加async关键字使得函数的返回值变为原先返回值的promise类型
        在箭头函数中的圆括号()前加async关键字
            async function sayHello() { return "hello" }
        在一个async函数中在另一个async的函数调用前使用await关键字，可以使得这个函数调用变为异步，即代码暂停，直到所调用的函数返回的Promise对象完成执行
        在async函数中要处理异常，使用普通的try catch方法
        使用async/await机制可以使得异步代码类似于传统非同步代码
        注意一个常见误区：当希望多个并不互相依赖的函数实际上并发执行时，不要直接对其使用await调用
            await doSomething()
            await doSomethingElse()
            await doThirdThing()
        会导致其实际上是顺序执行的，因为doSomething()执行完才会继续执行doSomethingElse()
        应该将他们返回的Promise对象存储到一个变量中，然后对这些变量进行await
            const promise1 = doSomething()
            const promise2 = doSomethingElse()
            const promise3 = doThirdThing()
            await promise1
            await promise2
            await promise3
        或 await Promise.all([promise1, promise2, promise3])
严格模式
    在一个文件的开头加上"use strict";字符串将使得本文件执行在严格模式下
    在一个函数内加上"use strict";字符串将使得本函数执行在严格模式下

JSON（Javascript object notation）
    静态成员函数：
        .parse(text)
            将字符串text按JSON来解析，并返回一个对象
            如果字符串text不符合JSON语法，抛出SyntaxError异常
        .stringify(value)
            将对象value转换为JSON格式的字符串并返回
HTTP（Hyper text transfer protocol）
    服务器<->客户端间的通信协议
    Http请求是无状态的，意思是每个http请求之间都是互相独立的
    要记录状态，需要使用本地存储local storage、cookies等技术
    HTTPS（hyper text transfer protocol secure）
        数据使用SSL（secure sockets layer）或TLS（transport layer security）技术加密
    HTTP请求方法：
        GET
        POST
        PUT
        DELETE
    状态码
        
REST（Representational state transfer）

TS
1.变量
    变量的类型用:写在变量名的右边
        Boolean
        null
        undefined
        Number  整数或浮点
        BigInt  任意精度的整数，例如很大的整数
        String
        Symbol
        Object （也包括函数）
        除了Object，其他类型在赋值时都是复制，即拷贝，Object在赋值时是复制引用
        let isDone: boolean = false
        let decimal: number = 6         //十进制字面值
        let hex: number = 0xf00d        //十六进制字面值
        let binary: number = 0b1010     //二进制字面值
        let octal: number = 0o744       //八进制字面值
        let big: bigint = 100n

    TS中新增的类型
        数组：
            let list: number[] = [1,2,3]
            let list: Array<number> = [1,2,3]\
        元组：
            元组的类型声明后就不可改变，不与元组类型兼容的赋值会出错
            元组的类型写在一对方括号中[]，值也用一对方括号[]括起来
                let x: [string, number] = ["hello", 3]
            访问元组的元素的方式与数组类似，都使用方括号加索引的形式
                x[0]    //"hello"
        枚举：
            定义一个枚举类型
                enum Type{
                    //values
                }
            定义一个枚举类型的变量
                let myEnum: Type = Type.Value
            可以在定义枚举类型时给其中的一些或枚举值赋数值，没有赋值的枚举值将从最后一个赋值的枚举值后+1，以此类推
                enum Color{
                    Red = 1,
                    Green,  //自动赋值为2
                    Blue    //自动赋值为3
                }
            然而不带赋值枚举值必须要么放在最前面，要么放在常量枚举值（可以在编译期计算的枚举值）之后
                enum Thing
                {
                    Thing1 = GetValue() //非常量枚举值
                    Thing2  //错误，需放在非常量枚举值之前
                }
            枚举值的名称可以作为string使用，引用枚举名使用数组下标语法，索引为需要引用的枚举值
                let colorName: string = Color[1]    //Red
            常量枚举值
                将enum声明为const将禁止非常量枚举值的赋值
                使用常量枚举值时，编译器会完全抹除这个枚举值的信息，直接使用其值代替
                    const enum Direction {...}
        unknown:
        any:
            any类型将迫使Typescript编译器停止类型检查，使用any类型与Javascript类似
            与unknown不同，使用any类型时可以使用其可能存在或不存在的属性、方法等
                let anyThing: any = 4
                anyThing.toLower()  //Typescript编译器将不检查此处的toLower()是否合法，虽然其实不合法
            由于any类型降低了类型安全性，所以应该尽量避免使用
        void：
            只有两种用法，一种是用于没有返回值的函数
                function DoNotReturn() : void {...}
            或者是undefined和null类型的变量
                let unusable: void = undefined
                let unusable: void = null
        undefined
        null
            只能赋值给其对应的undefined和null类型还有void类型
        never
            只有一种用法，就是不返回的函数（函数永远抛出异常，或者是死循环）
                function error(message: string) : never
                {
                    throw new Error(message)
                }
        object
            非number, string, boolean, bigint, symbol, null, undefined的类型
        字面值类型
            可以使用type关键字把字符串、数值、布尔值作为类型来使用，得到类似于枚举类型的行为，例如：
                type Easing = "ease-in" | "ease-out" | "ease-in-out";//声明了一个Easing的字符串字面值类型
                type Dice = 1 | 2 | 3 | 4 | 5 | 6
    类型合集：
        有时需要表达一个对象可能是几种类型之一，使用逻辑或|运算符来表示
    类型并集：
        有时需要表达一个对象同时满足多个接口，使用逻辑运算符&来表示

    编译期类型转换：
        有时可能需要将变量做类型转换，迫使Typescript编译器将其作为另一个类型（如果有充足的理由）
        此时编译器将不检查其是否真的可以进行这样的类型转换
        由于Typescript编译成Javascript后类型实际上不存在，所以这样的类型转换并不会产生运行期性能损耗
        有两种转换的形式：
            将所要转换的变量加as关键字和所要转换为的类型
                let someValue: unknown = "this is a string"
                let strLength: number = (someValue as string).length
            在一对尖括号<>中加上转换为的类型，后加变量名
                let someValue: unknown = "this is a string"
                let strLength: number = (<string>someValue).length
    keyof关键字
        keyof Type返回Type中所有的属性名的类型合集，例如
            interface Person 
            {
                name: string;
                age: number;
                location: string;
            }
            type K1 = keyof Person; // "name" | "age" | "location"
            
3.函数
    函数的类型
        函数的类型由参数的类型和返回值的类型决定
        形如下面的函数
            function FunctionName(parameter: ParameterType): ReturnType {...}
        其类型为：
            (parameter:ParameterType) => ReturnType
        其中parameter可以随意，但不能没有
        例如:
            function add(x: number, y: number)：number
            {
                return x + y
            }
        其类型为：(x: number, y: number) => number
        所以它可以赋值给一个相同类型的变量
            let myAdd: (x:number, y: number) => number = add
        Typescript可以根据return语句来自动判断返回值的类型所以无需写返回值的类型，所以上面的add又可以写成
            function add(x: number, y: number) 
            {
                return x + y;    
            }
        Typescript还可以根据赋值变量的类型来推断函数的类型，也可以根据函数的类型来推断要赋值的变量的类型
        所以将一个函数赋值给变量时，两端只需一端明确类型即可
            let myAdd = function (x: number, y: number): number //由函数推断变量类型
            {
                return x + y;
            };

            // myAdd has the full function type
            let myAdd2: (baseValue: number, increment: number) => number = function (x, y)  //由变量推断函数类型
            {
                return x + y;
            };
    可选参数
        与接口的可选属性类似，在函数参数名后加问号?表明该参数是可选参数
        可选参数必须位于必须参数的后面
    默认参数
        可以用赋值的形式给函数形参加一个默认参数，当实参个数==形参个数时使用实参的值或这对应实参非undefined，否则使用默认参数的值
        默认参数不要求必须处于必须参数之后，然而如果调用时要使用默认参数的值，需要显式传递一个undefined        
        默认参数的类型与可选参数相同，即使用默认参数的函数与可选参数的函数类型相同
        例如下面的FullName和FullName2函数的类型相同
            function FullName(firstName: string, lastName?: string) {...}
            function FullName2(firstName: string, lastName:string = "Smith") {...}
    可变参数
        用...Parameter: Type[]表示默认可变参数
        Parameter是一个Type类型的数组
        可以传0~无穷多个实参给这样的可变参数
            function add(x: number, ...args: number[])
            {
                return x + args.reduce((lhs: number, rhs: number) => lhs + rhs);
            } 
            console.log(add(1, 2, 3, 4, 5));    //15
    重载
        函数重载的方式是先声明所有要重载的版本的类型
        然后在定义中将参数和返回值声明为any类型，在函数体内使用typeof来判断参数的真实类型来使用不同的实现
            function add(x: number, ...args: number[]) : number;
            function add(x: string, ...args: string[]) : string;

            function add(x: any, ...args: any[]) :any
            {
                if (typeof x == "number")
                {
                    //...
                }
                else if (typeof x == "string")
                {
                    //...
                }
            }
    接口就是满足一些条件的类型，例如包含某个符合类型的属性、某些符合类型（接收某些类型的参数且返回特定类型）的方法
    Object接口
        匿名接口
            可以直接用类似于定义Object的语法定义一个匿名接口    
            function PrintLabel(labelObj: { label: string})  //函数接收一个匿名接口类参数，这个接口类需要有一个名叫label且类型为string的属性
            {
                console.log(labelObj.label)
            }
            let myObj = {size: 10, label: "My Object"}
            PrintLabel(myObj)
        命名接口
            使用interface关键字定义一个接口
            如上例的匿名函数参数接口可以写为
                interface LabeledObj
                {
                    label: string;
                }
                function PrintLabel(labelObj: LabeledObj)
                {
                    console.log(labelObj.label)
                }
                let myObj = {size: 10, label: "My Object"}
                PrintLabel(myObj)
            可选属性
                命名接口中的某些属性可能是非必要的，在接口定义中这样的属性名后加问号?表示该属性可选
                    interface LabeledObj
                    {
                        label?: string
                    }
                在判断传入的参数是否具备这个可选属性时，只需使用一个if语句，条件为可选属性的名称
                    if(labelObj.label)
            只读属性
                只读属性是定义了对象后就不能再修改的属性，类似于const对应于对象的关系
                在属性名前加readonly关键字声明一个只读属性
        然而，如果作为实参的Object不存在接口中的任何属性也会发生编译错误，即使接口中声明的属性都是可选属性
        Object字面值的强化检查:
            当以Object字面值作为实参时，字面值中不能有接口中未定义的属性
            即Object字面值的类型检查比Object对象更严格
            比如
                PrintLabel({size: 10, label: "My Object"})将无法通过编译，原因是size未在interface LabeledObj中定义
    函数接口
        满足一定类型要求的函数也可以定义为接口
        一个函数的类型由：参数的类型、返回值的类型所决定
        参数的名称可以随意
            interface SearchFunction{
                (source: string, searchString: string) : boolean    //接收两个string参数并返回一个布尔值的函数接口
            }  
        声明了函数接口后，即可将一个函数赋值给同样类型接口的变量
            let mySearch: SearchFunc
            mySearch = function(source: string, searchString: string)
            {
                return source.search(searchString) > -1
            }
        由于接口已经描述了函数的参数类型和返回值类型，所以可以在赋值时省略
            let mySearch: SearchFunc
            mySearch = function(source, searchString)
            {
                return source.search(searchString) > -1
            }
    继承接口
        接口可以相互继承，形成更大的接口，即派生接口中包含所继承的接口中所声明的所有属性
        继承一个接口使用extends关键字加接口名
            interface Derived extends Base{...}
        一个接口可以继承多个接口
            interface Derived extends Base1 Base2 {...}
4.类
    Javascript中的类数据成员只需在构造函数中使用this.赋值即可
    在Typescript中类的数据成员需要先列出其名称和类型
        class ClassName
        {
            member: Type
            constructor(data: Type)
            {
                this.member = data
            }
        }
    可见性：
        可以在成员名（无论是数据成员还是成员方法或构造函数）前加public private protected来修改其可见性
        类成员默认为public
        private关键字使得成员对外不可见
        protected关键字使得成员只对派生类可见
        将构造函数声明为protected使得该类只能由派生类构造，对外不能构造这个类的对象
    快速声明类成员
        先声明所有数据成员，再在构造函数中对数据成员赋值，会造成代码重复
        可以在构造函数的参数中直接将参数加上可见性修饰符，使得该参数即成为数据成员，无需前向声明
            class Person
            {
                constructor(public name: string)    //name即成为Person类的数据成员，可见性为public
                {}
            }
    getter和setter
        如果一个属性只有getter没有setter将自动成为readonly
    静态成员
        在成员名前使用static关键字将成员声明为静态
        要访问类的静态成员，要在前面加类名.
            class Point
            {
                static origin = { x: 0, y: 0 };
                constructor(public x: number, public y: number) { }
                distanceFromOrigin()
                {
                    return Math.sqrt(Math.pow(this.x - Point.origin.x, 2) + Math.pow(this.y - Point.origin.y, 2));
                }
            }
    抽象类
        抽象类只能通过派生类继承，不能定义对象
        类似于接口，但是可以提供公用的实现
        可以将方法声明为abstract，派生类必须提供抽象方法的实现
        没有提供实现的方法必须声明为abstract
    类也可以作为接口来使用
        class Point {...}
        interface 3DPoint extends Point { z: number }
        let point:3Dpoint = {x:1, y:2, z:3 }    //注意这里不能用new
5.模板
    函数模板
        在函数名后加一对尖括号<T>表示这是一个模板参数并引入了一个模板参数
        可以引入多个模板参数，用逗号隔开
        普通函数：
            function identity(arg: any): any { return arg; }
        这个函数的类型为：
            (arg: any) => any
        这个函数符合这样的函数接口
            interface identityFunction
            {
                (arg: any): any;
            }
        模板函数：
            function identity<T>(arg: T): T { return arg; }
        这个函数的类型为：
            <T>(arg: T) => T;
        这个函数符合这样的函数接口
            interface identityFunction
            {
                <T>(arg: T): T;
            }
    类模板
        在类名后加一对尖括号<T>表示这是一个类模板
            class ClassName<T>
            {
                ...
            }
    模板限制
        函数模板中只能执行模板参数T本身所支持的操作，即所有可能的T所共有的操作
        在没有对T进行限制的情况下，能执行的操作非常有限
        所以需要对T进行限制，使得编译器知道T所能支持的操作
        这通常需要借助定义接口来实现，然后限制T符合这一接口
            interface HasLength
            {
                length: number
            }
            function LogLength<T extends HasLength>(arg: T)
            {
                console.log(arg.length)
            }
DOM
    Document
        .getElementById()
        .getElementByTagName()
        .querySelector()
        .querySelectorAll()
    HTMLElement
        .style
        注意在Javascript中style的属性是驼峰命名camelCase，而CSS中是全小写加连字符lower-case
    <input> 使用.value属性来获取输入的字符串
Ajax（Asynchronous Javascript and XML）
    是指用XMLHttpRequest()这样的函数来直接向服务器发起Http请求从而更新网页的部分内容而不必刷新整个页面的获取数据的方式
    XMLHttpRequest:
        首先构造一个XMLHttpRequest对象：let request = new XMLHttpRequest()
        然后使用.open(method: string, url)来创建一个请求
        最后使用.send()来发送请求
        请求默认是使用async方式执行的，所以如果需要在收到应答后执行某些操作，可以给.onload属性赋值一个回调函数
    fetch():
        fetch(url)返回一个Promise对象
    blob（binary large object）