0.MSVC C++扩展
    __interface
        定义一个__interface如同定义一个只包含纯虚函数的抽象基类
        需要满足以下条件：
            不从一个基类继承
            只能包含public的纯虚函数
            不能包含构造函数、析构函数、运算符函数
            不能包含静态方法
            不能包含成员变量，但是可以包含属性
        __interface中的纯虚函数可以简写省略virtual和=0
            __interface Animal
            {
                virtual void MakeSound() = 0; //可以直接写成void MakeSound();
            }
    __declspec()
        与static和extern类似，是一个存储类说明符
        https://docs.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-160
        括号中可以填入
            align(<number>)
            allocate("<segname>")
            allocator
            appdomain
            code_seg("<segname>")
            deprecated
            dllimport
            dllexport
            jitintrinsic
            naked
            noalias
            noinline
            noreturn
            nothrow
            novatable
            no_sanitize_address
            process
            property({get=<get_func_name> |, put=<put_func_name>})
            restrict
            safebuffers
            selectanu
            spectre(nomitigation)
            thread
            uuid("<ComObjectGUID>")
    UNREFERENCED_PARAMETETER(parameter)
        定义在<winnt.h>中，用来消除函数未使用参数时编译器警告
    调用约定
        __cdecl 
        __clrcall
        __stdcall
        __fastcall
        __thiscall
        __vectorcall
        在需要指定调用约定的函数声明的返回类型后加上面关键字之一，而函数定义不加，例如
            /*MyFunc.h*/
            void __cdecl MyFunc(int a, int b);

            /*MyFunc.cpp*/
            void MyFunc(int a, int b)
            {
                //...
            }
    _ASSERT, _ASSERTE, _ASSERT_EXPR
        #include <crtdbg.h>
        用于在Debug模式下当条件为FALSE时打印调试信息
        // Typical usage:
        _ASSERT_EXPR( booleanExpression, message ); 输出表达式的字符串+简单调试信息+自定义的message
        _ASSERT( booleanExpression );   输出一个简单调试信息
        _ASSERTE( booleanExpression );  输出表达式的字符串+调试信息
    字符集
        在Project Properties->Advanced->Character Set中
        Not Set：单字节字符编码，例如UTF-8
        Use Unicode Character Set：双字符字节编码，例如UTF-16（Windows原生）
        Use Multi-Byte Character Set：多字节字符编码（罕见）
    VC++运行库
        /MT -> LibCMt.lib  静态链接发行版本
        /MTd -> LibCMtD.lib 静态链接调试版本
        /MD -> MSVCRt.lib 导入库，用于动态链接MSVCR80.dll库的发行版本（默认）
        /MDd -> MSVCRtD.lib 导入库，用于动态链接MSVCR80D.dll库的调试版本
    
1.高级数据类型
    为了统一成大写，VC++给很多类型取了大写的typedef
    INT->int
    UINT->unsigned int
    CHAR->char
    WCHAR->wchar_t
    
    WinDef.h:
    BYTE 8位无符号
    DWORD 32位无符号
    INT32
    INT64
    LONG 32位有符号
    LONGLONG 64位有符号

    UINT32
    UINT64
    ULONG
    ULONGLONG
    WORD 16位无符号
    windows里P开头表示是指针，LP开头表示长指针（为了便于将给16位计算机设计的代码移植到32位），现在P和LP没有区别，与变量类型*的指针表示也没有区别
    指针的长度是编译时决定的，所以64位系统中运行32位的程序，指针长度仍然是32位

    BOOL {FALSE->0, TRUE->1}

    LRESULT->long (winnt.h:typedef long LONG    windef.h:typedef LONG LRESULT)
    HRESULT->long (winnt.h)初始化COM库的函数的返回值
    LPTSTR 字符串指针
    LPTCSTR 常量字符串指针
2.错误处理
    DWORD FormatMessage(
        DWORD dwFlags,
        LPCVOID pSource,
        DWORD dwMessageID,
        DWORD dwLanguageID,
        PTSTR pszBuffer,
        DWORD nSize,
        va_list* Arguments
    );
    可以通过FormatMessage()函数来获得一个描述性字符串
        using String = std::basic_string<TCHAR>;
        auto GetErrorMessage(DWORD dwErrorCode)
        {
            LPTSTR psz{ nullptr };
            const DWORD cchMsg = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                | FORMAT_MESSAGE_IGNORE_INSERTS
                | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                NULL, // (not used with FORMAT_MESSAGE_FROM_SYSTEM)
                dwErrorCode,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                reinterpret_cast<LPTSTR>(&psz),
                0,
                NULL);
            if (cchMsg > 0)
            {
                auto deleter = [](void* p) { ::LocalFree(p); };
                std::unique_ptr<TCHAR, decltype(deleter)> ptrBuffer(psz, deleter);
                return String(ptrBuffer.get(), cchMsg);
            }
            else
            {
                auto error_code{ ::GetLastError() };
                throw std::system_error(error_code, std::system_category(),
                    "Failed to retrieve error message string.");
            }
        }

    VOID SetLastError(DWORD dwErrCode) 设置Error值

    
3.字符串
    在<winnt.h>中定义了这些宏

        #ifdef  UNICODE                     // r_winnt

        #ifndef _TCHAR_DEFINED
        typedef WCHAR TCHAR, *PTCHAR;
        typedef WCHAR TBYTE , *PTBYTE ;
        #define _TCHAR_DEFINED
        #endif /* !_TCHAR_DEFINED */

        typedef LPWCH LPTCH, PTCH;
        typedef LPCWCH LPCTCH, PCTCH;
        typedef LPWSTR PTSTR, LPTSTR;
        typedef LPCWSTR PCTSTR, LPCTSTR;
        typedef LPUWSTR PUTSTR, LPUTSTR;
        typedef LPCUWSTR PCUTSTR, LPCUTSTR;
        typedef LPWSTR LP;
        typedef PZZWSTR PZZTSTR;
        typedef PCZZWSTR PCZZTSTR;
        typedef PUZZWSTR PUZZTSTR;
        typedef PCUZZWSTR PCUZZTSTR;
        typedef PZPWSTR PZPTSTR;
        typedef PNZWCH PNZTCH;
        typedef PCNZWCH PCNZTCH;
        typedef PUNZWCH PUNZTCH;
        typedef PCUNZWCH PCUNZTCH;
        #define __TEXT(quote) L##quote      // r_winnt

        #else   /* UNICODE */               // r_winnt

        #ifndef _TCHAR_DEFINED
        typedef char TCHAR, *PTCHAR;
        typedef unsigned char TBYTE , *PTBYTE ;
        #define _TCHAR_DEFINED
        #endif /* !_TCHAR_DEFINED */

        typedef LPCH LPTCH, PTCH;
        typedef LPCCH LPCTCH, PCTCH;
        typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
        typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
        typedef PZZSTR PZZTSTR, PUZZTSTR;
        typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
        typedef PZPSTR PZPTSTR;
        typedef PNZCH PNZTCH, PUNZTCH;
        typedef PCNZCH PCNZTCH, PCUNZTCH;
        #define __TEXT(quote) quote         // r_winnt

        #endif /* UNICODE */                // r_winnt
        #define TEXT(quote) __TEXT(quote)   // r_winnt
    可以使用TEXT()宏，使得当UNICODE被定义时，使用16bit字符和字符串，否则使用8位字符和字符串
        TCHAR c = TEXT('A');
        TCHAR szBuffer[] = TEXT("A string");
    在<string.h>中也定义了类似的宏，使得无论是ANSI字符串函数还是Unicode字符串函数都能通过编译
        #ifdef _UNICODE
            #define _tcslen wcslen
        #else
            #define _tcslen strlen
        #endif
    在<strsafe.h>中定义了字符串函数的安全版本
    安全版本的函数在检查参数失败后会设置errno

    int CompareString(
        LCID locale,
        DWORD dwCmdFlags,
        PCTSTR pString1,
        int cch1
        PCTSTR pString2,
        int cch2)
        按语言习惯的方式进行字符串比较
        locale指定一个区域设置id，用来表示1种语言，通常使用GetThreadLocale()函数获取
        dwCmdFlags指定比较字符串的方法，可能的值为
            NORM_IGNORECASE LINGUISTIC_IGNORECASE 忽略大小写
        cch1和cch2指定字符数（不是字节数），传入负值则自动计算字符串长度
        pString为待比较字符串指针

    int CompareStringOrdinal(
        PCWSTR pString1,
        int cchCount1,
        PCWSTR pString2,
        int cchCount2,
        BOOL bIgnoreCase)
        按码位比较字符串，不考虑区域语言，适用于程序内部比较字符串
        返回
            0 ->函数失败
            CSTR_LESS_THAN 1 -> pString1 < pString2
            CSTR_EQUAL 2 -> pString1 == pString2
            CSTR_GREATER_THAN 3 -> pString2 > pString2
    使用这个宏来分配字符串所需的内存
        #define chmalloc(nCharacters) (TCHAR*)malloc(nCharacters * sizeof(TCHAR))
    UNICODE <=> ANSI
        int MultiByteToWideChar(
            UINT uCodePage,
            DWORD dwFlags,
            PCSTR pMultiByteStr,
            int cbMultiByte,
            PWSTR pWideCharStr,
            int cchWideChar
        )

        BOOL IsTextUnicode(
            CONST PVOID pvBuffer,
            int cb,         字节数
            PINT pResult    通常为NULL
        )
        判断一个字符串是包含ANSI字符还是Unicode字符

4.内核对象
    内核对象可以用一个安全描述符来保护
    用于创建内核对象的所有函数几乎都有一个只想SECURITY_ATTRIBUTES结构体的指针
    大多数创建内核对象的函数失败时返回值为NULL（0），少数的函数失败时返回INVALID_HANDLE_VALUE （-1）
    typedef struct _SECURITY_ATTRIBUTES {
        DWORD nLength;                  传入sizeof(SECURITY_ATTRIBUTES)
        LPVOID lpSecurityDescriptor;    
        BOOL bInheritHandle;        
    } SECURITY_ATTRIBUTES;

    HANDLE CreateFileMapping(
        HANDLE hFile,               
        PSECURITY_ATTRIBUTES psa,   
        DWORD flProtect,            
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        PCTSTR pszName
    )

    HANDLE CreateThread(
        PSECURITY_ATTRIBUTES psa,
        size_t dwStackSize,
        LPTHREAD_START_ROUTINE pfnStartAddress,
        PVOID pvParam,
        DWORD dwCreationFlags,
        PDWORD pdwThreadID
    )

    HANDLE CreateFile(
        PCTSTR pszFileName,
        DWORD dwSesiredAccess,
        DWORD dwShareMode,
        PSECURITY_ATTRIBUTES psa,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttribues,
        HANDLE hTemplateFile
    )

    HANDLE CreateSemaphore(
        PSECURITY_ATTRIBUTES psa,
        LONG lInitialCount,
        LONG lMaximumCount,
        PCTSTR pszName
    )

    无论用什么方式创建内核对象，都应该调用这个函数表明结束使用
    BOOL CloseHandle(Handle hobject)
    内核对象的共享
        对象句柄继承
            当进程之间存在父-子关系时可以使用对象句柄继承
            父进程需要初始化一个SECURITY_ATTRIBUTES结构，并设置其中的成员
                SECURITY_ATTRIBUTES sa{sizeof(sa), NULL, TRUE};
            再将其传给相应的创建内核对象的函数，例如
                HANDLE hMutex = CreateMutex(&sa, FALSE, NULL);
            有时可能父进程创建了两个子进程，并且希望只有其中一个子进程继承句柄，即需要在更改继承标志位后才能创建另一个进程
            更改进程标志位函数
                BOOL SetHandleInformation(
                    HANDLE hObject,     一个需要修改继承标志位的句柄
                    DWORD dwMask,       修改哪个进程标志位
                    DWORD dwFlags       修改为什么
                )
            所以需要调用
                SetHandleInformation(handle, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT) 启用handle的继承
                SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0)    禁用handle的继承
5.进程
    Windows应用程序必须要有一个入口点函数
        当链接可执行文件时，连接器将按子系统开关来寻找入口点函数，如果找不到将返回unresolved external symbol
        /SUBSYSTEM:WINDOWS -> int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow) wWinMainCRTStartup
        /SUBSYSTEM:CONSOLE -> int _tmain(int argc, TCHAR* argv[], TCHAR* envp[]); wmainCRTStartup
        /NotSet -> 编译期自动查找入口点函数，并选择正确的启动函数
    hPrevInstance已经废弃不用
    加载到进程地址空间的每个dll或exe都有一个独一无二的实例句柄HINSTANCE
    有些函数需要一个HMODULE类型参数，HMODULE与HINSTANCE是完全混用的，因为在<minwindef.h>中有
        typedef HINSTANCE HMODULE; 
    进程的创建
        typedef struct _STARTUPINFO
        {
            DWORD cb;           //sizeof(STARTUPINFO)
            PSTR lpReserved;    //NULL
            PSTR lpDesktop;     //表明在哪个桌面上启动，如果不存在则新创建一个桌面，如果为NULL则在当前桌面启动
            PSTR lpTitle;       //控制台窗口的标题，如果为NULL则使用当前程序的名称
            DWORD dwX;          //如果是CUI程序，则指定控制台左上角的坐标，如果是GUI程序且在进程新建重叠窗口时使用了CW_USEDEFAULT参数，则指定新重叠窗口左上角的坐标
            DWORD dwY;
            DWORD dwXSize;
            DWORD dwYSize;
            DWORD dwXCountChars;//指定用字符数来表示的控制台的宽度和高度
            DWORD dwYCountChars;
            DWROD dwFillAttribute;//指定控制台窗口的文本和背景色
            DWORD dwFlags;
            WORD wShowWindow;
            WORD cbReserved2; //0
            PBYTE lpReserved2;//NULL
            HANDLE hStdInput;
            HANDLE hStdOutput;
            HANDLE hStdError;
        } STARTUPINFO, *LPSTARTUPINFO;
            dwFlagg的值：
                STARTF_USESIZE          使用dwXSize和dwYSize成员
                STARTF_USESHOWWINDOW    使用wShowWindow成员
                STARTF_USEPOSITION      使用dwX dwY
                STARTF_USECOUNTCHARS    使用dwXCountChars dwYCountChars
                STARTF_USEFILLATTRIBUTE 使用dwFillAttribute
                STARTF_USESTDHANDLES    使用hStdInput hStdOutput hStdError
                STARTF_RUNFULLSCREEN    控制台程序以全屏模式启动

        typedef struct _STARTUPINFOEX
        {
            STARTUPINFO StartupInfo;
            struct _PROC_THREAD_ATTRIBUTE_LIST *lpAttributeList;
        } STARTUPINFOEX, *LPSTARTUPINFOEX;

        typedef struct _PROCESS_INFORMATION
        {
            HANDLE hProcess;
            HANDLE hThread;
            DWORD dwProcessId;
            DWORD dwThreadId;
        } PROCESS_INFORMATION;

        BOOL CreateProcess(
            PCTSTR pszApplicationName,          //可执行文件名
            PTSTR pszCommandLine,               //注意这个字符串指针是非常量指针，意味着函数可能修改字符串中的内容，所以不能直接传入一个字符串字面值，但是函数返回时会复原
            PSECURITY_ATTRIBUTES psaProcess,    //进程内核对象的安全属性
            PSECURITY_ATTRIBUTES psaThread,     //线程内核对象的安全属性
            BOOL bInheritHandle,
            DWORD fdwCreate,
            PVOID pvEnvironment,
            PCTSTR pszCurDir,
            PSTARTUPINFO psiStartInfo,          //可以是一个STARTUPINFO的指针，也可以是STARTUPINFOEX的指针（都让fdwCreate使用了EXTENDED_STARTUPINFO_PRESENT时）
            PROCESS_INFORMATION ppiProcInfo
        )
        fdwCreate参数可以由下面的值按位或：
            DEBUG_PROCESS
            DEBUG_ONLY_THIS_PROCESS
            CREATE_SUSPENDED 系统在创建新进程时挂起其主线程，使得父进程可以修改子进程地址空间的内存、更改优先级等操作，结束后需要调用下面函数恢复子进程的执行
                DWORD ResumeThread(HANDLE hThread)
            DETACH_PROCESS 阻止CUI子进程使用父进程的控制台窗口，例如在控制台执行命令时输出是直接输出到控制台的，新进程如果需要控制台窗口，需要使用AllocConsole()函数
            CREATE_NEW_CONSOLE 不能与DETACH_PROCESS连用
            CREATE_NO_WINDOW 不要创建任何窗口（包括控制台）
            CREATE_DEFAULT_ERROR_MODE 不继承父进程的错误模式
            CREATE_UNICODE_ENVIRONMENT 子进程的环境快使用Unicode字符（默认是ANSI字符）
            EXTENDED_STARTUPINFO_PRESENT 表明psiStartInfo是一个指向STARTUPINFOEX结构体的指针
            还可以在fdwCreate参数设置优先级
                IDLE_PRIORITY_CLASS
                BELOW_NORMAL_PRIORITY_CLASS
                NORMAL_PRIORITY_CLASS
                ABOVE_NORMAL_PRIORITY_CLASS
                HIGH_PRIORITY_CLASS
                REALTIME_PRIORITY_CLASS
        pvEnvironment指向新进程所使用的环境字符串，多数情况下传入NULL，使得子进程继承父进程的环境字符串，可以在创建进程时使用函数
            PVOID GetEnvironmentStrings()
        pszCurDir为子进程的工作目录，如果为NULL则工作目录为程序所在的当前目录
    进程id
        GetCurrentProcessId()
        GetCurrentThreadId()
        GetProcessId()
        GetThreadId()
        GetProcessIdByThread()
    进程的退出
        进程的退出的4种方式
            主线程的入口点函数返回
            进程的一个线程调用ExitProcess()
                VOID ExitProcess(UINT fuExitCode)
                实际上，主线程的入口点函数返回时就是返回到C运行库的启动代码，清理资源后显示调用ExitProcess()，并将入口点函数的返回值作为fuExitCode参数的
            另一个进程种的线程调用TerminateProcess()
                BOOL TerminateProcess(HANDLE hProcess, UINT fuExitCode)
                    注意这个函数是非阻塞的，会立即返回
            进程中的所有线程都自然死亡
        获取进程的退出代码
            BOOL GetExitCodeProcess(HANDLE hProcess, PDWORD pdwExitCode)
            当hProcess所标识的进程还在运行时，会向pdwExitCode指向的变量写入STILL_ACTIVE
            
    进程的权限
        在某些程序的manifest文件中会有这样的字段
            <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
                <security>
                    <requestPrivileges>
                        <requestedExecutionLevel level="requireAdministrator"/>
                    </requestPrivileges>
                </security>
            </trustInfo>
            level有3个值：requireAdministrator highestAvailable asInvoker
            OpenProcessToken(HANDLE hHandle, token, PHANDLE pHandle)
            GetTokenInformation()
                TokenElevationTypeDefault
                TokenElevationTypeFull
                TokenElevationTypeLimited
        要用提升的权限创建进程，需要下面函数
            typedef struct _SHELLEXECUTEINFO
            {
                DWORD cbSize;
                ULONG fMask;
                HWND hwnd;
                PCTSTR lpVerb;      //TEXT("runas")
                PCTSTR lpFile;      //可执行文件的路径
                PCTSTR lpParameters;
                PCTSTR lpDirectory;
                int nShow;
                HINSTANCE hInstApp;
                PVOID lpIDList;
                PCTSTR lpClass;
                HKEY hkeyClass;
                DWORD dwHotKey;
                union 
                {
                    HANDLE hIcon;
                    HANDLE hMonitor;
                } DUMMYUNIONNAME;
                HANDLE hProcess;
            } SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO;
        BOOL ShellExecuteEx(LPSHELLEXECUTEINFO pExecInfo);
            如果用户拒绝提升权限，返回FALSE
    获取一个exe或dll的句柄
        使用函数
            HMODULE GetModuleHandle(PCTSTR pszModule)
                pszModule参数为一个可执行文件或dll的文件的名称，可以为NULL，此时系统返回主调进程的可执行文件的句柄
        使用函数
            BOOL GetModuleHandleEx(
                DWORD dwFlags,          //使用GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
                LPCSTR lpModuleName,    //使用当前函数的地址
                HMODULE* phModule       //指向存储HMODULE变量的指针
            )
        使用链接器定义的伪变量__ImageBase，对其进行取地址
            extern "C" const IMAGE_DOS_HEADER __ImageBase;
        
        HMODULE hModule = GetModuleHandle(nullptr);
        _tprintf(TEXT("With GetModuleHandle(nullptr) = 0x%x\n"), hModule);
        _tprintf(TEXT("With __ImageBase = 0x%x\n"),__ImageBase);
        输出：
            With GetModuleHandle(nullptr) = 0xd3920000
            With __ImageBase = 0xd3920000
    把进程的伪句柄转换为真正的进程句柄
        HANDLOE hProcess;
        DuplicateHandle(
            GetCurrentProcess(),
            GetCurrentProcess(),
            &hProcess,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
        )
    命令行
        程序运行时会忽略可执行文件名称，把剩下的命令行参数传递给pCmdLine参数
        要获取包括可执行文件名称的命令行参数，使用函数
            LPWSTR GetCommandLine()
        可以将命令行参数拆分成一个字符串数组
            PWSTR* CommandLineToArgvW(PWSTR pszCmdLine, int* pNumArgs)
            pNumArgs存储字符串数组的大小
    环境变量
        在GUI程序中
            函数GetEnvironmentStrings()会将所有环境变量放到一个字符串中，以\n分割
        在CUI程序中可以直接使用main函数的TCHAR* env[]参数，数组的最后一个指针是NULL
            该字符串数组的每个字符串都是以"<varName>=<value>"的格式
        DWORD GetEnvironmentVariable(
            PCTSTR pszName, //变量名
            PTSTR pszValue, //存储变量值的缓冲区的指针
            DWORD cchValue  //存储变量值缓冲区大小的字符数，当为0时函数返回所需缓冲区的字符数，所以要乘以一个sizeof(TCHAR)
        )
        经常使用环境变量的一个场景是带有环境变量的字符串，例如路径%USERPROFILE%\Document，可以使用下面的函数来将一个字符串中的环境变量展开
            DWORD ExpandEnvironmentStrings(
                PTCSTR pszSrc,  //包含可替换环境变量的字符串
                PTSTR pszDst,   //接受替换后字符串的缓冲区
                DWORD chSize    //缓冲区大小，当为0时函数返回缓冲区需要的字符数，所以要乘以一个sizeof
            )
        使用下面函数来添加、删除、修改一个环境变量
            BOOL SetEnvironmentVariable(
                PCTSTR pszName,
                PCTSTR pszValue
            )
            将pszName所表示的一个变量设为pszValue参数的值，如果pszValue为NULL则删除
    进程的错误模式
        每个进程都关联了一组标志，这些标志的作用是让系统知道进程如何响应严重错误，包括磁盘介质错误、未处理的异常、文件查找错误、数据对齐错误
        子进程会继承父进程的错误模式标记
            UINT SetErrorMode(UINT fuErrorMode) 告诉系统如何处理错误
                fuErrorMode是下面参数按位或的结果
                    SEM_FAILCRITICALERRORS
                    SEM_NOGPFAULTERRORBOX
                    SEM_NOOPENFILEERRORBOX
                    SEM_NOALIGNMENTFAULTEXCEPT
    进程目录
        windows为进程记录当前目录，如果程序中不使用完整路径，windows会在当前目录查找，例如CreateFile()函数
            DWORD GetCurrentDirectory(
                DWORD cchCurDir,    //当缓冲区不够大时，函数返回需要的字符数且不会写入缓冲区，由于有260的MAX_PATH限制，所以可以直接传入一个260字符的数组
                PTSTR pszCurDir 
            )
            BOOL SetCurrentDirectory(PCTSTR pszCurDir) 设置当前目录
        进程可以在不同驱动器下各有一个当前目录
    进程优先级
        BOOL SetPriorityClass(HANDLE hProcess, DWORD fdwPriority)
            要改变自己的优先级，直接SetPriorityClass(GetCurrentProcess(), priority)即可
        DWORD GetPriorityClass(HANDLE hProcess)
    为GUI程序创建终端以方便调试
        if (!AllocConsole()) {
            // Add some error handling here.
            // You can call GetLastError() to get more info about the error.
            return -1;
        }
        // std::cout, std::clog, std::cerr, std::cin
        FILE* fDummy;
        freopen_s(&fDummy, "CONOUT$", "w", stdout);
        freopen_s(&fDummy, "CONOUT$", "w", stderr);
        freopen_s(&fDummy, "CONIN$", "r", stdin);
        std::cout.clear();
        std::clog.clear();
        std::cerr.clear();
        std::cin.clear();

        // std::wcout, std::wclog, std::wcerr, std::wcin
        HANDLE hConOut = CreateFile(_T("CONOUT$"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        HANDLE hConIn = CreateFile(_T("CONIN$"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        SetStdHandle(STD_OUTPUT_HANDLE, hConOut);
        SetStdHandle(STD_ERROR_HANDLE, hConOut);
        SetStdHandle(STD_INPUT_HANDLE, hConIn);
        std::wcout.clear();
        std::wclog.clear();
        std::wcerr.clear();
        std::wcin.clear();
    Windows版本
        typedef struct
        {
            DWORD dwOSVersionInfoSize;  //设置为sizeof(OSVERSIONINFOEX)
            DWORD dwMajorVersion;
            DWORD dwMinorVersion;
            DWORD dwBuildNumber;
            DWORD dwPlatformId;         //VER_PLATFORM_WIN32s(Win32s), VER_PLATFORM_WIN32_WINDOWS(Windows95/98), VERSION_PLATFORM_WIN32_NT(NT/2000/XP/2003/Vista)
            TCHAR szCSDVersionm[128];   //与操作系统有关的额外信息
            WORD wServicePackMajor;
            WORD wServicePackMinor;
            WORD wSuiteMask;
            BYTE wProductType;
            BYTE wReserved;
        } OSVERSIONINFOEX, *POSVERSIONINFOEX;

        BOOL GetVersionEx(POSVERSIONINFOEX pVersionInformation)
    获取所有线程
        #include <Tlhelp32.h>
        HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
            dwFlags:
                TH32CS_SNAPPROCESS 获取所有进程的信息，第二参数应为0，此时应该使用Process32First()和Process32Next()函数来进行枚举
            成功返回所要求的句柄，否则返回INVALID_HANDLE_VALUE
        下面结构体定义了使用Snapshot时的进程信息
            typedef struct tagPROCESSENTRY32 
            {
                DWORD     dwSize;
                DWORD     cntUsage;
                DWORD     th32ProcessID;
                ULONG_PTR th32DefaultHeapID;
                DWORD     th32ModuleID;
                DWORD     cntThreads;
                DWORD     th32ParentProcessID;
                LONG      pcPriClassBase;
                DWORD     dwFlags;
                CHAR      szExeFile[MAX_PATH];
            } PROCESSENTRY32;
        BOOL Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
        BOOL Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
            当枚举当前值成功时返回TRUE，否则返回FALSE
        正确使用这两个函数枚举信息的方法是
            if(Process32First(...))
            {
                do
                {
                    //使用PROCESSENTRY32对象
                }while(Process32Next(...))
            }
    异步IO
        父进程可以在CreateProcess()之后继续执行，并等待子进程初始化完毕窗口
            DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
线程
    每个线程都必须有一个入口点函数，主线程的入口点函数是main
    辅助线程的入口点函数形如：
        DWORD WINAPI ThreadFunc(PVOID pvParam)
    线程的创建
        HANDLE CreateThread(
            PSECURITY_ATTRIBUTES psa,           //如果希望线程有默认的安全属性，传入NULL，否则传入一个SECURITY_ATTRIBUTES指针，其中的bInheritHandle成员为true
            DWORD cbStackSize,                  //栈空间大小，实际分配的大小取max(cbStackSize, 连接器的/STACK设置)
            PTHREAD_START_ROUTINE pfnStartAddr, //线程函数的地址
            PVOID pvParam,                      //传递给线程函数的参数
            DWORD dwCreateFlags,                //为0时线程立刻执行，为CREATE_SUSPENDED则暂停执行，可以在恢复执行前更改线程的一些属性
            PDWORD pdwThreadID                  //存储新线程ID的指针，可以为NULL
        )
    线程的挂起
        一个线程可以被挂起多次，系统会给线程内核对象记录挂起计数，必须在计数减至0时线程才可能被调度
        在创建线程时可以将dwCreateFlags参数设置为CREATE_SUSPENDED
        也可以使用下面函数挂起
            DWORD SuspendThread()
    恢复执行时调用下面函数，会使得进程的挂起计数器减一
        DWORD ResumeThread(HANDLE hThread)
    线程的终止
        线程函数返回
        线程调用ExitThread()
            VOID ExitThread(DWORD dwExitCode)
        同一个进程或另一个进程的线程调用TerminateThread()
            BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
                该函数是非阻塞的，如果需要确认线程被终止，需要WaitForSingleObject()函数
        包含线程的进程终止运行
    优先级
        在CreateThread()创建线程时没有参数可以改变优先级，所以总是以normal创建的，必须手动在创建时传入CREATE_SUSPENDED标志，修改优先级后再恢复线程执行
        BOOL SetThreadPriority(HANDLE hThread, int nPriority)
            THREAD_PRIORITY_TIME_CRITICAL
            THREAD_PRIORITY_HIGHEST
            THREAD_PRIORITY_ABOVE_NORMAL
            THREAD_PRIORITY_NORMAL
            THREAD_PRIORITY_BELOW_NORMAL
            THREAD_PRIORITY_LOWEST
            THREAD_PRIORITY_IDLE
        int GetThreadPriority(HANDLE hThread)
    获取创建窗口的线程id
        DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
    线程同步
        原子操作
            以下函数对一个LONG型变量进行原子地加法运算
                LONG InterlockedAdd(PLONG volatile plAddend, LONG lIncrement)
                LONGLONG InterlockedAdd64(PLONGLONG volatile pllAddend, LONGLONG llIncrement)

            以下函数把第一参数所指向的内存地址的当前值原子地替换为第二个参数的值，并返回原来的值
                LONG InterlockedExchange(PLONG volatile plTarget, LONG lValue)
                LONGLONG InterlockedExchange64(PLONGLONG volatile plTarget, LONGLONG lValue)
                PVOID InterlockedExchangePointer(PVOID* volatile ppvTarget, PVOID pvValue)

            以下函数把第一参数的值与第3参数比较，如果相同，则把第2参数赋值给第一参数，并返回原来的值
                LONG InterlockedCompareExchange(PLONG plDestination, LONG lExchange, LONG lComparand) //内部过程（并非实现）
                {
                    LONG lRet = *plDestination;
                    if(*plDestination == lComparand)
                        *plDestination = lExchange;
                    return lRet;
                }
                PVOID* InterlockedCompareExchangePointer(PVOID* ppvDestination, PVOID pvExchange, PVOID pvComparand)
            
            以下函数原子地++或--
                LONG InterlockedIncrement(PLONG plAddend)
                LONG InterlockedDecrement(PLONG plAddend)

            原子单链表操作函数
                InitializeSListHead
                InterlockedPushEntrySList
                InterlockedPopEntrySList
                InterlockedFlushSList
                QueryDepthSList
            获取CPU信息
                typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION 
                {
                    ULONG_PTR                      ProcessorMask;
                    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
                    union 
                    {
                        struct 
                        {
                            BYTE Flags;
                        } ProcessorCore;
                        struct 
                        {
                            DWORD NodeNumber;
                        } NumaNode;
                        CACHE_DESCRIPTOR Cache;
                        ULONGLONG        Reserved[2];
                    } DUMMYUNIONNAME;
                } SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;
            
            BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
        关键段
            需要给每一个要被共享的数据定义一个CRITICAL_SECTION类型的变量，然后使用
                VOID InitializeCriticalSection(PCRITICAL_SECTION pcs) 初始化CRITICAL_SECTION变量
            操作
                VOID EnterCriticalSection(PCRITICAL_SECTION PCS)
                VOID LeaveCriticalSection(PCRITICAL_SECTION PCS)
                BOOL TryEnterCriticalSection(PCRITICAL_SECTION pcs) 当不能进入关键段时立即返回false
            处于等待状态的线程不会处于饥饿状态，因为对EnterCriticalSection()的调用有一个超时机制，超时时长由
                HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager的CriticalSectionTimeout值决定，默认为30天时间
            当线程不再需要访问共享资源时
                VOID DeleteCriticalSection(PCRITICAL_SECTION pcs)
            当EnterCriticalSection()失败需要等待时，线程需要从用户态->内核态，这个开销很大，可以在使用关键段的同时使用自旋锁来初始化
                BOOL InitializeCriticalSectionAndSpinCount(PCRITICAL_SECTION pcs, DWORD dwSpinCount) 返回函数是否成功
                DWORD SetCriticalSectionSpinCount(PCRITICAL_SECTION pcs, DWORD dwSpinCount)  
                    dwSpinCount：自旋锁循环次数，值可以为0~0xFFFFFF
        读写锁
            读写锁可以区分只读线程和写入线程，写入线程独占资源的访问
                VOID InitializeSRWLock(PSRWLOCK SRWLock)
            写入线程
                VOID AcquireSRWLockExclusive(PSRWLOCK SRWLock)
                VOID ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
            读取线程
                VOID AcquireSRWLockShared(PSRWLOCK SRWLock)
                VOID ReleaseSRWLockShared(PSRWLOCK SRWLock)
        条件变量
            BOOL SleepConditionVariableCS(
                PCONDITION_VARIABLE pConditionVariable,
                PCRITICAL_SECTION pCriticalSection,
                DWORD dwMilliseconds
            )
            BOOL SleepConditionVariableSRW(
                PCONDITION_VARIABLE pConditionVariable,
                PSRWLOCK PSRWLOCK,
                DWORD dwMilliseconds,
                ULONG Flags     //写入线程传入0，读取线程传入CONDITION_VARIABLE_LOCKMODE_SHARED
            )
            VOID WakeConditionVariable(PCONDITION_VARIABLE pConditionVariable)
            VOID WakeAllConditionVariable(PCONDITION_VARIABLE pConditionVariable)
        DWORD WaitForSingleObject(HANDLE hObject, DWORD dwMilliseconds)
            hObject标识要等待的内核对象
            dwMilliseconds指定调用线程愿意等待的时间（无限时间设为INFINITE），如果超时，返回WAIT_TIMEOUT，否则返回WAIT_OBJECT_0
        DWORD WaitForMultipleObjects(DWORD dwCount, CONST HANDLE* phObjects, BOOL bWaitAll, DWORD dwMilliseconds)
            dwCount指定所需等待的内核对象数组的元素的个数
            bWaitAll为true时，等待所有内核对象，否则只等待任何一个对象
            当bWaitAll为true，且所有对象都被触发时，函数返回WAIT_OBJECT_0
            当bWaitAll为false，函数会返回WAIT_OBJECT_0 ~ WAIT_OBJECT_0 + dwCount - 1中间的值，标识第几个内核对象被触发，所以可以使用一个switch语句来判断结果
                auto const dw = WaitForMultipleObject(4, arr, FALSE, 5000);
                switch(dw)
                {
                case WAIT_FAILED: //...
                case WAIT_TIMEOUT: //...
                case WAIT_OBJECT_0: //第0个内核对象被触发
                case WAIT_OBJECT_0 + 1: //第1个内核对象被触发
                ...
                case WAIT_OBJECT_0 + 3: //第3个内核对象被触发
                }
        事件
            创建事件
                HANDLE CreateEvent(
                    PSECURITY_ATTRIBUTES psa,
                    BOOL bManualReset,  //自动重置事件被触发时，只有一个正在等待该事件的线程成为可调度状态，手动充值事件被触发时，所有等待的线程都将成为可调度状态
                    BOOL bInitialState, //初始化为触发还是未触发状态
                    PCTSTR pszName
                )
                另外记得需要使用CloseHandle()将事件句柄关闭
            触发事件
                BOOL SetEvent(HANDLE hEvent)
            将事件->未触发状态
                BOOL ResetEvent(HANDLE hEvent)
            脉冲触发
                BOOL PulseEvent(HANDLE hEvent)
                    函数先触发事件，然后立即恢复到未触发状态，类似于
                        SetEvent(hEvent);
                        ResetEvent(hEvent);
        计时器
            可等待的计时器是一种内核对象，可以在某个指定的时间触发，或每隔一段时间触发一次
            创建
                HANDLE CreateWaitableTimer(
                    PSECURITY_ATTRIBUTES psa, 
                    BOOL bManualReset,  //手动重置计时器被触发时，正在等待该计时器的所有线程都变成可调度状态，自动重置定时器被触发时，只有一个正在等待该计时器的线程变成可调度状态
                    PCTSTR pszName
                )
            触发
                BOOL SetWaitableTimer(
                    HANDLE hTimer,
                    const LARGE_INTEGER* pDueTime,          指定计时器第一次触发的事件
                    LONG lPeriod,                           指定第一次触发之后，每个多久再次触发，如果只想触发一次，传入0
                    PTIMERAPCROUTINE pfnCompletionRoutine,
                    PVOID pvArgToCompletionRoutine,
                    BOOL bResume                            是否挂起和唤醒计算机，通常传入FALSE
                )
            取消触发
                BOOL CancelWaitableTimer(HANDLE hTimer)
            APC（asynchronous procedure call）调用
                当线程创建了定时器，并使用SleepEx(), WaitForSingleObjectEx(), WaitForMultipleObjectEx(), MsgWaitForMultipleObjectEx(), SingleObjectAndWait()进入等待状态时
                可以在调用SetWaitableTimer()时向pfnCompletionRoutine传递一个函数指针，函数原型形如
                    VOID APIENTRY TimerAPCRoutine(PVOID pvArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue) 
                    {
                        //dwTimerLowValue 和 dwTimerHighValue表示计时器被触发的时间
                    }
                需要保证APC函数在计时器再次被触发前执行完毕
        信号量
            创建
                HANDLE CreateSemaphore(
                    PSECURITY_ATTRIBUTE psa, 
                    LONG lInitialCount,     在创建信号量时有多少个资源可用
                    LONG lMaximumCount,     应用程序能够处理的资源的最大数量
                    PCTSTR pszName
                )
            释放
                BOOL ReleaseSemaphore(
                    HANDLE hSemaphore, 
                    LONG lReleaseCount,     //把lReleaseCount的值加到信号量的当前资源计数上
                    PLONG plPreviousCount   //返回当前资源计数的值，可以为NULL
                )
        互斥量
            创建
                HANDLE CreateMutex(
                    PSECURITY_ATTRIBUTE psa,
                    BOOL bInitialOwner, 如果为FALSE，互斥量不被任何线程占有，处于触发状态，如果为TRUE，则对象的线程ID设为调用线程的线程ID，处于未触发状态
                    PCTSTR pszName
                )
            释放
                BOOL ReleaseMutex(HANDLE hMutex)
        组合函数
            经常需要触发一个对象并等待另一个对象
                DWORD SignalObjectAndWait(
                    HANDLE hObjectToSignal, 只能是互斥量、信号量或事件
                    HANDLE hObjectToWaitOn, 可以是互斥量、信号量、事件、计时器、进程、线程、作业、控制台输入、变更通知
                    DWORD dwMilliseconds,   花多长时间来等待hObjectToWaitOn
                    BOOL bAlertable         指定当线程处于等待状态时，是否能够对添加到队列中的APC进行处理
                )
    线程池
        以异步方式调用函数
        每隔一段时间调用一个函数
            定义所需要执行的回调函数，形如
                VOID CALLBACK TimeoutCallback(PTP_CALLBACK_INSTANCE pInstance, PVOID pvContext, PTP_TIMER pTimer)
            创建线程池计时器
                PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnTimerCallback, PVOID pvContext, PTP_CALLBACK_ENVIRON pcbe)
            向线程池注册计时器
                VOID SetThreadpoolTimer(PTP_TIMER pTimer, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
            关闭
                void CloseThreadpoolTimer(PTP_TIMER pti)
            
COM
    每个使用COM库的线程（注意是线程）都必须分别调用一次初始化函数
        HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
            pvReserved必须设置为NULL
            dwCoInit必须为以下值：
                COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE 表明该线程必须不与其他线程共享同一个COM指针，且包含一个message loop
                COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE 不满足上面条件之一时使用这个参数
    每个使用COM库的线程在退出前都必须调用一次释放COM库的函数
        void CoUninitialize()
    大多数COM函数返回一个HRESULT类型的值，该类型实际上是一个32为整数，其最高位为0时表示成功，为1时表示错误，即
        0x0 - 0x7FFFFFFF 为成功结果
        0x80000000 - 0xFFFFFFFF 为错误结果
    所以为了判断是否成功，可以使用最高位与1<<15按位与，或者直接判断其是否大于0，因为负数的最高位就是1
    windows还提供了SUCCEEDED()和FAILED()宏，可以直接将结果作为布尔值
    使用一个GUID类型的结构体来标识COM借口或这COM类，GUID实际上是一个128位的整数
    习惯上，将COM接口以IID_I开头命名，COM类以CLSID_开头命名
        HRESULT CoCreateInstance(
            REFCLSID rclsid,        //类的GUID
            LPUNKNOWN pUnkOuter,    //取NULL
            DWORD dwClsContext,     
            REFIID riid,            //类所实现的COM接口的GUID
            LPVOID* ppv             //通常将需要赋值给的指针做reinterpret_cast<void**>(&pt)
        )
        第三参数的取值为：
            CLSCTX_INPROC_SERVER    Same process
            CLSCTX_LOCAL_SERVER     Different process, same computer
            CLSCTS_REMOTE_SERVER    Differnet computer
            CLSCTX_ALL              使用这个对象支持的最高效的选项
    注意，任何指向COM接口的指针，都必须在复制前调用AddRef()方法，在结束使用后调用Release()方法
    要查询一个COM接口指针所指向的COM对象是否实际上支持另一个接口，使用
        HRESULT QueryInterface(REFIID riid, void** ppvObject)
            riid为接口的GUID
            ppvObject为所要修改的指针，通常要reinterpret_cast<void**>(pt)
    有一些COM函数需要在内部分配内存，此时需要显式的调用CoTaskMemFree()函数释放内存，例如
        PWSTR pszFilePath;
        auto hr = pShellItem->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath); //这个函数会分配一个字符串的内存空间，并将指针pszFilePath设置为新分配的空间
        if(SUCCEEDED(hr))
        {
            //...
            CoTaskMemFree(pszFilePath);
        }
    由于要显式的对COM接口指针调用Release()方法十分繁琐，在<atlbase.h>中定义了一种智能指针类CComPtr<>
    这种智能指针类在析构时自动释放，在复制时自动调用AddRef()方法 
    CComPtr<T>定义了.CoCreateInstance()方法，只需传入__uuidof(COMClassName)即可创建一个指向COMClassName对象，且类型为T（某个接口类型）的指针

UI相关
    一个窗口实际上就是一个矩形区域，窗口接受用户的交互，并与其他窗口共享屏幕面积
    启动系统时，系统会创建一个桌面，桌面也是一个窗口，可以使用下面函数来获取桌面窗口的窗口句柄
        HWND GetDesktopWindow()
    一个窗口包含
        一个客户界面，客户界面是接收用户输入并渲染输出的区域，每一个产生窗口的GUI应用都必须定义一个window过程
        一个非客户界面，包括标题栏，菜单栏、最大化最小化关闭按钮、滚动条
    一个窗口的属性
        类名：每个窗口都属于一个窗口类，应用程序必须在创建窗口前注册一个窗口类，窗口类通常使用窗口过程定义窗口的行为
        窗口名：窗口名是标识一个窗口的字符串，通常显示在标题栏上，有些特殊窗口不显示窗口名，例如复选框列表
        窗口样式：是一些预定义的常量以WS_开头，定义了窗口除了窗口类之外的显示方法和行为，应用程序通常在创建窗口时就指定窗口样式，但也可以在创建之后再修改，使用SetWindowLong()函数
        拓展窗口样式：定义除了窗口类和窗口样式之外的窗口的显示和行为
        位置：窗口的位置是相对于屏幕左上角为原点坐标的位置，对于子窗口则是相对于父窗口客户界面的左上角为坐标
            WindowFromPoint()返回占据屏幕上某个点的窗口的窗口句柄
        大小：以宽高来定义，单位为像素，一个窗口的大小可以是0*0，此时系统将为其设置系统的最小窗口大小
            GetSystemMetrics()
            可以通过AdjustWindowRect()函数和期望的客户界面的大小来获取期望的整个窗口的大小作为CreateWindow()函数的参数
        父窗口或窗口句柄的所有者：当窗口有父窗口时行为会发生改变，例如可以使得子窗口只允许在父窗口的范围内移动。当一个窗口没有父窗口，或者父窗口是桌面窗口时，称为“最上层窗口”
            EnumWindows()
        菜单句柄或子窗口标识符:
        应用程序句柄：由于同一个程序可能运行多个实例，所以需要用不同的应用程序句柄来唯一标识
        创建窗口相关的数据
        窗口句柄
    可以通过CreateMutex()函数来创建一个系统范围的全局锁，当函数失败时即表明该程序有另一个实例正在运行，此时可以退出，来保证程序只能运行一个实例
    窗口类
        一个程序必须先注册一个窗口类
            下面结构体中只有打*的成员是必须填入的项
            typedef struct tagWNDCLASSEXW
            {
                UINT cbSize;
                UINT style;
                WNDPROC lpfnWndProc;    //*窗口过程函数的指针
                int cbClsExtra;         //这个窗口类所有窗口所需共享的额外的内存
                int cbWndExtra;         //这个窗口类所有窗口各自所需的额外的内存
                HINSTANCE hInstance;    //*
                HICON hIcon;
                HCURSOR hCursor;
                HBRUSH hbrBackground;   //定义窗口的客户区域的背景
                LPCWSTR lpszMenuName;
                LPCWSTR lpszClassName;  //*
                HICON hIconSm;
            } WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW; 
            
            其中lpfnWndProc是一个函数指针，指向窗口过程函数，形如
                LRESULT Wndproc(
                    HWND unnamedParam1,     //接受消息的窗口句柄
                    UINT unnamedParam2,     //uMsg
                    WPARAM unnamedParam3,   //uMsg的wParam
                    LPARAM unnamedParam4    //uMsg的lParam
                );
            ATOM RegisterClassEx(const WNDCLASSEXW* unnamedParam1)
                函数成功时返回一个标识这个窗口类的id，否则返回0
                
        一个窗口类具有一个窗口过程，而且可以创建多个窗口，这个窗口过程控制所有由这个窗口类创建的窗口
        有3种窗口类
            系统类
                系统类是由系统注册的窗口类，一部分系统类可以给用户程序使用
                    Button
                    ComboBox
                    Edit
                    ListBox
                    MDIClient
                    ScrollBar
                    Static
            
            程序全局类
                全局窗口类可以由一个exe或dll来注册，并被所有其他模块使用（即在所有其他模块创建这个窗口类的窗口）
            程序本地类
                只能由当前注册窗口类的exe或dll来创建这个窗口类的窗口
        当dll从内存中卸载时，系统不会自动删除其注册的窗口类，所以需要手动取消注册，否则会导致访问出错
            BOOL UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
                函数失败时返回0
    窗口过程
        一个窗口过程函数具有4个参数：窗口句柄、UINT类型的信息标识符、WPARAM和LPARAM类型的两个信息的数据，函数返回一个有符号整数，整数的值根据特定的信息应具有特定意义
        有一个默认提供的窗口过程函数DefWindowProc()，它提供了所有窗口过程都必须具备的一些代码，直接将窗口过程函数的参数传给这个函数做剩下的处理
            LRESULT LRESULT DefWindowProc(
                HWND   hWnd,
                UINT   Msg,
                WPARAM wParam,
                LPARAM lParam
            );
        子类
            可以对窗口过程使用子类的方法来干预窗口过程，使得可以在子类窗口过程中修改预处理窗口信息，再调用原来的窗口过程
            有两种子类的构造方法
                实例子类：只对窗口类的某一个窗口实例的窗口过程子类化
                    需要使用下面的函数来修改这个窗口的窗口过程，并将nIndex设置为GWL_WNDPROC
                        LONG SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
                            nIndex的值可以是：
                                GWL_EXSTYLE
                                GWL_HINSTANCE
                                GWL_ID
                                GWL_STYLE
                                GWL_USERDATA
                                GWL_WNDPROC
                            函数成功时返回nIndex的值所对应的之前的值，例如返回之前的窗口过程函数指针
                    修改了窗口过程之后，如果需要调用原来的窗口过程函数做进一步处理，需要将上面函数的返回值保存，并使用下面函数调用原窗口过程
                        LRESULT CallWindowProc(
                            WNDProc lpPrevWndFunc,
                            HWND hWnd,
                            UINT Msg,
                            WPARAM wParam,
                            LPARAM lParam
                        )
                    有时也需要还原窗口过程，也需要用到SetWindowLong()函数返回的原窗口过程指针
                全局子类：对一个窗口类的所有窗口实例的窗口过程子类化
                    需要调用下面的函数来修改这个类的窗口过程，并将nIndex设置为GCL_WNDPROC
                        DWORD SetClassLong(HWND hWnd, int nIndex, LONG dwNewLong)
                            nIndex的值可以是
                                GCL_CBCLSEXTRA
                                GCL_CBWNDEXTRA
                                GCL_HBRBACKGROUND
                                GCL_HCURSOR
                                GCL_HICON
                                GCL_HICONSM
                                GCL_HMODULE
                                GCL_HMENUNAME
                                GCL_STYLE
                                GCL_WNDPROC
                            函数成功时返回nIndex的值所对应的之前的值
        超类
            可以在程序中对现有的窗口类进行功能拓展，成为超类
            超类拥有自己的窗口过程
            与子类化不同的是，超类在处理窗口创建消息（WM_NCCREATE WM_CREATE）时必须调用原本类的窗口过程函数
            先调用下面函数来获得窗口类的信息
                BOOL GetClassInfo(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASS lpWndClass)
            然后修改lpWndClass中的lpszClassName成员为超类的类名，把hInstance成员设置为自己的句柄
            然后调用RegisterClass()函数来注册超类
            同时注意需要保存lpfnWndProc成员，以备后面还原
        
        HWND FindWindowEx(
            HWND hWndParent,        //从父窗口中搜索子窗口，如果为NULL则搜索桌面窗口的子窗口
            HWND hWndChildAfter,    //从这个指定的子窗口中搜索父窗口在Z轴上的下一个子窗口，如果为NULL，则从父窗口的第一个子窗口开始找
            LPCSTR lpszClass,       //窗口类名
            LPCSTR lpszWindow       //窗口的标题名，如果为NULL则找所有的窗口
        )
            
    窗口样式
        重叠窗口 WS_OVERLAPPED WS_OVERLAPPEDWINDOW
            通常用作程序的主窗口
        弹出窗口 
            通常用作临时窗口，例如对话框、消息框
            弹出窗口的标题栏是可选的
            WS_POPUP 
            WS_POPUPWINDOW 包含窗口边框和菜单栏
            WS_CAPTION | WS_POPUPWINDOW 包含标题栏、窗口边框和菜单栏
        子窗口 WS_CHILD
            子窗口不能创建菜单栏
        

    HWND CreateWindowEx(
        DWORD dwExStyle,
        LPCWSTR lpClassName,    //必须为之前调用过RegisterClass()注册过的窗口类的类名，否则ShowWindow()将无效
        LPCWSTR lpWindowName,   //窗口标题栏显式的字符串
        DWORD dwStyle,
        int X,                  //窗口左上角的水平位置，如果窗口是一个子窗口，则为相对于父窗口的水平位置，如果使用overlapped窗口样式，则可以使用CW_USEDEFAULT来自动分配位置
        int Y,                  //窗口左上角的垂直位置，如果X值使用CW_USEDEFAULT，则Y被忽略
        int nWidth,             //
        int nHeight,
        HWND hWndParent,
        HMENU hMenu,            //创建一个子窗口时需要一个有效的HWND窗口句柄
        HINSTANCE hInstance,    //
        LPVOID lpParam
    );
    CreateWindow()函数其实是CreateWindowEx()函数的简化版，使用了默认的dxExStyle
        #define CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
        CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)
    创建窗口后，系统会在窗口实际显示出来之前发送下面两个信息给窗口过程函数
        创建完窗口的非客户界面后 -> WM_NCCREATE 
        创建完窗口的客户界面后 -> WM_CREATE

    BOOL ShowWindow(HWND hWnd, int nCmdShow)
        当用来显示应用程序的主窗口时，参数nCmdShow必须为SW_SHOWDEFAULT
        当第一次调用这个函数时，nCmdShow参数的值应该为WinMain函数的参数
        再次调用这个函数时，第二参数的值可以是
            SW_HIDE
            SW_SHOWNORMAL SW_NORMAL
            SW_SHOWMINIMIZED
            SW_SHOWMAXIMIZED SW_MAXIMIZE
            SW_SHOWNOACTIVE
            SW_SHOW
            SW_MINIMIZE
            SW_SHOWMINNOACTIVE
            SW_SHOWNA
            SW_RESTORE
            SW_SHOWDEFAULT
            SW_FORCEMINIMIZE
    
    BOOL IsWindow(HWND hWnd)
        函数返回hWnd所代表的窗口句柄是否是一个存在的窗口
        不要对非本线程创建的窗口调用这个函数来检测，因为窗口句柄的值可能被循环使用，即这个窗口句柄可能已经指向另一个窗口
    BOOL IsWindowVisible(HWND hWnd)
        函数返回hWnd所代表的窗口是否可见
    HWND GetWindow(HWND hWnd, UINT uCmd)

    
进程通信
    SendMessage方式
        typedef struct tagCOPYDATASTRUCT {
            ULONG_PTR dwData;   //发送数据的类型，用户自己定义
            DWORD cbData;       //发送数据的字节数
            PVOID lpData;       //发送数据的指针
        };

        LRESULT SendMessage(
            HWND hWnd,      //接收消息的窗口的句柄
            UINT Msg,       //
            WPARAM wParam,  
            LPARAM lpParam  //与wParam一样都是与具体消息类型有关的额外参数
        )

        发送程序
            #include <windows.h>

            int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, int nCmdShow)
            {
                wchar_t str[] = L"Hello world";     //发送这个字符串

                auto receiveWindow = FindWindow(nullptr, L"Receiver");
                if (receiveWindow == nullptr)
                    return 1;

                COPYDATASTRUCT copyData{};
                copyData.lpData = str;
                copyData.cbData = sizeof(str);

                HWND hwnd = CreateWindowEx(
                    0,                              // Optional window styles.
                    L"Sender",                      // Window class
                    L"Sender Title",                // Window text
                    WS_OVERLAPPEDWINDOW,            // Window style

                    // Size and position
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,

                    NULL,       // Parent window    
                    NULL,       // Menu
                    hInstance,  // Instance handle
                    NULL        // Additional application data
                );  //产生一个隐藏的窗口，只用来发送信息，所以无需注册窗口类

                SendMessage(receiveWindow, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&copyData);
            }

        接收程序
            #include <windows.h>

            LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

            int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
            {
                // Register the window class.
                const wchar_t CLASS_NAME[] = L"Sample Window Class";

                WNDCLASS wc = { };

                wc.lpfnWndProc = WindowProc;
                wc.hInstance = hInstance;
                wc.lpszClassName = CLASS_NAME;

                RegisterClass(&wc);

                // Create the window.

                HWND hwnd = CreateWindowEx(
                    0,                              // Optional window styles.
                    CLASS_NAME,                     // Window class
                    L"Receiver",                        // Window text
                    WS_OVERLAPPEDWINDOW,            // Window style

                    // Size and position
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,

                    NULL,       // Parent window    
                    NULL,       // Menu
                    hInstance,  // Instance handle
                    NULL        // Additional application data
                );

                if (hwnd == NULL)
                {
                    return 0;
                }

                ShowWindow(hwnd, nCmdShow);

                // Run the message loop.

                MSG msg = { };
                while (GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

                return 0;
            }

            LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
            {
                switch (uMsg)
                {
                case WM_DESTROY:
                    PostQuitMessage(0);
                    return 0;

                case WM_PAINT:
                {
                    PAINTSTRUCT ps;
                    HDC hdc = BeginPaint(hwnd, &ps);

                    FillRect(hdc, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));

                    EndPaint(hwnd, &ps);
                    break;
                }
                case WM_COPYDATA:
                {
                    auto pData = reinterpret_cast<COPYDATASTRUCT*>(lParam);
                    MessageBox(nullptr, (LPCWSTR)pData->lpData, L"Get Message", MB_OK); //将接收到的字符串显示到一个消息框中
                    break;
                }
                return 0;

                }
                return DefWindowProc(hwnd, uMsg, wParam, lParam);
            }

文件IO
    DWORD GetFileType(HANDLE hDevice)
        函数返回值：
            FILE_TYPE_UNKNOWN
            FILE_TYPE_DISK  磁盘文件
            FILE_TYPE_CHAR  文件是一个字符文件，一般是一个并口设备或控制台
            FILE_TYPE_PIPE  文件是一个命名管道或匿名管道
    创建文件
        HANDLE CreateFile(
            LPCSTR                lpFileName,               完整文件路径，一般最长只能为MAX_PATH，其中反斜线+转义符只算1个字符，拓展名也算进长度，当长度超出时，直接返回INVALID_HANDLE_VALUE，并且GetLastError()返回3，错误信息为The system cannot find the path specified.
            DWORD                 dwDesiredAccess,          可以为GENERIC_READ, GENERIC_WRITE, 和两者的按位或
            DWORD                 dwShareMode,              指定是否可以与其他进程共享，如果为0，则当前进程必须先关闭句柄，其他进程才能使用，可选的值为0, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE
            LPSECURITY_ATTRIBUTES lpSecurityAttributes,     可以为NULL
            DWORD                 dwCreationDisposition,
            DWORD                 dwFlagsAndAttributes,
            HANDLE                hTemplateFile
        )
            函数失败返回INVALID_HANDLE_VALUE
            dwCreationDisposition的值可以是：
                CREATE_NEW 创建一个新文件，如果同名文件已经存在，则调用失败
                CREATE_ALWAYS 总是创建一个新文件，如果同名文件存在，则覆盖
                OPEN_EXISTING 打开一个已有文件，如果不存在则失败，当使用这个函数来打开设备时，必须使用这个值
                OPEN_ALWAYS 打开一个已有文件，如果不存在则创建新文件
                TRUNCATE_EXISTING 打开已有文件，并清除内容，如果文件不存在则失败
            dwFlagsAndAttributes
                FILE_ATTRIBUTE_ARCHIVE
                FILE_ATTRIBUTE_NORMAL
                FILE_ATTRIBUTE_ENCRYPTED
                FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
                FILE_ATTRIBUTE_OFFLINE
                FILE_ATTRIBUTE_READONLY
                FILE_ATTRIBUTE_SYSTEM
                FILE_ATTRIBUTE_TEMPORARY    文件数据只会使用一小段时间，为了提高性能，系统尽量将文件保存到内存中
                FILE_FLAGS_OVERLAPPED 用于异步IO
    获取文件信息
        BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER pliFileSize)
            返回文件的逻辑大小
        DWORD GetCompressedFileSize(PCTSTR pszFileName, PDWORD pdwFileSizeHigh)
            返回文件的物理大小的低32位，即文件在硬盘上实际占用的字节数
            通过指针pdwFileSizeHigh来存储大小的高32位
    读取
        BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER pliNewFilePointer, DWORD dwMoveMethod)
            设置文件指针，并在pliNewFilePointer中存入新的文件指针
            可以通过将liDistanceToMove参数设为0来获取当前的文件指针位置
        typedef struct _OVERLAPPED
        {
            /*---由驱动程序设置，返回时使用他们的值---*/
            DWORD Internal;     //存储错误码
            DWORD InternalHigh; //存储已传输的字节数
            
            /*---需要在调用时初始化---*/
            DWORD Offset;       //对于非文件设备，设置为0
            DWORD OffsetHigh;
            HANDLE hEvent;
        } OVERLAPPED, *LPOVERLAPPED;
        BOOL ReadFile(HANDLE hFile, PVOID pvBuffer, DWORD nNumBytesToRead, PDWORD pdwNumBytes, OVERLAPPED* pOverlapped)
            使用异步IO时，将pdwNumBytes设置为NULL
        BOOL ReadFileEx(HANDLE hFile, PVOID pvBuffer, DWORD nNumBytesToRead, OVERLAPPED* pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE pFnCompletionRoutine)
            IO完成时调用pFnCompletionRoutine所指向的回调函数
            回调函数形如
                VOID WINAPI CompletionRoutine(DWORD dwError, DWORD dwNumBytes, OVERLAPPED* po)
    写入
        BOOL WriteFile(HANDLE hFile, CONST VOID* pvBuffer, DWORD nNumBytesToWrite, PDWORD pdwNumBytes, OVERLAPPED* pOverlapped)
            使用异步IO时，将pdwNumBytes设置为NULL
        BOOL WriteFileEx(HANDLE hFile, PVOID pvBuffer, DWORD nNumBytesToRead, OVERLAPPED* pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE pFnCompletionRoutine)
        BOOL FlushFileBuffers(HANDLE hFile)


Direct2D
    D2D是用来替代已有的GDI GDI+的2D图形API，它可以在有硬件加速的条件下基于Direct3D渲染，也可以在没有时基于软件渲染
    包含头文件
        <d2d1.h>    C和C++的主要D2D API
        <d2d1_1.h>  给win8和之后用的D2D API
        
        <d2d1helper.h>  C++的辅助函数、类和结构体
        <d2d1_1helper.h> win8之后的版本

        <d2dbasetypes.h> 基本绘图原语，例如点和举行，包含于<d2d1.h>中
        <d2d1effects.h> 图形效果，win8之后可用
        <d2d1effecthelper.h> 图形效果的辅助函数、类和结构体，win8之后可用
        <d2derr.h>  定义了d2d的错误码，包含于<d2d1.h>中
    链接库
            d2d1.lib        
    创建一个D2D工厂并指定渲染目标
        ID2D1Factory* pD2DFactory{};
        D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pD2DFactory)
    创建
        创建完D2D工厂后，指定渲染目标
            ID2D1HwndRenderTarget* pRt{};
            auto const hr = pD2DFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),     //使用默认的渲染目标属性
                D2D1::HwndRenderTargetProperties(   //设置HWND的渲染属性
                    hwnd,                       //渲染窗口
                    D2D1::SizeU(...)            //渲染大小
                ),
                &pRt
            );
        创建绘图资源
            创建完渲染目标后可以从这个渲染目标创建各种绘图资源，例如画刷
                ID2D1SolidColorBrush* pBlackBrush{};
                pRt->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBlackBrush)
            有以下几种绘图资源
                位图bitmap
                    ID2D1RenderTarget::CreateBitmapFromWicBitmap()
                画刷brush
                    ID2D1SolidColorBrush
                    ID2D1LinearGradientBrush
                    ID2D1RadialGradientBrush
                    ID2D1BitmapBrush
                几何形状geometry
                    几何形状ID2D1Geometry用于创建复杂的形状
                图层layer
                
                网格mesh
    绘制
        使用渲染目标来绘制
        pRt->BeginDraw();
        pRt->DrawRectangle(D2D1::RectF(...));
        auto const hr = pRt->EndDraw();
    释放
        需要释放渲染目标和渲染设备和绘图资源
            SafeRelease(pRt);
            SafeRelease(pBlackBrush);
        最后释放D2D工厂
            SafeRelease(pD2DFactory)
DirectWrite
    DWWrite用于渲染高质量的Microsoft ClearType、OpenType，当与Direct2D使用时支持硬件加速的渲染
    typeface和 font的区别
        typeface其实是通常意义上的“字体”
        font是指某个fontface的某种具体呈现结果，包含了typeface的某个粗细，斜体，字号
    IDWriteLocalizedStrings
    {
        HRESULT FindLocaleName(WCHAR const* localeName, UINT32* index, BOOL* exists)
            当localeName不存在时，index赋值为UINT_MAX，exists赋值为FALSE，返回S_OK
        UINT32 GetCount()
            返回语言的个数
        HRESULT GetLocaleName(UINT32 index, WCHAR* localeName, UINT32 size)
            返回第index（从0开始）个locale名存储到localeName字符串中，size为数组的大小（以字符数为单位，包括\0）
        GetLocaleNameLength()
            
        GetString()
        GetStringLength()
    }

    IDWriteFontFamily
    {
        HRESULT GetFamilyNames(IDWriteLocalizedStrings** names)
        GetFirstMatchingFont()
        GetMatchingFonts()
    }

    IDWriteFontCollection
    {
        HRESULT FindFamilyName(WCHAR const* familyName, UINT32* index, BOOL* exist)
        HRESULT GetFontFamily(UINT32 index, IDWriteFontFamily** fontFamily)
        GetFontFamilyCount()
        GetFontFromFontFace()
        
    }

    IDWriteFactory
    {
        HRESULT GetSystemFontCollection(IDWriteFontCollection** fontCollection, BOOL checkForUpdates)
    }
    IDWriteFactory1
    IDWriteFactory2
    IDWriteFactory3
    IDWriteFactory4
    IDWriteFactory5
    IDWriteFactory6
    IDWriteFactory7
    HRESULT DWriteCreateFactory(
        DWRITE_FACTORY_TYPE factoryType,    //DWRITE_FACTORY_TYPE_SHARED:当前进程的其他部分共享这个工厂，共享一些字体数据 DWRITE_FACTORY_TYPE_ISOLATED
        REFIID iid,         //__uuidof(IDWriteFactory)
        IUnknown** factory  //指向要存储所创建的DirectWrite工厂的指针
    )
MFC
    Microsoft Foundation Class主要是Win32和COM的面向对象化的接口
    MFC源码
        头文件 \atlmfc\include
        源文件 \atlmfc\src\mfc
    MFC程序组成部分
        线程对象 CWinThread
        应用对象 CWinApp
        文档模板 CDocTemplate
        Frame：所有可视组件都显示在这个frame窗口中 CFrameWnd
        文档 CDocument
        View CView
            常见View
                CScrollView
                CFormView
                CEditView
                CTreeView
                CListView
                CRichEditView
        
MVVM
    View定义了界面，通常是Xaml，或者极少与界面呈现相关的代码
    ViewModel定义了界面与核心业务逻辑和核心业务数据交互的逻辑，包括界面元素响应的处理函数
    Model定义了核心业务逻辑，与界面完全剥离开
C++/WinRT
    每个winrt中的类都有一个接收nullptr的构造函数，用来延迟初始化，而默认构造函数会实际构造对象
    数据绑定
        数据绑定的3歌要素
            数据源
            绑定目标（通常就是UI元素）
            传输数据（实际发生数据传输的对象）
        一个类要支持单项或双向绑定，就需要在数据变化时发出事件，此时需要让类实现Windows::UI::Xaml::Data::INotifyPropertyChanged接口
            例如下面这个类ViewModel需要跟UI的一个Button的字符串绑定
                /*idl*/
                runtimeclass HostViewModel : Windows.UI.Xaml.Data.INotifyPropertyChanged
                {
                    HostViewModel();
                    String NextButtonText;
                }

                /*.h*/
                struct HostViewModel
                {
                    winrt::
                }
        所有在XAML中使用的{x:Bind}绑定的数据都必须以相同名字的getter和setter出现在这个xaml对应的idl文件中
        绑定一个XAML数据到另一个XAML
            XAML：
                <TextBox x:Name="myTextBox"/>
                <TextBlock Text="{x:Bind myTextBox.Text, Mode=OneWay}" />
            idl中
                runtimeclass MainPage : Windows.UI.Xaml.Controls.Page
                {
                    MainPage();
                    Windows.UI.Xaml.Controls.TextBox myTextBox{get;};
                }
        数据绑定的模式
            一次性绑定，数据不会再更新
            单向绑定OneWay，UI会随着数据源的改变而更新
            双向绑定TwoWay，UI会随着数据源的改变而更新，同时UI的更新（例如用户在输入框输入文字）也会更新数据源

    绑定一个XAML数据集合
            例如itemsSource

    IInspectable类型
        每个WinRT的类都继承于IInspectable，类似于Com中的IUnknown和C#中的System.Object

    box_value()函数
        用来将一个基本类型或除了数组的数组以外的数组类型转化为一个引用，来传递给具有引用语义参数的函数
        template<typename T, typename = std::enable_if_t<!std::is_convertible_v<T, winrt::hstring>>>
        winrt::Windows::Foundation::IInspectable box_value(winrt::hstring const& value);    //除了hstring以外的通用版本

        winrt::Windows::Foundation::IInspectable box_value(winrt::hstring const& value);    //hstring的重载
    unbox_value()函数
        将一个IInspectable引用转化回一个基本类型或数组类型
        template<typename T>
        T unbox_value(winrt::Windows::Foundation::IInspectable const& value);

        template<typename T>
        winrt::hstring unbox_value_or(winrt::Windows::Foundation::IInspectable const& value, winrt::hstring const& default_value);

        template<typename T>
        T unbox_value_or(winrt::Windows::Foundation::IInspectable const& value, T const& default_value)
    事件处理
        事件管理机制可以使用任何C++的函数类型
        在Xaml中与物件连接的事件处理函数在code behind中必须是public函数，C#中没有这个限制，可以是private
        通常不把事件处理函数写在.idl里，而是直接生成在.h和.cpp文件中
        通常在一个物件上右键->属性->事件处理器会列出所有该物件的事件，然后双击要添加的事件处理函数，VS会自动生成一个处理函数
        也可以手动注册一个事件处理函数，例如在MainPage的构造函数中
            带this指针的成员函数
                MainPage::MainPage()
                {
                    InitializeComponent();
                    myButton().Click({ this, &MainPage::ClickHandler });
                }
            不带this指针的静态成员函数
                MainPage::MainPage()
                {
                    InitializeComponent();

                    myButton().Click( MainPage::ClickHandler );
                }
            lambda
                MainPage::MainPage()
                {
                    InitializeComponent();

                    myButton().Click([this](IInspectable const& /* sender */, RoutedEventArgs const& /* args */)
                    {
                        myButton().Content(box_value(L"Clicked"));
                    });
                }
        注销事件处理函数
            使用winrt::event_token
                注册事件处理函数时会返回一个winrt::event_token，使用将这个token作为参数调用同一个注册函数将注销这个事件处理函数
                    struct MainPage
                    {
                    private:
                        winrt::event_token token;
                    public:
                        MainPage()
                        {
                            token = myButton().Click(...);
                        }
                        ~MainPage()
                        {
                            myButton().Click(token);    //取消事件处理函数
                        }
                    };
            自动注销
                在注册事件时添加一个winrt::auto_revoke参数，将返回一个winrt::event_revoker<T>对象
                这个对象在超出作用域析构时自动注销事件处理函数，所以无需手动注销
                    struct MainPage
                    {
                    private:
                        winrt::Windows::UI::Xaml::Controls::Button::Cick_revoker event_revoker;
                    public:
                        MainPage()
                        {
                            event_revoker = myButton().Click(winrt::auto_revoke, ...);
                        }
                    };
                有时使用auto_revoke会抛出winrt::hresult_no_interface异常，表明该事件源不支持弱引用
                此时需要手动注销
    异步
        执行时间可能超过50毫秒的Windows Runtime API都被写成异步函数，函数名以Async结尾
        在Windows::Foundation名称空间中定义了以下4中异步操作对象
            IAsyncAction
            IAsyncActionWithProgress<TProgress>
            IAsyncOperation<TResult>
            IAsyncOperationWithProgress<TResult, TProgress>
        当携程不需要返回值时，携程返回类型为前两种
        当需要在携程中返回一个Windows Runtime类时，返回类型为后两种
        当需要在携程中返回一个非Windows Runtime类时，返回类型可以std::future或concurrency::task （在parallel patterns library <ppltasks.h>中）
    容器
        template <typename T, typename Allocator = std::allocator<T>>
        winrt::Windows::Foundation::Collections::IObservableVector<T> single_threaded_observable_vector(std::vector<T, Allocator>&& values = {})
    IDL
        IDL用来定义Windows Runtime 类，用来生成对应的C++/WinRT的类的头文件
        IDL源文件以.idl结尾，使用midl.exe生成一个Windows Runtime metadata文件，以.winmd结尾
        类型
            值类型
                整数类型
                    Boolean
                    Int16
                    Int32
                    Int64
                    UInt8
                    UInt16
                    UInt32
                    UInt64
                    Char: UTF-16 code unit
                    String
                浮点数类型
                    Single
                    Double
                128位Guid
                枚举类型 enum
                    普通枚举
                        内部数据类型是Int32
                    标志枚举
                        在普通枚举的基础上加[flags]修饰
                        内部数据类型是Uint32
                            [flags]
                            enum SetOfBooleanValues
                            {
                                None   = 0x00000000,
                                Value1 = 0x00000001,
                                Value2 = 0x00000002,
                                Value3 = 0x00000004,
                            };
                结构体类型 struct
                可空类型 转化为Windows.Foundation.IReference<T>
            引用类型
                类
                    Object 所有类类型的基类
                    runtimeclass
                        构造函数
                            构造函数可以重载
                            如果没有声明构造函数，则不能产生一个实例，没有默认构造函数，需要使用工厂函数

                        属性
                            与C#属性不同，idl的属性仅代表访问方式，不代表实际的存储
                            <Type> <Name>{get; set};
                        方法
                            ovrrride
                            protected
                            重载
                                idl的方法重载需要方法接收不同数量的参数
                                只是不同类型的参数不能重载
                        事件
                        可见性
                            由于IDL是用来定义接口的，所以runtimeclass中的成员都是public的
                        static
                            可以使用static关键字修饰不支持实例化的静态类
                            此时所有的成员也都必须被修饰为static
                                static runtimeclass Singleton
                                {
                                    ...
                                }
                        继承
                        事件
                            在类中定义一个事件使得这个类成为事件的源，事件源通知提供了事件处理函数的类
                            定义一个事件，需要定义事件委托（即事件处理函数）的类型，例如一个窗口大小改变的事件
                                event Windows.UI.Xaml.WindowSizeChangedEventHandler SizeChanged;
                            定义一个事件会隐式的添加两个方法，一个添加事件处理函数的的add()方法，一个取消事件处理函数的remove()方法
                            通常，一个事件处理函数包含两个参数，事件源+事件参数
                接口 interface
                    接口声明了一些方法，继承它的类需要实现
                    接口也可以继承，使用requires关键字
                        interface IControl
                        {
                            void Paint();
                        }

                        interface ITextBox requires IControl
                        {
                            void SetText(String text);
                        }

                        interface IListBox requires IControl
                        {
                            void SetItems(String[] items);
                        }

                        interface IComboBox requires ITextBox, IListBox
                        {
                            ...
                        }
                委托
                    delegate <ReturnType> <MethodName>(<ParameterList>)
            一维数组类型 T[]
        函数
            参数
                值类型
                    值类型默认是输入参数
                    可以通过使用out关键字转化为输出参数
                    使用struct作为参数时由于是值类型，所以发生拷贝
                    可以使用ref const关键字转化为传递一个常量指针
                        Boolean IsIdentity(ref const Windows.Foundation.Numerics.Matrix4x4 value)
                数组类型
                    // Pass array pattern: read-only array from caller to callee
                    void PassArray(Int32[] values);

                    // Fill array pattern: caller allocates array for callee to fill
                    void FillArray(ref Int32[] values);

                    // Receive array pattern: callee allocates and fill an array returned to caller
                    void ReceiveArray(out Int32[] values);
        属性
            一个属性通常来定义元信息
            属性类似于struct，没有构造函数，按成员顺序赋值
            可以在定义Attribute时使用attributeusage(...)的圆括号中加上目标对象的种类，多个种类之间用逗号分隔
                target_all
                target_delegate
                target_enum
                target_event
                target_field
                target_interface
                target_method
                target_parameter
                target_property
                target_runtimeclass
                target_struct
            如果一个属性类型名以Attribute结尾，则可以省略Attribute，例如下面的HelpAttribute属性在使用时可以只用Help
                [attributeusage(target_runtimeclass, target_event, target_method, target_property)]
                attribute HelpAttribute
                {
                    String classUri;
                    String topic;
                }

                [Help("https://docs.", "topic")]
                runtimeclass BookSku
                {

                }
        泛型
            嵌套的泛型右尖括号之间需要加空格
                Windows.Foundation.IasyncOperation<Windows.Foundation.Collections.IVector<String>> GetCollection(); //error
                Windows.Foundation.IasyncOperation<Windows.Foundation.Collections.IVector<String> > GetCollection();//OK
            不能将数组类型作为泛型类型
                Windows.Foundation.IAsyncOperation<Int32[]> GetArray(); //error
            解决方法
                返回一个IInspectable类型，数组内容使用Windows::Foundation::PropertyValue或者box_value包起来
                在使用时再转化为winrt::Windows::Fountation::IPropertyValue类型，创建一个winrt::com_array<T>的变量，调用.GetInt32Array()赋值给winrt::com_array<T>变量
                    Windows::Foundation::IAsyncOperation<Windows::Foundation::IInspectable> RetrieveCollectionAsync()
                    {
                        co_return Windows::Foundation::PropertyValue::CreateInt32Array({ 99, 101 }); // Box an array into a PropertyValue.
                    }
                
                    /*使用*/
                    auto boxed_array = co_await RetrieveCollectionAsync();
                    auto property_value = boxed_array.as<winrt::Windows::Foundation::IPropertyValue>();
                    winrt::com_array<int32> array;
                    property_value.GetInt32Array(array);
    注意事项：
        winrt::event<T>的类型必须是Windows Runtime类型
        
UWP
    UWP项目类型
        blank app, unit test app 
            创建一个带空白页的uwp，使用XAML UI框架，空白页继承自Windows.UI.Xaml.Controls.Page和单元测试项目
        core app 
            创建一个不使用XAML定义UI的工程
        class library 
            创建一个dll，可以由其他托管语言（例如C#）调用
        Windows Runtime component  
            是一个自足的软件模块，可以由任何windows runtime语言使用（C# C++/WinRT VB C++/CX）
            使用C++/WinRT创建一个Windows Runtime Component
                1. 创建一个新项目，在idl文件中定义好类的接口
                2. 构建这个项目，会生成对应的.h和.cpp文件，添加实现代码
                3. 在要使用这个Component的工程中添加一个要使用的Component的.winmd文件引用
                4. 所要包含的头文件生成在<winrt/...>下
        Optional code package 创建一个可执行的C#代码包
    图标
        SymbolIcon
            <SymbolIcon Symbol="SymbolName"/> 资源列表https://docs.microsoft.com/en-us/windows/apps/design/style/segoe-ui-symbol-font
        FontIcon
            <FontIcon FontFamily="Segoe MDL2 Assets" Glyph="<&#xE(开头的代码)>"/> https://docs.microsoft.com/en-us/windows/apps/design/style/segoe-ui-symbol-font
            
    合并资源
        在一个资源文件中
            <!-- Dictionary1.xaml -->
            <ResourceDictionary
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                xmlns:local="using:MSDNSample">

                <SolidColorBrush x:Key="brush" Color="Red"/>

            </ResourceDictionary>
        要在另一个xaml中使用这个资源，可以合并到当前xaml的资源
            <Page
                x:Class="MSDNSample.MainPage"
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
                <Page.Resources>
                    <ResourceDictionary>
                        <ResourceDictionary.MergedDictionaries>
                            <ResourceDictionary Source="Dictionary1.xaml"/>
                        </ResourceDictionary.MergedDictionaries>

                        <x:String x:Key="greeting">Hello world</x:String>

                    </ResourceDictionary>
                </Page.Resources>

                <TextBlock Foreground="{StaticResource brush}" Text="{StaticResource greeting}" VerticalAlignment="Center"/>
            </Page>
    自定义标题栏
        定制标题栏颜色
            // using Windows.UI.ViewManagement;

            var titleBar = ApplicationView.GetForCurrentView().TitleBar;

            // Set active window colors
            titleBar.ForegroundColor = Windows.UI.Colors.White;
            titleBar.BackgroundColor = Windows.UI.Colors.Green;
            titleBar.ButtonForegroundColor = Windows.UI.Colors.White;
            titleBar.ButtonBackgroundColor = Windows.UI.Colors.SeaGreen;
            titleBar.ButtonHoverForegroundColor = Windows.UI.Colors.White;
            titleBar.ButtonHoverBackgroundColor = Windows.UI.Colors.DarkSeaGreen;
            titleBar.ButtonPressedForegroundColor = Windows.UI.Colors.Gray;
            titleBar.ButtonPressedBackgroundColor = Windows.UI.Colors.LightGreen;

            // Set inactive window colors
            titleBar.InactiveForegroundColor = Windows.UI.Colors.Gray;
            titleBar.InactiveBackgroundColor = Windows.UI.Colors.SeaGreen;
            titleBar.ButtonInactiveForegroundColor = Windows.UI.Colors.Gray;
            titleBar.ButtonInactiveBackgroundColor = Windows.UI.Colors.SeaGreen;
            注意当给一个颜色属性设置为null时，将使用默认系统颜色
            颜色的透明度分量将被忽略

        完全隐藏标题栏
            需要先创建一个空的Grid，并将其作为titleBar，然后才能在原来标题栏的区域上防止元素，防止原来的标题栏区域被windows作为标题栏使用，从而无法接收信息
                <Grid x:Name="AppTitleBar" Background="Transparent">
                    <!-- Width of the padding columns is set in LayoutMetricsChanged handler. -->
                    <!-- Using padding columns instead of Margin ensures that the background
                    paints the area under the caption control buttons (for transparent buttons). -->
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition x:Name="LeftPaddingColumn" Width="0"/>
                        <ColumnDefinition/>
                        <ColumnDefinition x:Name="RightPaddingColumn" Width="0"/>
                    </Grid.ColumnDefinitions>
                </Grid>

                void OnLaunched()
                {
                    // using Windows.ApplicationModel.Core;
                    // Hide default title bar.
                    var coreTitleBar = CoreApplication.GetCurrentView().TitleBar;
                    coreTitleBar.ExtendViewIntoTitleBar = true;
                    Window.Current.SetTitleBar(AppTitleBar);
                }
    设计一个返回按键
        最低要求是要实现一个返回按钮的响应事件
            // MainPage.xaml.cs
            private void BackButton_Click(object sender, RoutedEventArgs e)
            {
                App.TryGoBack();
            }

            // App.xaml.cs
            //
            // Add this method to the App class.
            public static bool TryGoBack()
            {
                Frame rootFrame = Window.Current.Content as Frame;
                if (rootFrame.CanGoBack)
                {
                    rootFrame.GoBack();
                    return true;
                }
                return false;
            }
        有时，还需要支持返回的键盘快捷键Alt+←
            // App.xaml.cs
            // Add event handler in OnLaunced.
            protected override void OnLaunched(LaunchActivatedEventArgs e)
            {
                // ...
                // Do not repeat app initialization when the Window already has content,
                // just ensure that the window is active
                if (rootFrame == null)
                {
                    // ...
                    // rootFrame.NavigationFailed += OnNavigationFailed;

                    // Add support for accelerator keys. 
                    // Listen to the window directly so the app responds
                    // to accelerator keys regardless of which element has focus.
                    Window.Current.CoreWindow.Dispatcher.AcceleratorKeyActivated +=
                        CoreDispatcher_AcceleratorKeyActivated;

                    // ...

                }
            }

            // ...

            // Add this code after the TryGoBack method added previously.
            // Perform forward navigation if possible.
            private bool TryGoForward()
            {
                Frame rootFrame = Window.Current.Content as Frame;
                if (rootFrame.CanGoForward)
                {
                    rootFrame.GoForward();
                    return true;
                }
                return false;
            }

            // Invoked on every keystroke, including system keys such as Alt key combinations.
            // Used to detect keyboard navigation between pages even when the page itself
            // doesn't have focus.
            private void CoreDispatcher_AcceleratorKeyActivated(CoreDispatcher sender, AcceleratorKeyEventArgs e)
            {
                // When Alt+Left are pressed navigate back.
                // When Alt+Right are pressed navigate forward.
                if (e.EventType == CoreAcceleratorKeyEventType.SystemKeyDown
                    && (e.VirtualKey == VirtualKey.Left || e.VirtualKey == VirtualKey.Right)
                    && e.KeyStatus.IsMenuKeyDown == true
                    && !e.Handled)
                {
                    if (e.VirtualKey == VirtualKey.Left)
                    {
                        e.Handled = TryGoBack();
                    }
                    else if (e.VirtualKey == VirtualKey.Right)
                    {
                        e.Handled = TryGoForward();
                    }
                }
            }
        有时，还需要支持平板模式下系统任务栏自带的返回按键，这个按键处理需要在SystemNavigationManager.GetForCurrentView().BackRequested添加一个处理函数
            // App.xaml.cs
            // Add event handler in OnLaunced.
            protected override void OnLaunched(LaunchActivatedEventArgs e)
            {
                // ...
                // Do not repeat app initialization when the Window already has content,
                // just ensure that the window is active
                if (rootFrame == null)
                {
                    // ...
                    // Add support for accelerator keys. 
                    // ... (Previously added code.)

                    // Add support for system back requests. 
                    SystemNavigationManager.GetForCurrentView().BackRequested 
                        += System_BackRequested;

                    // ...

                }
            }

            // ...
            // Handle system back requests.
            private void System_BackRequested(object sender, BackRequestedEventArgs e)
            {
                if (!e.Handled)
                {
                    e.Handled = TryGoBack();
                }
            }
        有的鼠标还带有返回和向前按键，需要在CoreWindow.PointerPressed添加处理函数
            // App.xaml.cs
            // Add event handler in OnLaunced.
            protected override void OnLaunched(LaunchActivatedEventArgs e)
            {
                // ...
                // Do not repeat app initialization when the Window already has content,
                // just ensure that the window is active
                if (rootFrame == null)
                {
                    // ...
                    // Add support for system back requests. 
                    // ... (Previously added code.)

                    // Add support for mouse navigation buttons. 
                    Window.Current.CoreWindow.PointerPressed += CoreWindow_PointerPressed;

                    // ...

                }
            }

            // ...

            // Handle mouse back button.
            private void CoreWindow_PointerPressed(CoreWindow sender, PointerEventArgs e)
            {
                // For this event, e.Handled arrives as 'true'.
                if (e.CurrentPoint.Properties.IsXButton1Pressed)
                {
                    e.Handled = !TryGoBack();
                }
                else if (e.CurrentPoint.Properties.IsXButton2Pressed)
                {
                    e.Handled = !TryGoForward();
                }
            }
        综上所有，要兼容所有的返回操作所需的代码如下
            // App.xaml.cs
            //
            // (Add event handlers in OnLaunched override.)
            protected override void OnLaunched(LaunchActivatedEventArgs e)
            {
                // ...
                // Do not repeat app initialization when the Window already has content,
                // just ensure that the window is active
                if (rootFrame == null)
                {
                    // ...
                    // rootFrame.NavigationFailed += OnNavigationFailed;

                    // Add support for accelerator keys. 
                    // Listen to the window directly so the app responds
                    // to accelerator keys regardless of which element has focus.
                    Window.Current.CoreWindow.Dispatcher.AcceleratorKeyActivated +=
                        CoreDispatcher_AcceleratorKeyActivated;

                    // Add support for system back requests. 
                    SystemNavigationManager.GetForCurrentView().BackRequested 
                        += System_BackRequested;

                    // Add support for mouse navigation buttons. 
                    Window.Current.CoreWindow.PointerPressed += CoreWindow_PointerPressed;

                    // ...

                }
            }

            // ...

            // (Add these methods to the App class.)
            public static bool TryGoBack()
            {
                Frame rootFrame = Window.Current.Content as Frame;
                if (rootFrame.CanGoBack)
                {
                    rootFrame.GoBack();
                    return true;
                }
                return false;
            }

            // Perform forward navigation if possible.
            private bool TryGoForward()
            {
                Frame rootFrame = Window.Current.Content as Frame;
                if (rootFrame.CanGoForward)
                {
                    rootFrame.GoForward();
                    return true;
                }
                return false;
            }

            // Invoked on every keystroke, including system keys such as Alt key combinations.
            // Used to detect keyboard navigation between pages even when the page itself
            // doesn't have focus.
            private void CoreDispatcher_AcceleratorKeyActivated(CoreDispatcher sender, AcceleratorKeyEventArgs e)
            {
                // When Alt+Left are pressed navigate back.
                // When Alt+Right are pressed navigate forward.
                if (e.EventType == CoreAcceleratorKeyEventType.SystemKeyDown
                    && (e.VirtualKey == VirtualKey.Left || e.VirtualKey == VirtualKey.Right)
                    && e.KeyStatus.IsMenuKeyDown == true
                    && !e.Handled)
                {
                    if (e.VirtualKey == VirtualKey.Left)
                    {
                        e.Handled = TryGoBack();
                    }
                    else if (e.VirtualKey == VirtualKey.Right)
                    {
                        e.Handled = TryGoForward();
                    }
                }
            }

            // Handle system back requests.
            private void System_BackRequested(object sender, BackRequestedEventArgs e)
            {
                if (!e.Handled)
                {
                    e.Handled = TryGoBack();
                }
            }

            // Handle mouse back button.
            private void CoreWindow_PointerPressed(CoreWindow sender, PointerEventArgs e)
            {
                // For this event, e.Handled arrives as 'true'.
                if (e.CurrentPoint.Properties.IsXButton1Pressed)
                {
                    e.Handled = !TryGoBack();
                }
                else if (e.CurrentPoint.Properties.IsXButton2Pressed)
                {
                    e.Handled = !TryGoForward();
                }
            }
    后台播放
        https://docs.microsoft.com/en-us/windows/uwp/audio-video-camera/background-audio
    后台内存控制
        https://docs.microsoft.com/en-us/windows/uwp/launch-resume/reduce-memory-usage
        public App()
        {
            this.InitializeComponent();
            this.Suspending += OnSuspending;

            this.EnteredBackground += App_EnteredBackground;
            this.LeavingBackground += App_LeavingBackground;
            
            Windows.System.MemoryManager.AppMemoryUsageLimitChanging += MemoryManager_AppMemoryUsageLimitChanging;
            Windows.System.MemoryManager.AppMemoryUsageIncreased += MemoryManager_AppMemoryUsageIncreased;
        }

        private _isInBackgroundMode = false;

        private void App_EnteredBackground(object sender, EnteredBackgroundEventArgs e)
        {
            _isInBackgroundMode = true;
        }

        private void App_LeavingBackground(object sender, LeavingBackgroundEventArgs e)
        {
            _isInBackgroundMode = false;
        }

        /// <summary>
        /// Raised when the memory limit for the app is changing, such as when the app
        /// enters the background.
        /// </summary>
        /// <remarks>
        /// If the app is using more than the new limit, it must reduce memory within 2 seconds
        /// on some platforms in order to avoid being suspended or terminated.
        ///
        /// While some platforms will allow the application
        /// to continue running over the limit, reducing usage in the time
        /// allotted will enable the best experience across the broadest range of devices.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MemoryManager_AppMemoryUsageLimitChanging(object sender, AppMemoryUsageLimitChangingEventArgs e)
        {
            // If app memory usage is over the limit, reduce usage within 2 seconds
            // so that the system does not suspend the app
            if (MemoryManager.AppMemoryUsage >= e.NewLimit)
            {
                ReduceMemoryUsage(e.NewLimit);
            }
        }

        /// <summary>
        /// Handle system notifications that the app has increased its
        /// memory usage level compared to its current target.
        /// </summary>
        /// <remarks>
        /// The app may have increased its usage or the app may have moved
        /// to the background and the system lowered the target for the app
        /// In either case, if the application wants to maintain its priority
        /// to avoid being suspended before other apps, it may need to reduce
        /// its memory usage.
        ///
        /// This is not a replacement for handling AppMemoryUsageLimitChanging
        /// which is critical to ensure the app immediately gets below the new
        /// limit. However, once the app is allowed to continue running and
        /// policy is applied, some apps may wish to continue monitoring
        /// usage to ensure they remain below the limit.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MemoryManager_AppMemoryUsageIncreased(object sender, object e)
        {
            // Obtain the current usage level
            var level = MemoryManager.AppMemoryUsageLevel;

            // Check the usage level to determine whether reducing memory is necessary.
            // Memory usage may have been fine when initially entering the background but
            // the app may have increased its memory usage since then and will need to trim back.
            if (level == AppMemoryUsageLevel.OverLimit || level == AppMemoryUsageLevel.High)
            {
                ReduceMemoryUsage(MemoryManager.AppMemoryUsageLimit);
            }
        }

        /// <summary>
        /// Reduces application memory usage.
        /// </summary>
        /// <remarks>
        /// When the app enters the background, receives a memory limit changing
        /// event, or receives a memory usage increased event, it can
        /// can optionally unload cached data or even its view content in
        /// order to reduce memory usage and the chance of being suspended.
        ///
        /// This must be called from multiple event handlers because an application may already
        /// be in a high memory usage state when entering the background, or it
        /// may be in a low memory usage state with no need to unload resources yet
        /// and only enter a higher state later.
        /// </remarks>
        public void ReduceMemoryUsage(ulong limit)
        {
            // If the app has caches or other memory it can free, it should do so now.
            // << App can release memory here >>

            // Additionally, if the application is currently
            // in background mode and still has a view with content
            // then the view can be released to save memory and
            // can be recreated again later when leaving the background.
            if (isInBackgroundMode && Window.Current.Content != null)
            {
                // Some apps may wish to use this helper to explicitly disconnect
                // child references.
                // VisualTreeHelper.DisconnectChildrenRecursive(Window.Current.Content);

                // Clear the view content. Note that views should rely on
                // events like Page.Unloaded to further release resources.
                // Release event handlers in views since references can
                // prevent objects from being collected.
                Window.Current.Content = null;
            }

            // Run the GC to collect released resources.
            GC.Collect();
        }

        private void MainPage_Unloaded(object sender, RoutedEventArgs e)
        {
            // << free large data sructures and set them to null, here >>

            // Disconnect event handlers for this page so that the garbage
            // collector can free memory associated with the page
            Window.Current.Activated -= Current_Activated;
            GC.Collect();
        }
    UWP非活动窗口透明效果
        DependencyProperty
            DependencyProperty提供了一个全局的访问依赖属性和提供属性事件响应的方法
            一个依赖属性在XAML中通常用来实现：
                数据绑定
                样式
                动画
            一个类要支持Dependency property，需要在其继承链上继承有DependencyObject类
            一个需要使用依赖属性的类，通常使用DependencyProperty.Register()方法返回的一个DependencyProperty作为其静态成员变量，然后提供一个wrapper成员属性来方便访问和赋值
            DependencyObject
                定义了访问依赖属性的方法
            class PropertyMetadata
            {
                public PropertyMetadata(object defaultValue)
                public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback)
                    其中回调函数需要形如
                        public delegate void PropertyChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e)

                    public object DefaultValue{ get; }
                public CreateDefaultValueCallback CreateDefaultValueCallback{ get; }
                    其中CreateDefaultValueCallback是一个函数类型，应当是一个返回默认PropertyValue的工厂函数，形如
                        public delegate object CreateDefaultValueCallback()
                
                public static PropertyMetadata Create(CreateDefaultValueCallback createDefaultValueCallback) 使用一个返回默认PropertyValue的工厂函数构造
                public static PropertyMetadata Create(object defaultValue, PropertyChangedCallback propertyChangedCallback)
                public static PropertyMetadata Create(CreateDefaultValueCallback createDefaultValueCallback, PropertyChangedCallback propertyChangedCallback) 
            }

            class DependencyObject
            {
                
            }

            class DependencyProperty
            {
                public static DependencyProperty Register(
                    string name,                    依赖的属性名
                    System.Type propertyType,       属性的类型，通常传入typeof(property)
                    System.Type ownerType,          所有者的类型，通常传入typeof(OwnerClass)
                    PropertyMetadata typeMetadata   当传入null时，等同于传入PropertyMetadata.Create(null)
                )

                public PropertyMetadata GetMetadata(System.Type forType)
                    forType所要提取的metadata的信息的类型，传入typeof()

                public static DependencyProperty RegisterAttached(
                    string name,                依赖的属性名
                    System.Type propertyType,         
                    System.Type ownerType,              
                    PropertyMetadata defaultMetadata    
                )
            }

        class Compositor
        {
            public CompositionEffectFactory CreateEffectFactory(IGraphicsEffect graphicsEffect)
                创建一个效果工厂CompositionEffectFactory，这个效果工厂可以创建graphicsEffect所描述的效果的实例
                https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositor.createeffectfactory?view=winrt-22000#Windows_UI_Composition_Compositor_CreateEffectFactory_Windows_Graphics_Effects_IGraphicsEffect_
                https://microsoft.github.io/Win2D/WinUI2/html/T_Microsoft_Graphics_Canvas_Effects_ArithmeticCompositeEffect.htm
                支持的效果类型：
                    ArithmeticCompositionEffect
                    CompositeEffect
                    BlendEffect (21 of 26 modes)
                    ColorSourceEffect
                    SaturationEffect
                    Transform2DEffect
            public CompositionEffectFactory CreateEffectFactory(IGraphicsEffect graphicsEffect, IEnumerable<string> animatableProperties)

        }

        class CompositionEffectFactory
        {
            public CompositionEffectBrush CreateBrush()
                用创建效果工厂时指定的效果和动画属性创建画刷
        }

        class CompositionEffectSourceParameter
        {
            public CompositionEffectSourceParameter(string name) 
                这个合成效果的名字
            public string Name { get; }
        }

        class ArithmeticCompositeEffect
        {
            /*
                将两个图片合并成1个的效果
                需要初始化的参数是
                {
                    Name
                    Source1
                    Source1Amount
                    Source2
                    Source2Amount
                    MultiplyAmount
                    Offset
                }
                This effect combines two images using a weighted sum:

                result = (Source1 * Source1Amount) + (Source2 * Source2Amount) + (Source1 * Source2 * MultiplyAmount) + Offset

                Different settings of these coefficients can blend the images in many different ways, for instance:

                To add two images:
                Source1Amount = 1
                Source2Amount = 1
                MultiplyAmount = 0
                Offset = 0

                To multiply two images:
                Source1Amount = 0
                Source2Amount = 0
                MultiplyAmount = 1
                Offset = 0

                To subtract Source2 from Source1:
                Source1Amount = 1
                Source2Amount = -1
                MultiplyAmount = 0
                Offset = 0

                To interpolate between Source1 and Source2 by amount 't':
                Source1Amount = 1 - t
                Source2Amount = t
                MultiplyAmount = 0
                Offset = 0

                To invert Source1:
                Source1Amount = -1
                Source2Amount = 0
                MultiplyAmount = 0
                Offset = 1
            */
        }

        /*Specifies the way in which a brush paints areas outside its typical content region.*/
        enum CanvasEdgeBehavior
        {
            Clamp = 0, //Repeat the edge pixels of the brush's content.  
            Wrap = 1, //Tile the brush's content.
            Mirror = 2 //Tile the the brush's content, and flip each alternate tile.
        }

        class BorderEffect
        {
            /*
                定义了延申图片的效果，例如重复边缘像素或者包裹对边的像素
                需要定义的参数
                {
                    ExtendX
                    ExtendY
                    Source
                }
            */
        }

        enum BlendEffectMode //https://microsoft.github.io/Win2D/WinUI2/html/T_Microsoft_Graphics_Canvas_Effects_BlendEffectMode.htm
        {
            //
            // Summary:
            //     Multiply blend mode.
            Multiply = 0,
            //
            // Summary:
            //     Screen blend mode.
            Screen = 1,
            //
            // Summary:
            //     Darken blend mode.
            Darken = 2,
            //
            // Summary:
            //     Lighten blend mode.
            Lighten = 3,
            //
            // Summary:
            //     [NoComposition] Dissolve blend mode.
            Dissolve = 4,
            //
            // Summary:
            //     Color burn blend mode.
            ColorBurn = 5,
            //
            // Summary:
            //     Linear burn blend mode.
            LinearBurn = 6,
            //
            // Summary:
            //     Darker color blend mode.
            DarkerColor = 7,
            //
            // Summary:
            //     Lighter color blend mode.
            LighterColor = 8,
            //
            // Summary:
            //     Color dodge blend mode.
            ColorDodge = 9,
            //
            // Summary:
            //     Linear dodge blend mode.
            LinearDodge = 10,
            //
            // Summary:
            //     Overlay blend mode.
            Overlay = 11,
            //
            // Summary:
            //     Soft light blend mode.
            SoftLight = 12,
            //
            // Summary:
            //     Hard light blend mode.
            HardLight = 13,
            //
            // Summary:
            //     Vivid light blend mode.
            VividLight = 14,
            //
            // Summary:
            //     Linear light blend mode.
            LinearLight = 15,
            //
            // Summary:
            //     Pin light blend mode.
            PinLight = 16,
            //
            // Summary:
            //     Hard mix blend mode.
            HardMix = 17,
            //
            // Summary:
            //     Difference blend mode.
            Difference = 18,
            //
            // Summary:
            //     Exclusion blend mode.
            Exclusion = 19,
            //
            // Summary:
            //     [NoComposition] Hue blend mode.
            Hue = 20,
            //
            // Summary:
            //     [NoComposition] Saturation blend mode.
            Saturation = 21,
            //
            // Summary:
            //     [NoComposition] Color blend mode.
            Color = 22,
            //
            // Summary:
            //     [NoComposition] Luminosity blend mode.
            Luminosity = 23,
            //
            // Summary:
            //     Subtract blend mode.
            Subtract = 24,
            //
            // Summary:
            //     Division blend mode.
            Division = 25
        }

        class BlendEffect
        {
            /*
                定义混合两个图片的效果
                输出的图片大小是两个输入图片大小的交集

                需要初始化的参数
                {
                    Mode
                    Background
                    Foreground
                }
            */
        }

        要使用一个效果
            1.创建一个/一些效果实例
                其中效果的Source字段可以是另一个效果的实例，也可以是一个CompositionEffectSourceParameter
                var luminosityBlendingEffect = new ArithmeticCompositeEffect
                {
                    //...
                }
            2.使用compositor创建一个CompositionEffectFactory
                var factory = Window.Current.Compositor.CreateEffectFactory(luminosityBlendingEffect)
            3.使用这个工厂创建画刷
                var brush = factory.CreateBrush()
            4.使用compositor创建一个CompositionBackdropBrush
                var backdropBrush = Window.Current.Compositor.CreateHostBackdropBrush() //表示从应用的后面获取颜色数据
            5.将这个backdropBrush绑定到画刷中使用了CompositionEffectSourceParameter作为Source字段的效果上
                brush.SetSourceParameter("Backdrop", backdropBrush)
            完整范例https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.media.xamlcompositionbrushbase?view=winrt-22000
    
    判断当前系统主题
        var DefaultTheme = new Windows.UI.ViewManagement.UISettings();
        var uiTheme = DefaultTheme.GetColorValue(Windows.UI.ViewManagement.UIColorType.Background).ToString();
        if(uiTheme == "#FF000000")
        {
            WindowsThemeText.Text = "Dark";
        }
        else if(uiTheme == "#FFFFFFFF")
        {
            WindowsThemeText.Text = "Light";
        }
        /*
        else
        {
            WindowsThemeText.Text = "Some new Updated theme found";
        }
        */
    添加主题变更事件响应函数
        var Listener = new ThemeListener();
        Listener.ThemeChanged += Listener_ThemeChanged;

        private void Listener_ThemeChanged(ThemeListener sender)
        {
            var theme = sender.CurrentTheme;
            switch(theme)
            {
                case ApplicationTheme.Dark:
                case ApplicationTheme.Light:
            }
        }

XAML
    数据绑定
        通常数据存在一个专门的数据类里，然后这个类的UI呈现即ViewModel存放一个数据类的实体作为公有成员，然后在XAML需要引用数据的地方使用数据绑定
        例如一个TextBlock要引用一个数据
            public class Recording //假设这是一个数据类
            {
                public string line;
            }

            public class RecordingViewModel //代表这个数据类的UI呈现
            {
                private Recording defaultRecording = new Recording();

                public Recording DefaultRecording { get { return this.defaultRecording; } }
            }

            public sealed partial class MainPage : Page
            {
                MainPage()
                {
                    this.ViewModel = new RecordingViewModel();
                }
                public RecordingViewModel ViewModel{ get; set; }
            }

            <TextBlock Text = "{x:Bind ViewModel.DefaultRecording.line}"/>
    VisualState
        使用VisualState来控制当一个Control的State为某个值时，更改Control的某些属性
        要更改的属性使用<Setter Target="<PropertyName>" Value="<value>"/>对象
        例如一个自定义的CheckBox有3个State：选中、未选中、半选中，则可以使用下面的VisualState来控制各个状态的一些属性的值
            <VisualStateManager.VisualStateGroups>
                <VisualStateGroup x:Name="CheckStates">

                    <VisualState x:Name="Checked">
                        <VisualState.Setters> 
                            <Setter Target="CheckGlyph.Opacity" Value="1"/>
                        </VisualState.Setters>
                    </VisualState>

                    <VisualState x:Name="Unchecked">
                        <VisualState.Setters> 
                            ...
                        </VisualState.Setters>
                    </VisualState>

                    <VisualState x:Name="Indeterminate">
                        <VisualState.Setters> 
                            ...
                        </VisualState.Setters>
                    </VisualState>

                </VisualStateGroup>
            </VisualStateManager.VisualStateGroups>
    ControlTemplate
        可以通过ControlTemplate的方式自定义Control的一些行为或者创建自定义Control
        一个ControlTemplate有且只能有一个FrameworkElement作为根元素，但是这个根元素（即这个唯一的FrameworkElement）可以包含若干个FrameworkElement来组合出想要的Control
        定义一个ControlTemplate，需要指定一个Name和作用对象的类型<ControlTemplate x:Key="<Name>" TargetType="<TargetType>"/>，定义在Resource中
            <ControlTemplate x:Key="CheckBoxTemplate" TargetType="CheckBox">
                ...
            </ControlTemplate>
        对某个控件使用ControlTemplate时，在Template属性使用这个资源
            <CheckBox Template="{StaticResource CheckBoxTemplate}"/>
    TemplateBinding
        TemplateBinding只能在ControlTemplate中使用
        <object propertyName="{TemplateBinding <sourceProperty>}"/>
        将对象object的propertyName属性的绑定为另一个sourceProperty
        当使用现有的Control来创建实现一个新Control时，常见将同一个对象的同一个属性绑定到自身
        例如当使用一个TextBlock来实现一个新Control时，且希望使用TextBlock来显示新Control的Text属性时，可以写
            <TextBlock Text="{TemplateBinding Text}"/>
    DataTemplate
        一些容器例如ListView和GridView中的项目的显示方式是由ListViewItem和GridViewItem来定义的
        当不进行自定义时，将默认使用项目的.ToString()方法来展示文字内容
        可以定义两方面的内容
            DataTemplate
                将一个DataTemplate作为ListView.ItemTemplate的内容
                如果在DataTemplate中使用了x:Bind，则需要在DataTemplate添加x:DataType属性指定数据源的类名
                    <ListView x:Name="colorsListView">
                        <ListView.ItemTemplate>
                            <DataTemplate x:DataTemplate="local:NamedColor">
                                <Grid>
                                    ...
                                </Grid>
                            </DataTemplate>
                        </ListView.ItemTemplate>
                    </ListView>
                
            ControlTemplate
                将一个Style作为ListView.ItemContainerStyle的内容
                    <ListView x:Name="colorsListView">
                        <ListView.ItemContainerStyle>
                            <Style TargetType="ListViewItem">
                                <Setter ... />
                                ...
                            </Style>
                        </ListView.ItemContainerStyle>
                    </ListView>
                另外，在VS->View->Other Window->Document outline中选中要修改的控件->Property，可以编辑其默认的Style
                在修改Style时，最好是先创建一个副本，在副本的基础上修改
    DataTemplateSelector
        DataTemplate将定义的数据展示方式作用于一个容器内的所有项目
        DataTemplateSelector可以根据项目的属性来选择不同的DataTemplate作用于不同的项目
        要定义一个DataTemplateSelector，需要从它继承出自己的类，并override SelectTemplate()方法，将逻辑写在code-behind中，然后在XAML的资源部分创建一个这样的类的实体
            class TaskListDataTemplateSelector : DataTemplateSelector
            {
                public override DataTemplate SelectTemplate(object item, DependencyObject container)
                {
                    FrameworkElement element = container as FrameworkElement;
                    if(element != null && item != null && item is Task)
                    {
                        Task taskItem = item as Task;
                        if(taskItem.Priority == 1)
                        {
                            return element.FindResource("importantTaskTemplate") as DataTemplate;
                        }
                        else
                        {
                            return element.FindResource("myTaskTemplate") as DataTemplate;
                        }
                    }
                    return null;
                }
            }

            /*xaml*/
            <Window.Resource>
                <local:TaskListDataTemplateSelector x:Key="taskListDataTemplateSelector"/>
            </Window.Resource>

            <!- Use -->
            <ListBox ... ItemTemplateSelector="{StaticResource taskListDataTemplateSelector}"/>


    Storyboard
        Storyboard可以用来随时间改变某个属性的值，最常见的用途是实现动画
        有3种动画
            DoubleAnimation
            PointAnimation
            ColorAnimation
        对一个对象使用storyboard，不直接定义在这个对象中，而是通常将storyboard定义在资源部分，并通过名字来引用要应用效果的对象的名字
            <Page ...>
                <Page.Resources>
                    <!-- Storyboard resource: Animates a rectangle's opacity. -->
                    <Storyboard x:Name="myStoryboard">
                    <DoubleAnimation
                        Storyboard.TargetName="MyAnimatedRectangle"
                        Storyboard.TargetProperty="Opacity"
                        From="1.0" To="0.0" Duration="0:0:1"/>
                    </Storyboard>
                </Page.Resources>

                <!--Page root element, UI definition-->
                <Grid>
                    <Rectangle x:Name="MyAnimatedRectangle"
                    Width="300" Height="200" Fill="Blue"/>
                </Grid>
            </Page>
        有时，需要更改的属性是一个Control的内部对象的属性，例如一个TextBlock的Foreground是一个SolidColorBrush，要更改这个SolidColorBrush的颜色，即SolidColorBrush的Color属性
            <Storyboard x:Name="myStoryboard">
                <ColorAnimation
                    Storyboard.TargetName="tb1"
                    Storyboard.TargetProperty="(TextBlock.Foreground).(SolidColorBrush.Color)"
                    From="Red" To="Green"/>
            </Storyboard>
            每一对圆括号表示一个属性
            圆括号的语法为(<Type Name>.<Property Name>)
            圆括号之间的句号.表示向下一个层级
        属性
            From, To, By
                指定起始值，终点值，起始值的偏移量作为终点值
                通常需要3个值中指定2个
            AutoReverse
                自动返回，即动画会播放2次
            RepeatBehavior
                指定动画播放几次
                可以是Forever，使得永远循环动画
            SpeedRatio
    STA
        Single-threaded aparatments
        ATSA
    假数据
        
WINUI3
    项目类型
        Blank app, packaged 
            创建一个使用C#.NET5 或Win32 C++开发的基于WinUI的应用，会默认新建一个继承于Windows.UI.Xaml.Window基本窗口
            同时会创建一个package manifest和其他用于支持构建的文件，最终会打包成一个MSIX安装包
        Blank app, packaged with WAP
            与上面不同的是会在解决方案里多创建一个打包工程用于打包成MSIX安装包
    

    WINUI3跟随Windows App SDK一起发布，支持Win11->Win10 1809
    前身是Project Reunion
    Windows App SDK包含下面的功能
        WINUI3：支持C# .NET开发和C++ Win32开发，提供了统一的UI设计风格
        DWriteCore：硬件加速的高质量文字渲染
        MRT Core：统一的程序资源管理，例如管理在程序中使用的字符串、图片、数值等
        App instancing：设置是否允许一个应用的多个实例同时运行
        激活管理
        电源管理
        窗口管理
        使用Azure App Registration推送消息
    下载Windows App SDK: https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/set-up-your-development-environment?tabs=stable
    资源
        https://docs.microsoft.com/en-us/windows/uwp/app-resources/
    APP manifest
        https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/appx-package-manifest
    多语言支持
        使用文本编辑器打开Package.appxmanifest
        找到
            <Resource>
                <Resource Language="x-generate"/>
            </Resource>
        删除generate行，并添加所支持的语言代码，例如
            <Resource>
                <Resource Language="en-US"/>
                <Resource Language="es-ES"/>
            </Resource>
