1.高级数据类型
    为了统一成大写，VC++给很多类型取了大写的typedef
    INT->int
    UINT->unsigned int
    CHAR->char
    WCHAR->wchar_t
    
    WinDef.h:
    BYTE 8位无符号
    DWORD 32位无符号
    INT32
    INT64
    LONG 32位有符号
    LONGLONG 64位有符号

    UINT32
    UINT64
    ULONG
    ULONGLONG
    WORD 16位无符号
    windows里P开头表示是指针，LP开头表示长指针（为了便于将给16位计算机设计的代码移植到32位），现在P和LP没有区别，与变量类型*的指针表示也没有区别
    指针的长度是编译时决定的，所以64位系统中运行32位的程序，指针长度仍然是32位

    BOOL {FALSE->0, TRUE->1}

    LRESULT->long (winnt.h:typedef long LONG    windef.h:typedef LONG LRESULT)
    HRESULT->long (winnt.h)初始化COM库的函数的返回值
    LPTSTR 字符串指针
    LPTCSTR 常量字符串指针
2.错误处理
    DWORD FormatMessage(
        DWORD dwFlags,
        LPCVOID pSource,
        DWORD dwMessageID,
        DWORD dwLanguageID,
        PTSTR pszBuffer,
        DWORD nSize,
        va_list* Arguments
    );

    VOID SetLastError(DWORD dwErrCode) 设置Error值
3.字符串
    在<winnt.h>中定义了这些宏

        #ifdef  UNICODE                     // r_winnt

        #ifndef _TCHAR_DEFINED
        typedef WCHAR TCHAR, *PTCHAR;
        typedef WCHAR TBYTE , *PTBYTE ;
        #define _TCHAR_DEFINED
        #endif /* !_TCHAR_DEFINED */

        typedef LPWCH LPTCH, PTCH;
        typedef LPCWCH LPCTCH, PCTCH;
        typedef LPWSTR PTSTR, LPTSTR;
        typedef LPCWSTR PCTSTR, LPCTSTR;
        typedef LPUWSTR PUTSTR, LPUTSTR;
        typedef LPCUWSTR PCUTSTR, LPCUTSTR;
        typedef LPWSTR LP;
        typedef PZZWSTR PZZTSTR;
        typedef PCZZWSTR PCZZTSTR;
        typedef PUZZWSTR PUZZTSTR;
        typedef PCUZZWSTR PCUZZTSTR;
        typedef PZPWSTR PZPTSTR;
        typedef PNZWCH PNZTCH;
        typedef PCNZWCH PCNZTCH;
        typedef PUNZWCH PUNZTCH;
        typedef PCUNZWCH PCUNZTCH;
        #define __TEXT(quote) L##quote      // r_winnt

        #else   /* UNICODE */               // r_winnt

        #ifndef _TCHAR_DEFINED
        typedef char TCHAR, *PTCHAR;
        typedef unsigned char TBYTE , *PTBYTE ;
        #define _TCHAR_DEFINED
        #endif /* !_TCHAR_DEFINED */

        typedef LPCH LPTCH, PTCH;
        typedef LPCCH LPCTCH, PCTCH;
        typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
        typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
        typedef PZZSTR PZZTSTR, PUZZTSTR;
        typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
        typedef PZPSTR PZPTSTR;
        typedef PNZCH PNZTCH, PUNZTCH;
        typedef PCNZCH PCNZTCH, PCUNZTCH;
        #define __TEXT(quote) quote         // r_winnt

        #endif /* UNICODE */                // r_winnt
        #define TEXT(quote) __TEXT(quote)   // r_winnt
    可以使用TEXT()宏，使得当UNICODE被定义时，使用16bit字符和字符串，否则使用8位字符和字符串
        TCHAR c = TEXT('A');
        TCHAR szBuffer[] = TEXT("A string");
    在<string.h>中也定义了类似的宏，使得无论是ANSI字符串函数还是Unicode字符串函数都能通过编译
        #ifdef _UNICODE
            #define _tcslen wcslen
        #else
            #define _tcslen strlen
        #endif
    在<strsafe.h>中定义了字符串函数的安全版本
    安全版本的函数在检查参数失败后会设置errno

    int CompareString(
        LCID locale,
        DWORD dwCmdFlags,
        PCTSTR pString1,
        int cch1
        PCTSTR pString2,
        int cch2)
        按语言习惯的方式进行字符串比较
        locale指定一个区域设置id，用来表示1种语言，通常使用GetThreadLocale()函数获取
        dwCmdFlags指定比较字符串的方法，可能的值为
            NORM_IGNORECASE LINGUISTIC_IGNORECASE 忽略大小写
        cch1和cch2指定字符数（不是字节数），传入负值则自动计算字符串长度
        pString为待比较字符串指针

    int CompareStringOrdinal(
        PCWSTR pString1,
        int cchCount1,
        PCWSTR pString2,
        int cchCount2,
        BOOL bIgnoreCase)
        按码位比较字符串，不考虑区域语言，适用于程序内部比较字符串
        返回
            0 ->函数失败
            CSTR_LESS_THAN 1 -> pString1 < pString2
            CSTR_EQUAL 2 -> pString1 == pString2
            CSTR_GREATER_THAN 3 -> pString2 > pString2
    使用这个宏来分配字符串所需的内存
        #define chmalloc(nCharacters) (TCHAR*)malloc(nCharacters * sizeof(TCHAR))
    UNICODE <=> ANSI
        int MultiByteToWideChar(
            UINT uCodePage,
            DWORD dwFlags,
            PCSTR pMultiByteStr,
            int cbMultiByte,
            PWSTR pWideCharStr,
            int cchWideChar
        )

        BOOL IsTextUnicode(
            CONST PVOID pvBuffer,
            int cb,         字节数
            PINT pResult    通常为NULL
        )
        判断一个字符串是包含ANSI字符还是Unicode字符

4.内核对象
    内核对象可以用一个安全描述符来保护
    用于创建内核对象的所有函数几乎都有一个只想SECURITY_ATTRIBUTES结构体的指针
    大多数创建内核对象的函数失败时返回值为NULL（0），少数的函数失败时返回INVALID_HANDLE_VALUE （-1）
    typedef struct _SECURITY_ATTRIBUTES {
        DWORD nLength;                  传入sizeof(SECURITY_ATTRIBUTES)
        LPVOID lpSecurityDescriptor;    
        BOOL bInheritHandle;        
    } SECURITY_ATTRIBUTES;

    HANDLE CreateFileMapping(
        HANDLE hFile,               
        PSECURITY_ATTRIBUTES psa,   
        DWORD flProtect,            
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        PCTSTR pszName
    )

    HANDLE CreateThread(
        PSECURITY_ATTRIBUTES psa,
        size_t dwStackSize,
        LPTHREAD_START_ROUTINE pfnStartAddress,
        PVOID pvParam,
        DWORD dwCreationFlags,
        PDWORD pdwThreadID
    )

    HANDLE CreateFile(
        PCTSTR pszFileName,
        DWORD dwSesiredAccess,
        DWORD dwShareMode,
        PSECURITY_ATTRIBUTES psa,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttribues,
        HANDLE hTemplateFile
    )

    HANDLE CreateSemaphore(
        PSECURITY_ATTRIBUTES psa,
        LONG lInitialCount,
        LONG lMaximumCount,
        PCTSTR pszName
    )

    无论用什么方式创建内核对象，都应该调用这个函数表明结束使用
    BOOL CloseHandle(Handle hobject)
    内核对象的共享
        对象句柄继承
            当进程之间存在父-子关系时可以使用对象句柄继承
            父进程需要初始化一个SECURITY_ATTRIBUTES结构，并设置其中的成员
                SECURITY_ATTRIBUTES sa{sizeof(sa), NULL, TRUE};
            再将其传给相应的创建内核对象的函数，例如
                HANDLE hMutex = CreateMutex(&sa, FALSE, NULL);
            
