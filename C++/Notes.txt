0.Makefile (man 3 make, man 3 cc)

1.Formatted printing
    printf (man 3 printf)
        %d, %i -> int as a signed decimal number
            int a = 12345;
            printf("This is %%d->%d.\t This is %%i->%i.", a, a);    //两个百分号用于转义成一个%，而不是替换成变量的值
        %ld -> decimal long int
        %u -> decimal unsigned int
        %llu -> unsigned long long
        %f  默认显示6位小数(不管变量是float还是double)
        %e -> scientific notation
        %p -> address of a pointer, hex
    strlen 返回字符串长度，不包括字符串结尾的'\0'
    sizeof计算字符串长度时，会包括字符串结尾的'\0'
    '\0'在运算时等于0，因为它的ASCII值为0
    以%c printf '\0'时啥也不输出
    以%s printf '\0'时输出:(null)
    以puts输出'\0'时 terminated by singal SIGSEGV

2.array
    定义一个数组时只对第一个或前几个元素初始化，那么剩下的元素会被初始化成0
        int number[4]={1}; //输出这4个整数，得到：1 0 0 0
    这与下面的程序结果不同
        int number[4];
        number[0]=1;        //此时再输出这4个整数，得到：1+后面3个数是垃圾内容
    
    骚操作：
        char name[4] = { 'a','b','c','\0' };    //在内存中的顺序，从低->高：a,b,c,'\0' 十六进制 61626300h
        printf("%s\n", name);                   //正常输出：abc
        int name2 = 0x00636261;         //定义一个4字节整数，在内存中的顺序，从低->高 61626300H
        printf("name2 as string ->%s\n", (char*)&name2);    //输出：abc，这里不强制转换char*也没问题
    //注意%s 的参数应该是一个数组的地址

    多维数组：
        1.多维数组总是从最右的下标先变化的原则，然后向左
            如：int a[3][4]; a[1][3]的下一个元素(若有一个int *指针，+1后指向)是a[2][0]  
        2.多维数组与指针
        如：int a[3][10]; 包含3个元素，每个元素是一个包含10个整形元素的数组
            因为一维数组的数组名是指向第一个元素的指针，类似的，二维数组的数组名是指向第一个元素的指针，也就是指向第一个10个整形数的数组的指针
            即：int a[3][10]; 则a是指向一个包含10个整形数的数组的指针
                骚操作：*a是取第一个元素，因为元素是一个包含10个整形数的数组，所以*a的类型是这整个数组，也就是指向这个数组第一个元素的指针
                        再取*a的值，得到**a，即取(指向这个数组第一个元素的)指针的值，得到这个整数
                        所以a的类型是int **
                        a[0]是a[3][10]的第一个元素，这个元素是一个10个整数的数组，所以a[0]也是这整个10整数数组，所以a[0]与*a相同


    main函数的完整版是：
        int main(int argc, char *argv[])    //运行程序时，不带其他任何参数，argc=1，agrv[0]是程序本身的绝对路径
    //argv是一个指针数组，argv[i]是指向第i+1个参数字符数组的首地址
    运行程序时，参数带引号和不带引号，argv中存储的字符串相同
        ./test "ZED" //argv[1]->ZED
        ./test ZED   //agrv[1]->ZED

3.pointer
    sizeof(array)返回array[]的总大小
    sizeof(ptr)返回的永远是单个指针占用的大小

4. assert
    #include <assert.h>
    assert(表达式)
    如果表达式为假，程序终止，并向std error打印出错误行数和错误的表达式

5. string
    #include<string.h>
    char *strdup(const char *s) //return a pointer to a new string which is a duplicate of the string s
    char *strndup(const char *s, size_t n); //similar, but at most copies n bytes
    char *strcpy(char *dest, const char *src);//从源src拷贝字符到dest，直到遇到'\0'，（别用）
    char *strncpy(char *dest, const char *src, size_t n);//至多从src拷贝n字节到dest，如果从src连续拷贝n个字节还没有结束，dest的末尾不会自动加上终止符'\0'
                                                        //如果已经拷贝完成，会自动加上终止符'\0'

atoi()  将nptr所指的字符串的开头部分转化为相应的整数，长整型，双长整形
    #include <stdlib.h>
    int atoi(const char *nptr);
    long atol(const char *nptr);
    long long atoll(const char *char);

6. 文件操作
    #include <stdio.h>
    FILE *fopen(const char *pathname, const char *mode);
        r：只读打开，stream指向文件头
        r+：读写打开，stream指向文件头
        w：只写打开，若文件已存在则清空文件，不存在则创建，stream指向文件头
        w+：读写打开，若文件已存在则清空文件，不存在则创建，stream指向文件头
        a:只写打开，文件不存在则创建，stream指向文件尾
        a+：读写打开，文件不存在则创建，stream在读时从文件头开始，写时总是指向文件尾
    int fclose(FILE *stream);//将未缓存的数据写入stream，然后关闭其文件描述符，成功返回0，否则返回EOF

    size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);   //从文件流stream中读取nemb个size字节大小的内容，存储到ptr，返回读到的个数（nmemb）
    size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);    //从ptr连续读...写到stream
    
    int fclose(FILE *stream);   //先flush缓存的数据到stream，再关闭stream，返回0表示成功，否则返回EOF
    int fgetc(FILE *stream);//从stream中读取下一个字符，返回这个字符的int（ASCII），如读到文件尾或不成功则返回EOF
    int getc(FILE *stream);//同上
    int getchar();//等同于int getc(stdin)
    char *fgets(char *s, int size, FILE *stream);//从stream中至多读取size-1个字符到s所指的缓存中，并添加结尾的'\0'，返回s，不成功返回NULL

    int scanf(const char *format,...)

    char *gets(char *s);//从stdin读取一行到s所指的缓存中，遇到行尾或EOF结束，并把行尾替换成'\0'，成功返回s，否则返回NULL（别用）



7.struct   
    同类型struct之间可一直直接像变量赋值一样拷贝

8.函数指针
    先写一个普通函数：int foo(int a, int b) {}
    把函数名改写成指针的样式：int *foo(int a, int b) {}
    把指针名改掉：int *foo_ptr(int a, int b) {}

9.typedef
    typedef A B;    //用“B”作为“A”的别名
    如：
        typedef struct A {} B;  //以后可以用B foo来代替struct A foo定义变量

10.rand和srand()
    #include <stdlib.h>
    int rand(void); //产生一个从0到RAND_MAX范围的假随机数，win10上RAND_MAX为7fff，即[0,32767]
    void srand(unsigned int seed);  //随机种子函数，seed设置rand()的随机值，如果不在rand前调用srand，程序每次执行时，重复使用rand得到的序列相同
                                    //也就是每次执行，第n次调用rand的值永远是相同的
    一种实现：
        static unsigned long next = 1;

        /* RAND_MAX assumed to be 32767 */
        int myrand(void) {
            next = next * 1103515245 + 12345;
            return((unsigned)(next/65536) % 32768);
        }
        void mysrand(unsigned seed) {
            next = seed;
        }
    从这里可以看出，rand的值在next相同时是相同的，所以要使用srand改变next，通常使用时间做为srand的参数

11.高级数据类型
    #include <stdint.h>
    int8_t, int16_t, int32_t, int64_t
    uint8_t, uint16_t, uint32_t, uint64_t
    以上都可以用INTN_MAX（其中N是位数，8...64）查看能存储的最大值
    size_t//一个能存储指针的无符号整数，32位系统是uint32_t，64位是uint64_t

12.变量作用域
    局部变量的作用域在定义它的一对大括号中，内部大括号中定义的与外部大括号中的同名变量，外部的会被覆盖（就近原则）
    函数内定义的变量
    普通全局变量：在函数外定义的变量，作用域为本文件.c内的所有函数
    extern 全局变量：作用域为所有.c文件，可以在本.c文件内extern其他.c文件内的普通全局变量，使得在其他.c文件内定义的普通全局变量也能在本.c文件中使用
    static 全局变量：作用于为本.c文件，在其他.c文件中加extern也不能访问
    static 局部变量：作用域为定义它的一对大括号中，具有记忆特性，第一次赋值时被初始化，以后保持上一次的值（少用）
    
13.枚举类型enum
    枚举类型的定义：enum 枚举类型名 {枚举值列表};
    枚举类型变量的定义：enum 枚举类型名 变量名=枚举值;
        枚举类型定义和变量定义的简化：enum 枚举类型名 {枚举值列表} 枚举类型变量名;
    枚举值列表的值不赋值时，默认从整数0开始初始化第一个枚举值
    枚举值列表的值只能用整型常量表达式赋值
    一个枚举类型其实就是一个整形int的不同取值的列表

14.可变参数函数（man stdarg）
    #include <stdarg.h>
    如有函数：RETURNTYPE somefunc(last,...)其中last是可变参数列表前最后一个参数
    在可变参数的函数里声明一个va_list类型的变量，如：va_list argp;（argp其实是个指向参数栈的指针）
    然后va_start(argp, last);
    以后每次调用va_arg(argp,SOMETYPE)时返回的就是可变参数列表的下一个变量，类型由SOMETYPE决定
15. 栈区动态内存分配(类似于C中的VLA)
    void* alloca(size_t bytes);
    函数在栈区分配bytes大小的空间并返回一个空类型的指针指向这个空间的首字节，分配的空间在当前作用域结束时被释放
    通常要做类型转换，转换成所需的类型
    可以用这个函数来模拟一个可变大小的栈区动态数组
16. 预编译头
    将常用且不常修改的头文件（尤其是标准头文件）放到预编译头，将极大提高编译速度
    在VS中：
        1. 新建pch.h，把要包含的头文件用#include 放进去
        2. 新建pch.cpp，#include "pch.h"
        3. 选择pch.cpp，打开属性，将预编译头属性改为“创建”
        4. 打开项目属性，将预编译头属性改为“使用”，预编译头文件选择pch.h
    在GCC中：
        1. 新建pch.h，把要包含的头文件用#include 放进去
        2. 编译pch.h: g++ pch.h -> 生成一个pch.gch文件
        3. 正常编译其他文件

C++
1. 字符串输入
    cin.getline(char *s, int n);//读取一行，最多读取n-1个字符拷贝给s所指的字符串，并添加'\0'，丢弃用户输入的换行符
    cin.get(char *s, int n);//读取一行，最多读取n-1个字符拷贝给s所指的字符串，并添加'\0'，不丢弃用户输入的换行符，保留在输入队列中
    cin.getline(char *s, int n, char c);//最多读取n-1个字符拷贝给s所指的字符串，在达到遇到等于c的分隔符或n-1个字符时停止读取，并添加'\0'，丢弃分隔符
    getline(cin, string& s); //读取一行赋值给字符串s
    cin.get(char *s, int n, char c);//最多读取n-1个字符拷贝给s所指的字符串，遇到等于c的分隔符或n-1个字符时停止读取，并添加'\0'，不丢弃分隔符保留在输入队列中
    注意上面两个方法如果参数c不是换行符，则会把换行符当普通字符来读取，所以不止一行
    cin.ignore(int n, char c);  //读取并丢弃最多n个字符，达到n或者读取到等于c的分隔符时停止，返回调用对象cin，所以可以拼接，通常将c设置为换行符，所以可以丢弃一行
    cin.clear();//重置错误输入
    cin >>;//不断读取，直到空白字符
文件I/O
    对比：向控制台输出->向文本文件输出
    头文件：iostream->fstream
    声明了一个cout的ostream对象->手动声明一个ofstream对象
    声明了一个cin的istream对象->手动声明一个ifstream对象
    不同的是可以声明一个既能读取又能写入的fstream对象
        ofstream outFile;   //声明一个ofstream对象用于写入
        outFile.open("path");    //打开文件path
        注意path是C风格字符串，默认情况下，若path文件不存在，则新建，若存在，则清空原内容，重新写入
        也可以利用初始化，将上面两步合并起来
            ofstream outFile("path");
        outFile.close();    //关闭这个文件
        
        ifstream inFile;    //声明一个ifstream对象用于读取
        inFile.open("path");//可能会打开一个不存在的文件产生错误
        也可以利用初始化，将上面两步合并起来
            ifstream inFile("path");
        if(!inFile.is_open())   //用于判断文件有没有正确打开，没有则退出
            exit();
        while(inFile>>value)    //确保首先读取一个字符，再判断有没有错误发生
        {
            //do things 
        }
        inFile.close();
    可以为以一个文件流对象关联不同的文件
    也可以对fstream对象使用flush：outFile<<flush;
    open()：ifstream和ofstream的open函数都接收两个参数，第一个为C风格字符串path，第二个为文件模式
        文件模式：
            ios_base::in 打开文件以读取         <- ifstream open和构造函数的默认值
            ios_base::out 打开文件以写入                <-
            ios_base::ate 打开文件并移到文件尾            | ofstream open和构造函数的默认值
            ios_base::app 追加到文件尾                   |
            ios_base::trunc 如果文件存在，则截短文件     <-
            如果要在打开文件输出时不删除，要追加到文件尾，可以用ofstream fout("file", ios_base::out|ios_base::app);
    ifstream:
        seekg(streamoff, ios_base::seekdir);    //定位到离第二个参数指定的文件位置特定距离的位置，距离单位为字节
            seekdir的取值：ios_base::beg    文件开始处
                        ios_base::cur      文件当前位置
                        ios_base::end      文件尾
        seekg(streampos);   //定位到文件第streampos个字节的位置（从0开始）
        tellg()：返回输入文件指针的当前位置
        read(char *s, size_t count);    //读取count个字节，存储到s所指的内存区域
    ofstream：
        seekp()：同ifstream的seekg
        tellp();    对于fstream对象，由于他的输入与输出指针是同时移动，所以tellg和tellp返回的值相同
        write(char *s, size_t count);   //将s所指的内存区域写入count个字节到ofstream对象管理的文件流
cctype函数
    isalnum(char c);//字母或数字->true
    isalpha(char c);//字母->true
    iscntrl(char c);//控制字符->true
    isdigit(char c);//数字0~9->true
    isgraph(char c);//除空格之外的打印字符->true
    islower(char c);
    isprint(char c);
    ispunct(char c);//标点符号->true
    isspace(char c);//标准空白字符（空格、进纸、换行符、回车、水平制表符、垂直制表符）->true
    isupper(char c);
    isxdigit(char c);//十六进制数字->true
    char tolower(char c);//->c的小写
    char toupper(char c);//->c的大写
输出：
    cout.put('c'); //输出字符c，返回指向调用对象的引用即cout，原型为：ostream & put(char)
    cout.write(const char*s, streamsize n); //显示s指向的字符串的前n个字符、
    换行符会导致刷新缓冲区，大多数C++实现都在输入即将发生时刷新缓冲区
    程序一般会在cout输出时刷新缓冲区，如果没有，可以用flush控制符（刷新缓冲区）和endl控制符（刷新缓冲区+插入一个换行符）
    flush是控制符也是函数，所以可以用flush(cout)来刷新cout缓冲区
    而ostream对<<重载，所以可以cout<<flush;
    setf()：
        fmtflags setf(fmtflags);设置将一直有效直到被修改
            参数：
                ios_base::boolalpha 输出bool值，true或false
                ios_base::showbase  使用基数前缀0或0x
                ios_base::showpoint 显示末尾的小数点
                ios_base::uppercase 对于16进制输出，使用大写字母
                ios_base::showpos   在正数前加+号
        setf(ios_base::left, ios_base::adjustfield) 左对齐
        setf(ios_base::right, ios_base::adjustfield) 右对齐
        setf(ios_base::internal, ios_base::adjustfield) 符号或基数前缀左对齐，值右对齐
    浮点数的显示：
        浮点被显示为最多6位，小数结尾的0不显示，当指数大于等于6或小于等于-5时使用科学计数法表示，使用科学计数法时的真数部分还是最多6位，负号不包括在位数里
        可以使用precision()成员函数改变输出精度
        cout.precision(2);//显示最多2位精度，一直有效，直到再次更改他
        precision()函数返回一个std::streamsize类型保存之前的设置
        使用cout.setf(ios_base::showpoint)将显示末尾的0（根据输出精度），ios_base::showpoint是ios_base类定义的一个常量
        cout.setf(ios_base::fixed,ios_base::floatfield);    //定点表示法
        cout.setf(ios_base::scientific,ios_base::floatfield);    //科学计数法
        以上两个表示方法的小数位数都等于精度的位数，而不是总位数（注意与默认的precision不同，precision设置的是小数和整数部分的总精度）
        所有setf()方法返回一个ios_base::fmtflags类型，是之前的设置
        也可以用cout.unsetf(ios_base::floatfield); 恢复默认显示
    wchar_t 字符和字符串需要用wcout输出，语法与cout相同

    整数显示：
        可以使用dec、hex、oct控制符分别显示十进制、十六进制、八进制整数
        调用：hex(cout); 或 cout<<hex; (重载)
        可以使用width成员函数将长度不同的数字放到宽度相同的字段中
            int width();    //返回字段宽度的当前设置
            int width(int i);   //设置字段宽度为i个空格，并返回之前的字段宽度，只在下一次输出的时候生效，然后恢复为默认值
        C++不会截断数据，如果字段宽度小于实际的数字长度，C++将增加宽度来完整容纳要输出的数字
        C++默认字符显示为右对齐，即从最右边填充空格到最左边直到字符宽度
        cout.setf(ios_base::dec, ios_base::basefield);  //十进制
        cout.setf(ios_base::oct, ios_base::basefield);  //八进制
        cout.setf(ios_base::hex, ios_base::basefield);  //十六进制

    填充字符：默认情况下cout用空格填充字符宽度未使用的部分，可以用fill()成员函数来改变填充字符
        cout.fill('*');//使用*号填充，一直有效，直到再次更改他

输入：
    cin检查输入流，跳过空白（空格、换行符、制表符），然后根据输入对象的实际类型赋值给对象，不符合对象类型的输入数据将被留在输入流中，下一个cin语句从这里开始读取
    与cout一样，在输入回车的时候cin会刷新输入缓冲区并读取输入
    char ch;
    cin.get(ch);    //读取一个字符赋值给ch，应该用while循环测试ch是否为换行符来终止一行的读取
    如果使用cin>>ch;由于cin会跳过换行符，所以对回车换行符的测试永远为假
    cin.get(char &)返回调用他的对象cin，所以可以拼接：cin.get(ch1).get(ch2)，达到文件尾是返回值false，所以可以用判断测试
    cin.get(void)将返回读取到的字符，所以调用为ch=cin.get()，达到文件为时值为EOF，测试时要使用cin.get()!=EOF

        如果是要在界面上做出输入一个字母来分支选择，可以这样设计程序：
        char choice;
        cout<<"一些提示";
        while(cin>>ch)
        {
            while(cin.get()!='\n')
                continue;           //清除输入队列中的回车和其他无效字符
            if(!isalpha(ch))        //如果输入的根本不是字母选项，就跳过大循环中剩下的部分，重新读取
                continue;
            switch(ch)
            ... /*程序处理部分*/

            cout<<"一些提示";
        }
流状态：
    当输入流出现错误，应用cin.clear()来重新打开输入
    eof()：到达文件尾，返回true
    bad()：如果流被破坏，例如文件读取错误，返回true
    fail()：包含bad和输入操作未能读取预期的字符，返回true
    good()：如果流状态良好且可用，返回true

    由于流将重新从错误的地方开始读取（原先的错误输入还保存在输入队列中），所以应该要一直读取字符，直到空白为止
        cin.clear();    //先重新打开输入流
        while(!isspace(cin.get()))
            continue;               //一直读取字符直到空白
        cin>>input;//重新输入赋值
    或者用丢弃这一行的剩余部分的方法：
        while(cin.get()!='\n')
            continue;
    以上两种方式可以排除不恰当的输入引起的流的终止，即fail()会返回true

使用临时文件：
    char *tmpnam(char *s);  //生成一个包含L_tmpnam个字符的字符串并存储到s所指的字符数组中
    这个函数可以在同一目录下生成最多不超过TMP_MAX个不同的文件名


2.String类 string头文件
    string对象的地址到底在哪里？
        #include <stdio.h>
        #include <string>
        #include <iostream>

        using namespace std;

        int main()
        {
            int a = 1;
            printf("a -> %p\n", &a);
            int *b = (int*) malloc(sizeof(int));
            *b = 3;
            printf("b -> %p\n", b);
            int *c = (int*)malloc(sizeof(int));
            printf("c -> %p\n", c);
            *c = 4;
            string str;
            printf("size=%d capacity=%d location=%p \n", str.size(), str.capacity() , &str);
            cin >> str;
            printf("size=%d capacity=%d location=%p \n", str.size(), str.capacity(), &str);
            free(b);
            cout << str;
        }
    试验得知，超过16字节后，会在堆区重新分配内存空间进行拷贝
    C++用R"(Some string)"表示原始字符串
3.高级数据类型
    char16_t;
    char32_t;
    wchar_t;
4.vector类
    vector<typeName>vt(n_elem);//创建一个名为vt的vector对象，存储n_elem个类型为typeName的元素，n_elem可以是变量
5.array类
    array<typeName,n_elem>arr;//创建一个名为arr的array对象，存储n_elem个类型为typeName的元素，n_elem不可以是变量
    指针：array<typeName,n_elem>*arr;//指向一个arr对象的指针
        *arr是这个array对象，(*arr)[i]则是这个array对象的第i号元素

6.const与指针
    const int *p 指针可修改，指针指向的变量不可修改（p所指向的值是const int）
    int *const p指针不可修改，指针指向的变量可修改（const p所指向的值是int）
    const int *const p指针不可修改，指针指向的变量不可修改（const p所指向的值是const int）
    总结：const出现在*左边，表示被指物是常量，不能通过此指针修改被指物
        const出现在*右边，表示指针是常量，可以通过此指针修改被指物，但是此指针不能指向别的物
        const出现在*两边，表示指针和被指物都是常量

    不能将非const的普通指针指向const变量
7.递归
    与C不同，C++不允许main调用自己
8.函数指针 
    函数原型：returnType func(paraType para);
    函数指针：returnType (*p)(paraType);    //表明p是一个指针，*p是一个函数，返回值为returnType
    对函数指针赋值：p=func;//将函数指针p指向函数func()（因为func本身其实就是一段函数代码的地址）
    通过指针调用函数：
        C风格：(*p)(argument) 相当于func(argument)
        C++风格：p(argument)  相当于func(argument)
    函数指针数组：由于指针数组的定义是valueType *p[num]   //即定义一个包含num个指向valueType的指针数组p
                而这里valueType是returnType (*p) (paraType para)
                故函数指针数组的定义为：returnType  (*p[num])(paraType para)
                
                由于指向整个数组的指针是valueType (*p)[num]
                故指向整个函数指针数组的指针为returnType (*(*p)[num])(paraType para)

    注意：valueType *p[num]是一个包含num个指针的指针数组
        valueType (*p)[num]是一个指向num个元素的数组的指针
9.内联函数
    将函数调用处直接替换成函数的代码，减少跳转的开销
    在函数声明前加关键字inline
    在函数定义前加关键字inline
10.引用变量
    定义：valueType & p=a;//定义了一个a的引用变量p，其值的类型是valueType
    必须在定义引用时初始化，声明是对哪个变量的引用，不能像指针一样先声明再赋值
    引用变量做函数参数：returnType func(valueType &a, valueType &b)

    引用类型做形参时，若声明为const，则可同时接受const和非const变量的引用做为实参
        若形参引用没有声明为const，则不能接受const变量的引用
        若实参的类型与引用参数形参类型不匹配，但可被转换成引用类型，将创建一个正确类型的临时变量，使用这个临时变量赋值给形参
11.默认参数
    在声明函数原型时给参数赋值
        returnType func(paraType para1=VALUE)
    在某个有默认值的参数后右边的所有参数都必须有默认值（从右向左赋默认）
    调用时在某个空缺使用默认值的实参后所有参数都必须使用默认值（从左向右留空缺）
    在有原型时，函数定义不受影响，与一般函数定义一样，不写默认值
    当没有原型只有定义时，也可以有默认值
12.函数重载
    函数的参数的数目和类型，排列顺序不同，则称函数的特征标不同
    函数返回值类型不属于特征标，故若函数名、参数类型、参数顺序都一样，返回值类型不同，会产生冲突
    所以无法重载仅返回值类型不同的函数
    可以对重载的函数添加参数默认值
    例外：注意在类中的运算符重载函数的重载（同一个运算符被重载两次），如果参数相同，const方法与非const方法不冲突，而返回const与返回非const会冲突
13.函数模板
    是对函数的描述
    编译器自动根据描述来生成与调用时的实参类型符合的具体函数的定义
    声明和定义函数模板加语句：
    template <typename variantType>//在声明和定义前都需要
    剩下的函数描述与一般函数的声明和定义方法相同
    returnType func(variantType para)
    编译器生成具体函数时将template声明中的varianttype替换掉func中的所有varianttype
    常常用T代替varianttype：
        template <typename T>
        returnType func(T para){}
    显式具体化：有时，可能需要对特殊的类型执行不同的操作，所以需要为这些特殊类型定义不同的函数，方法是通过显示具体化指定模板类型参数
        template<>
        returnType func<Type>(Type para){}
        由于参数中的Type已经表明了这个具体化的模板参数是Type，所以函数头的模板参数Type可以省略
        template<>
        returnType func(Type para){}
        显式具体化的意思是不要使用通用模板来生成函数定义，而是根据Type类型生成一个专门给Type类型用的函数定义
    隐式实例化：函数模板本身不会生成函数定义，而在程序中，编译器根据函数调用导致生成一个函数模板的具体实例（这个实例就是根据实参类型生成的具体函数定义），这种实例化方法称为隐式实例化
        注意，隐式实例化中，模板参数可以被推导为boid
        如果函数的实参的类型不支持模板函数中的所有操作，会导致编译期错误
    显式实例化：直接命令编译器创建具体实例，格式是在template，后跟函数的模板声明式，在函数头后加一堆对尖括号<声明所需的类型>
        template returnType func<Type> (Type para);
        可以在函数调用中使用显示实例化，而不是隐式实例化，迫使编译器根据代码规定的模板参数来生成函数定义，而不是根据实参来推断
        假如有个模板函数Add()，返回两个相同类型的参数的值
        template<typename T>
        T Add(T a, T b)
        {
            return a+b;
        }
        显示实例化：template int Add<int>(int, int);
        int main()
        {
            int x=6;
            double y=10.2;
            std::cout<<Add<double>(x,y);    //这里使用显示实例化，规定编译器生成一个Add(double a, double b)的函数定义，然后将x做隐式类型转换传递给形参a
        }   //如果上面使用隐式实例化Add(x,y)，则会提示没有与参数模板T匹配的参数实例
    显式具体化在关键字template后有一对<>，显示实例化没有
    当调用一个函数时，名称匹配的顺序是非模板函数>具体化模板函数>常规模板函数
    模板参数自动推导：模板参数自动推导要满足3个条件
        1.模板参数必须与模板函数的形参在位置上一一对应
        2.模板函数返回值的模板参数无法推导
        3.需要推导的模板参数必须连续位于模板参数列表的尾部，中间不能有不可推导的模板参数，如：
            template<typename T1, typename T2, typename T3>
            double func(T1 a, T2 b) {...}   //这里T1 T2是可推导的模板参数，但不位于模板参数列表的尾部，所以不能自动推导
    避免模板参数自动推导：(C++20)
        C++20标准库定义了一个模板结构体std::type_identity
            template<typename T>
            struct type_identity
            {
                using type=T;
            }
        只需将using改成typedef就可以将其移植到C++98及以后的任何C++版本程序中
            template<typename T>
            struct type_identity
            {
                typedef T type;
            };
        在函数模板的函数形参中使用这个结构体的type成员作为类型名，可以避免这个形参的类型在这个函数被调用时发生隐式实例化被自动推导为另一种类型而发生冲突，比如：
            template<typename Key, typename Value>
            void replace_key(std::map<Key, Value>& container, const Key& oldKey, const Key& newKey) {...}   //这个模板函数修改一个map中的某个键值对的键
            
            std::map<std::string, int>my_map{{"one",1}, {"two", 2}, {"three", 3}};
            replace_key(my_map, "two", "double");   //试图调用这个函数，把键"two"改为"double"
            这个函数被调用时，my_map是一个map<std::string, int>类型，所以模板参数Key被推导为std::string，Value被推导为int，所以形参oldKey和newKey的类型应该是const std::string&
            然而实参却是一个C风格字符串，类型为const char*，所以会编译报错，原因是两次Key的类型推导的结果不一致，导致函数根本没有被实例化
        使用type_identity可以解决这个问题：
            template<typename Key, typename Value>
            void replace_key(std::map<Key, Value>& container, const typename type_identity<T>::type& oldKey, const typename type_identity<T>::type& newKey) {...}
        这是因为C++不会自动推导模板类的类型，所以当编译器已经知道Key的类型是std::string时，就不会再在隐式实例化的过程中根据实参的类型去推导出type_identity<T>的模板参数T是const char*类型
        所以当现在调用replace_key时实例化了一个replace_key<std::string, int>函数，形参中的C风格字符串被隐式类型转换为std::string，调用成功
        type_identity<T>::value有一个类型别名
        using type_identity_t=type_identity<T>::value
        所以模板函数的形参的类型可以用type_identity_t<T>代替typename type_identity<T>::value

14.函数模板重载
    函数名相同，而参数的模板类型不同或者个数不同的函数也可以重载
15.初始化：
    聚合初始化：
        T object = {arg1, arg2, ...};	(1)	
        T object {arg1, arg2, ...};	(2)	(C++11 起)
        T object = { .指派符 = arg1 , .指派符 { arg2 } ... };	(3)	(C++20 起)
        T object { .指派符 = arg1 , .指派符 { arg2 } ... };	(4)	(C++20 起)
        T object (arg1, arg2, ...);	(5)	(C++20 起)


内存模型
    自动变量：在声明他的一对花括号内有效，退出销毁
    静态持续性变量：在整个程序执行期间存在，分为下面三种类型
        外部链接性：在一个文件的全局范围定义（不加任何其他关键字），在另一个文件中使用extern声明，则可以在这个文件中访问
            /*a.cpp*/
            int a=0;//在a.cpp中定义a

            /*b.cpp*/
            extern int a;//在b.cpp中使用extern声明，可以在b.cpp中访问和使用a
            无特殊限定的全局变量都具有外部链接性
            所以不能在别的文件中定义名称相同的全局变量，否则违反“单定义”规则
        内部链接性（静态全局变量）：在一个文件的全局范围内定义为static，只能在这个文件内访问
            static int a=0;
        无链接性：在一对花括号内定义为static，只能在代码块内访问
            returnType func()
            {
                ...
                static int a=0; //a将一直存在，第二次调用func时不会将其重新初始化赋值为0，而是保持其上次的值
                ...
            }
    所有未手动初始化的静态持续性变量都被自动初始化为0
    局部变量将隐藏（与之同名的）全局变量

    函数默认都具有外部链接性
    可以将函数声明为static returnType func()使得函数只在本文件内可用
    mutable关键字：若结构和类声明为const，可以将某个成员声明为mutable，使得可以修改这种结构和类的实体中被声明为mutable的成员
        也可以在const成员函数中修改mutable的类成员
    定位new：
        new(ptr)type
        new(ptr)type []
        指定在ptr所指的内存区域上动态分配新内存
语言链接性
    由于C++对函数名会进行修饰，所以要使用C语言中的函数，需要在函数原型前加extern "C"
        extern "C"
        {
            ...//C语言中的函数原型
        }
        extern "C++"//C++的显式声明，可以去掉
        {
            ...//C++语言的函数原型
        }
名称空间：为了解决命名冲突的问题
    创建名称空间：
        namespace name  //创建一个名为name的名称空间
        {
            ...
        }   //名称空间末尾大括号后不加分号
    名称空间是开放的，可以另外添加新名称到已有的名称空间中
        namespace name
        {
            //somethingnew
        }
    除了用户定义的名称空间，在一个文件内还存在一个全局名称空间，用两个冒号运算符（名称空间解析运算符）表示
        ::globalName
        比如在这个文件内编写了某个函数，而在下面的函数中要使用这个函数而不是其他名称空间内的函数，就使用名称空间解析运算符显式表明是本文件内的这个函数
    using声明：将特定的名称添加到他所属的声明区域中（本文件全局、函数内、代码块内）
        using nameSpaceName::memberName;    //相当于将nameSoaceName中定义的memberName在当前作用域中可见
        与其他局部变量一样，若在局部（函数、代码块内）使用using 声明，则会隐藏同名的全局变量
            #include <iostream>
            namespace Jill
            {
                double fetch;
            }

            char fetch='a';

            int main()
            {
                using Jill::fetch;  //相当于将Jill内声明的fetch在main中可见，使得可以在main()中使用它
                fetch = 3;  //由于局部变量会隐藏全局变量，故这个fetch是Jill内的fetch
                std::cout << fetch << std::endl;    //输出3
                std::cout << ::fetch << std::endl;  //双冒号全局运算符，输出全局的fetch：a
            }
        与其他全局变量一样，在函数外使用using声明，将把名称添加到本文件全局名称空间中
    using编译指令：使名称空间内的所有名称都可用//？
        using namespace nameSpaceName;
        与using声明不同，using编译指令允许所在的局部有同名变量，若发生这种情况，名称空间内的同名名称被隐藏
            #include <iostream>
            namespace Jill
            {
                double fetch;
            }

            int main()
            {
                using namespace Jill;
                int fetch = 3;
                Jill::fetch = 4.0;
                std::cout << fetch << std::endl;    //输出局部变量int fetch：3
                std::cout << Jill::fetch << std::endl;  //输出名称空间内的变量double Jill::fetch：4.0
            }

    未命名的名称空间：若namespace关键字后省略名称，则相当于只能在本文件内使用该名称空间中的名称，类似于内部链接性
    名称空间可以嵌套：
        namespace A
        {
            ...
            namespace B
            {
                ...
            }
            ...
        }
    名称空间别名：
        namespace a=name;//让名称空间a成为名称空间name的别名

类
    类声明->头文件.h
    #include "头文件.h"+类方法（成员函数）->源.cpp
    #include "头文件.h"+客户程序->main.cpp
    类的默认成员都是private，所以可以省略private关键字，只写public和protected关键字和其成员
    注意类的成员变量和成员函数不能重名
    构造函数：是与类名相同，没有返回值类型的特殊类方法函数
        构造函数的参数名不应与类成员变量名相同，否则无法完成初始化赋值
        可以给构造函数的原型中的参数列表提供默认值，方法与规则与函数默认参数相同
        默认构造函数：当没有提供构造函数时，C++提供隐式默认构造函数，它不完成任何工作
            如果提供了构造函数，则可以通过函数重载来手动定义默认构造函数：
                className(){}
        调用构造函数：
        若className类有构造函数：className(paraType para)，则有如下的调用方法来构造object对象
        className object=className(paraValue);  //可能会创建一个临时对象
        className object(paraValue);            //是上面的简写
        className object={paraValue};           //C++11列表初始化
        className object{paraValue};            //是上面的简写
        若动态分配object
        className *object_ptr=new className(paraValue);
        className *object_ptr=new className{paraValue};//C++11列表初始化
        若构造函数只有一个参数，可以用赋值语句来调用构造函数初始化对象
            如：有构造函数className(paraType para1){...}
            调用：className object=value;
                若构造函数除了第一个参数，其他参数都有默认参数，则也可以用下面两种形式
                className object(value);
                className object=className(value);
    析构函数：在类型前加~，没有参数，没有返回值类型
        ~className(){...}
        默认析构函数：若没有提供析构函数，C++提供默认析构函数，它不完成任何工作
    构造函数和析构函数都应该是类的public成员
    类状态成员：通常的做法是在声明类的头文件.h中的public部分加一个enum 状态 {状态取值}，然后在私有数据成员中加状态 状态名，然后写上相应的公有接口函数
        这样函数的成员方法可以使用状态取值，外部也可以通过公有接口来改变这个状态
    静态成员变量：在类变量前加static关键字
        在编译时分配内存，在程序结束时释放，类似于全局变量，不过作用域不同
        初始化静态成员变量要在类外进行，不能用参数初始化列表，格式： 类型 类名::静态成员变量名=值;
        可以通过对象引用，也可以通过类名和作用域解析运算符
        可以在普通类成员方法中使用类中的静态成员变量
    const方法（const成员函数）：
        对于不修改对象本身的方法，由于这个方法本身可能没有任何参数，所以在函数原型和定义后加const关键字
        原型：void func() const;
        定义：void className::func() const {...}
        有个例外，如果在类定义中将非const非static成员（普通成员变量）声明为mutable，则可以在const成员函数中更改他们的值
    this指针：所有类的方法都将this指针设置为调用它的对象的地址
        所以在方法中访问成员变量实际上都是this指针指向的对象的成员变量
        *this将引用调用类方法的整个对象
        若将函数限定为const方法，则不能通过this指针修改对象
    静态成员函数：在类方法前加static关键字
        普通成员函数在传递参数时编译器会隐式传递this指针，通过this指针来确定是哪个对象调用此方法，而静态成员函数没有，所以不可以用静态成员函数访问类中的普通变量
        可以通过对象调用静态成员函数，也可以通过类名加作用域解析运算符： 类名::静态方法名
    静态常量成员：用static和const修饰的成员
        新标准可以在类内初始化
        旧标准不支持时，应当现在类内提供声明式，再在类外（.cpp实现文件）内提供定义式（注意用类名+名称解析运算符+成员名+值）
        可以对静态常量成员取地址，这是与enum最大的区别
    运算符重载：使用运算符函数的特殊函数形式
        原型：returnType operatorop(paraType para); //将op替换为要重载的运算符
        定义：returnType className::operatorop(paraType para) {...}   
        调用：可以用传统调用类方法的方式把运算符函数当传统函数调用，也可以直接用被重载的运算符，运算符后操作数直接作为实参传递给para
            object.operatorop(argument)
            object op argument
            如果是一元运算符：
            原型：returnType operatorop(); //将op替换为要重载的运算符，由于是一元运算符，所以肯定没有参数，因为作用于对象本身
            定义：returnType className::operatorop() {...}
            调用：object.operatorop();
                op object;
                有个例外是重载[]运算符
                    object.operator[](int i)
                    object[i]
        注意前置++和后置++运算符的重载：
            后置++、--操作符函数的重载需要在函数的参数内加一个int（为了区分前置和后置的标准）
            前置++、前置--，需要返回一个加完（减完）后的自身的引用，定义
                someClass& operator++() 
                {   ...//一些操作
                    return *this;
                }
            后置++、后置--，需要返回一个加和减之前的临时对象，再对自身操作，定义
                someClass operator++(int) 
                {
                    someClass temp(...) //构造一个临时对象，通常是使用复制构造函数直接将*this复制给temp
                    ...//一些操作
                    return this;
                }
        只能通过成员函数重载的运算符：
            = 赋值运算符 () 函数调用运算符  [] 下标运算符  -> 指针访问类成员运算符
    友元函数：可以访问类的私有成员的函数
        在普通函数声明（函数原型）的类型前加friend，放在类声明中
        定义与普通函数相同，不加friend，也不加名称空间解析运算符::
    转换函数：将对象转换为其他类型时需要定义的函数，该函数没有返回值类型，没有参数
        如需要将对象转换成typeName类型
            在类方法的public中声明：operator typeName();
            定义：className::operator typeName(){...}
        注意在定义了多个转换函数后，可能会导致赋值时的二义性（即可以将对象转换为多种类型来赋值）
        可以使用下面两种显式类型转换：
            typeName var; 
            var=(typeName) object;//使用转换为typeName类型的转换函数将object赋值给同样类型的变量var
            var=typeName (object);
        可以在转换函数的原型（声明）前加explicit关键字，使得任何转换都必须使用显式形式
            explicit operator typeName();
    复制构造函数：用于将一个对象复制到新创建的对象中，发生在初始化过程（按值传递参数、新建一个对象并用另一个对象对其初始化）
        复制构造函数没有返回值，形式上有点像接受一个同类对象的引用作参数的只有一个参数的构造函数
        由于只有一个参数的构造函数可以直接赋值，所以复制构造函数就是在新定义一个对象的同时用=赋值运算符将另一个对象赋值给新对象时被调用
        原型：className(const className &);
        定义：className(const className &){...}
        默认复制函数：按值拷贝所有非静态类成员，当类中含有new分配产生的成员时由于是按值复制，新对象析构时就会将原对象指向的内存delete掉从而产生问题
        调用：className object1=object2;//将调用复制构造函数来构造object1
        如果不需要复制构造函数，需要显式地声明到类的私有部分
    赋值运算符：用于对象给对象赋值
        与默认复制构造函数类似，默认赋值运算符也是将非静态类成员按值拷贝，当有new产生的成员时会产生类似问题
        本质上是重载的赋值=运算符，是重载运算符的一种特殊情况
        由于赋值永远是被复制的对象通过调用重载的赋值运算符来返回自己，所以这个赋值运算符重载函数的返回类型永远是自己的引用，参数永远是同类对象的引用
        注意如果类中有new分配的成员，应该先delete掉旧的，再分配新空间，然后再复制被复制的对象中的相应成员
        原型：className & operator=(const className & object);
        定义：className & className::operator=(const className & object) 
            {
                //一般的，先判断一下对象是否自己赋值给自己
                if(this==&object)
                    return *this;
                ...             //delete之前分配的内存，根据object来new一些新内存，并复制object中的相应成员
                return *this;   //返回自己的引用
            }
            方法2：
                {
                    className temp(object); //先构造一个object的副本temp
                    swap(*this, temp);  //将这个对象与temp对象交换
                    return *this;   //返回交换过的这个对象的引用，由于temp的自动变量，所以自动销毁，这个方法也可以处理自我赋值的问题
                }
            方法3：可以将赋值运算符的形参声明为按值传递，而不是按引用传递，这样可以将方法2中临时对象temp的构造也省去
            className & className::operator=(className object)
            {
                swap(*this, object);
                return *this;
            }
        调用：object_new=obejct;
        如果不需要赋值运算符，需要显式地声明到类的私有部分
    注意：不需要复制构造函数和赋值运算符把他们声明私有部分时，也要对类中的常量成员赋值，通常在初始化列表中赋一个无意义的值
    类和结构的嵌套：类中声明的结构体、类、枚举类型，作用域为整个类，这样的声明不创建数据对象，只指定可以在类中使用的类型
        若在private部分中声明，只能在类中使用
        若在public部分中声明，可以在类外面用作用域解析运算符::使用，如：className::struct A a;声明了一个在className中声明的sturct A类型的变量a
    类中常量成员的初始化方法：
        由于常量应在对象被创建时初始化，而构造函数的函数体的执行是对象被已经被创建且分配内存之后执行的，所以无法在构造函数中赋值
        应使用成员初始化列表的方法
        在构造函数的定义的函数头后加冒号: 成员，成员后跟括号(括号内是成员的值)，多个成员间用逗号,分隔
        如：
            className::className(paraType para) : const_mem1(value), const_mem2(value)
            {
                ...
            }
        只有构造函数的定义才能用这种语法，另外这种语法不限于常量，然而常量和引用成员只能使用这种语法初始化，因为其值必须在初始化时确定
        C++11允许类内初始化，如：
            class className
            {
                const mem1=value;
                className & mem2=&object;
                ...
            }
        等价于：
            className::className() : mem1(value), mem2(&object) {...}  
    定位new运算符生成的对象：需要显式地为用定位new运算符生成的对象调用其析构函数，然后再释放存储有那个对象的内存空间
        直接delete掉new的对象再释放内存会发生异常
继承：
    公有继承：从base基类公有继承得到derived派生类，声名：
        class derived:public base {...} 
        派生类需要自己的构造函数：
            由于必须首先创造基类，而派生类又不能直接访问基类的private成员，所以这个构造函数应在成员初始化列表中调用基类的构造函数来构造其基类的部分
                    若没有显式调用基类构造函数，将调用基类的默认构造函数
                    如果基类有可以无参调用的构造函数（构造函数有带默认值的参数或构造函数无参），则可以不用显式调用
                若使用基类的一个对象作为基类构造函数来构造基类，则使用基类的复制构造函数
                    若没有定义复制构造函数，则使用默认复制构造函数（按成员赋值）
                    使用基类的复制构造函数的派生类构造函数定义：derived::derived(... ,const base & obj) : base(obj) {...}
            然后派生类构造函数再初始化新增的成员
        派生类的析构函数：在释放对象时，C++自动先调用派生类的析构函数，然后调用基类的析构函数，可以都使用默认析构函数，即不显式定义析构函数
            如果派生类显式定义析构函数，也会在调用完派生类析构函数后自动调用基类的析构函数（所以注意不要delete两次）
            如果派生类使用默认析构函数，也会调用基类中显式定义的析构函数或没有显式定义的默认析构函数
        派生类和基类的关系：
            派生类对象可以使用基类的非private方法（public、protected）
                派生类函数中如果要调用基类的方法，需要加基类类名和作用域解析运算符
            基类指针/引用可以在不进行显式类型转换的情况下指向派生类对象（形参是基类的指针或引用同理）
                所以可以使用派生类对象初始化基类的对象（因为基类复制构造函数的形参是基类对象的引用）
                所以也可以使用派生类对象给基类对象赋值（因为有默认重载的赋值运算符函数，其形参也是对基类对象的引用）
                然而不能通过基类的指针/引用来调用派生类中新定义的方法
        多态：基类和派生类中同名函数的不同行为
            需要将基类中的同名函数原型声明为virtual虚函数，在函数的原型的类型前加关键字virtual
            派生类中的同名函数加不加virtual关键字没有影响
            注意虚函数和派生后的同名函数参数必须一样，返回类型都可以不一样（协变：返回类型可以是一个对象，这个对象的类是另一个派生类的基类）
            class A
            {
            public: 
                virtual int func();
            }
            class B:public A
            {
            public:
                double func();
            }
            有了虚函数后，如果将基类的指针/引用指向派生类对象，并调用这个同名函数，将根据实际的指向（派生类对象）调用派生类重新定义的同名函数
            如果不是虚函数，将永远调用这个指针/引用类型的类（基类）中的方法
            无论是不是虚函数，派生类中的同名函数都会隐藏基类的同名函数，所以对派生类对象调用这个方法永远是派生类中新定义的方法
            友元函数不能是虚函数，因为友元不是类成员
            虚函数的工作原理：动态联编、虚函数表...
            虚析构函数：如果派生类的析构与基类行为不同（比如派生类中有new分配的成员，需要在析构函数中释放），或者可能需要用基类指针或引用管理派生类对象，就需要在基类中显式声明虚析构函数，通常都应该将基类的构造函数声明为虚（类中已经定义了其他virtual虚函数的就应该有虚析构函数）
                如果希望基类用作抽象基类，可以将析构函数声明为纯虚函数，但是仍然应该提供他的定义，因为派生类的析构函数会调用基类的析构函数，如果不提供基类析构函数（即使是纯虚函数），连接器会报错
        访问控制：protected
            派生类可以访问基类中的protected成员，所以对派生类而言，protected与public类似
        纯虚函数：未实现的函数，在虚原型的原型后加=0成为纯虚函数
            virtual returnType func(paraType para)=0;
            纯虚函数也可以包含定义，不过用处不大，因为抽象基类派生的类必须覆盖这个纯虚函数，不过也可能派生的类调用在抽象基类的纯虚函数（注意使用作用域解析运算符::）
        抽象基类：包含纯虚函数的类
            一般的，包含纯虚函数的类只用作基类而不能创建对象
            一般的，用指向抽象基类的指针/引用来管理派生类的对象来实现多态
            如果需要一个抽象基类，同时又不需要一个纯虚函数，可以定义一个不带virtual关键字的虚函数 returnType func(paraType para)=0 并提供这个函数的定义，这也可以使得这个类称为抽象基类
            这种情况通常发生在func在派生类中的行为相同时
        继承与动态内存分配：
            若基类使用了new，派生类不使用new，则无需显式定义派生类的构造、析构、复制、重载赋值运算符
                因为派生类的构造会调用基类的构造，基类的构造应当已经new了所需空间
                因为派生类的析构会调用基类的析构，基类的析构应当已经delete了new的空间
                因为派生类的复制是成员赋值，而派生类没有new，所以成员赋值是可行的，而基类的复制应当已经处理了需要重新new的部分（如同在自己开发的类中使用string类那样）
                重载赋值与复制相似
            若基类使用了new，派生类也使用了new，则需要显式定义派生类的构造、析构、复制、重载赋值运算符
                因为派生类的构造需要new，所以显然需要在构造函数中定义，还要注意一般继承的构造函数调用基类构造函数的方法
                因为派生类的析构需要delete，所以也显然需要在析构函数中定义，派生类的析构函数将自动调用基类的构造函数delete基类new的部分
                派生类的复制构造函数需要调用基类的复制构造函数来处理基类的复制，所以需要在成员初始化列表部分将引用参数传给基类的复制构造函数来构造基类部分，同时再处理派生类自己new的部分
                    格式：derived::derived(const derived& d):base(d) {...}
                派生类的重载赋值运算符也需要将引用参数传给基类的重载赋值运算符，与复制构造函数不同的是可以在重载复制运算符函数体中进行（注意作用域解析运算符，因为如果不加，会递归调用派生类的函数）
                    重载赋值运算符调用基类重载复制运算符的方法：baseClass::operator=(参数);
    包含：has-a关系，即包括对象成员的类
        如果将对象放到一个类的private部分，则在类的成员函数中可以访问和修改，但类外只能通过这个类定义的公有接口来访问（不只是对象，还有其他private的数据成员），而不能直接调用这个被包含的对象的方法
        所以称这个类获得了对象成员的实现，但没有继承接口（即不能在类外直接使用这些对象的方法）
        初始化顺序：
            当初始化列表（构造函数定义的函数头的冒号后面的部分）包含多个项目，这些项目被初始化的顺序为他们在类定义中被声明的顺序，而不是按初始化列表的顺序
        初始化被包含的对象：
            应当在初始化列表语法中对被包含对象初始化，如果没有显式初始化，将调用这些对象的默认构造函数
    私有继承：has-a关系，从base基类通过私有继承得到derived，则表明derived类包含base类，声明：
        class derived:private base
        由于C++默认的继承是私有继承，所以可以省略private关键字，如：
        class derived:base
        使用私有继承，基类的public和protected都成为派生类的private
        由于使用私有继承，基类的public方法成为派生类的private方法，所以与包含一样，派生类获得了基类的实现，但没有继承接口
        多重私有继承：从多个base类继承而来的派生类，声明：
            class derived:private base1, private base2 或 class derived: base1, base2
            初始化基类组件：由于私有继承没有基类对象名，需要使用类型名来初始化基类组件，所以需要在构造函数的成员初始化列表中试用基类类名代替成员名：
                derived(paraType para): base1(value),base2(value){}
            访问基类的方法：在派生类中使用基类的方法，注意加作用域解析运算符
                有时希望基类的一些方法成为public（因为私有继承全部变成了private），则需要在派生类中定义新的public方法，在这个方法中调用基类的方法
            访问基类对象：同样由于没有基类对象名，需要使用强制类型转换将自身对象的引用转换为基类对象类型来访问
                (base &)*this;//将*this是这个派生类的对象，将其强制转换为基类的引用类型来得到基类的组件
            访问基类的友元函数：由于友元函数不属于某个类，但是需要接收一个类的引用做参数，所以派生类对象可以使用强制类型转换为基类对象来使用基类友元函数
    多重公有继承：与单公有继承一样，也是表达is-a关系，声明：
        class derived: public base1, public base2 //public关键词不可省略，由于默认是private继承
        虚基类：使得从多个基类相同的类派生出的类只继承一个基类组件，继承虚基类加关键字virtual，且virtual关键字和public关键字的顺序随意
            假如derived1和derived2类都是从共同的base虚基类继承而来：
                class derived2: virtual public base //class derived1: public virtual base
                class derived1: virtual public base //class derived2: public virtual base
            而derived3类使用多继承从derived1和derived2继承而来：
                class derived3: public derived1, public derived2
            则derived3只包含了一个base最初基类的组件
            而base可以被用作虚基类，也可以被用作非虚基类
            构造函数：如果称derived1和derived2是中间类，他们从虚基类base（其实是虚继承基类，而不是抽象基类，这里的base不是抽象基类）继承而来，
                C++不会将derived3的构造函数通过中间类传递给基类，因为这样会有两条传递途径，所以会使用基类的默认构造函数
                可以通过在成员初始化列表中显示调用基类所需的构造函数 derived3::derived3():derived2(...),derived1(...),base(...)
                如果类有间接虚基类（这里是base），除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数
            同名方法：
                如果在derived1和derived2中有同名方法，则使用derived3的这个方法需要使用成员运算符+类名+作用域解析运算符+函数名
                或者再新定义一个方法
    继承结构中的数据Get和Show：
        可以在继承层次中的每个类中增加一个proteced的Data()方法，该方法仅显示这个类中新增的数据成员，然后再定义一个public的Show()方法，这个方法先调用基类的Data()，再调用本类的Data()
        在多重继承中，假如有A-BC-D，在D类中定义一个Data()方法，调用BC的Data，然后再定义一个Show()方法，调用D::Data()（调用BC的Data），然后再调用A类的Data()（或者先调用A::Data(),再调用BC的Data()）
        对于Get也是同理，在继承层次中的每个类增加一个protected的Get()方法，该方法仅获取这个类新增的数据成员，然后再定义一个public的Set()方法，这个方法先调用基类的Get，再调用本类的Get()
        在最高级的派生类中的Set()先调用最基类的Get()再调用各个直接派生类的Get()方法
    代理类：如果希望在容器中存不同类型但是派生自同一个基类的对象，通常有两个办法：存基类的指针，指针指向不同的派生类对象、存代理类对象
        用指针有复杂的内存管理问题，比如存了一个自动（栈）的对象的指针，退出作用域后被销毁，指针就成了野指针
        如果改成指向这个对象副本的指针，而基类是一个虚基类，又存在难以调用复制构造函数的问题（因为基类对象不存在，所以不能通过基类的指针调用派生类的构造函数），所以使用代理类
        代理类通常的实现方法：1.在基类中添加一个虚的复制函数copy（不是复制构造函数），这个函数new一个基类对象，返回基类指针，形式：virtual bassClass *copy()const {return new bassClass(*this);}
        上一步会调用基类的复制构造函数创建一个未命名对象，然后返回指向这个对象的指针
        2.在派生类中同样添加一个同名函数，new一个派生类对象并调用派生类的复制构造函数，返回基类指针，形式： baseClass * copy()const {return new derivedClass(*this);}
        3.定义一个代理类，其中私有部分是一个基类指针，代理类的构造函数的参数接受一个基类对象的引用，然后调用对象的copy方法，将返回的指针赋值给代理类的那个基类指针
        同时，应该有一个默认构造函数，因为有可能没有来得及将引用传给代理类，所以此时pt指针为空
        代理类的析构函数应该释放这个pt指针new的对象
        代理类还应该能复制、赋值
        class Surrogate
        {
        public:
            Surrogate(){};
            Surrogate(const bassClass & base) {pt=base.copy();} //由于只有一个参数的构造函数可以用赋值语句构造，所以可以用形如Surrogate sur_obj=obj;   obj是基类或派生类（整个派生链）的对象
            ~Surrogate() {delete pt;}
            Surrogate & operator=(const Surrogate & s)
            {
                if(this==&s)
                    return *this;
                delete pt;
                pt=(s.pt? s.pt->copy():0);  //先判断参数这个代理类对象的pt指针是否为空，如果不为空，就调用他所指的对象中的copy函数，否则赋值空
                return *this;
            }
            Surrogate(const Surrogate & s):pt(s.pt? s.pt->copy():0) {} 
        private:
            baseClass *pt;
        }
        4.然后将基类的虚函数全部在代理类中定义，这样就能通过代理类使用这些方法
        对于虚基类，原理相同，在基类中定义一个纯虚函数virtual baseClass*copy() const=0，
            派生类中都是定义一个函数copy()，函数返回虚基类指针，new一个派生类对象，调用派生类的复制构造函数，参数是派生类对象自身*this：baseClass * copy()const{return new derivedClass(*this);}
    句柄类：代理类有个问题是要对每个对象进行复制并创建相应的代理类对象，复制有时开销很大，使用句柄类引入引用计数，当只有必要时才复制
        可以将引用计数单独作为一个类来辅助句柄类，这样引用计数类可以单独作为模块，与句柄类操作的对象无关
        class baseClass //有一个基类
        
        class refCount  //引用计数类
        {
            int *p;     //有一个指向整形的指针，这个整形数就是引用计数
        public：
            refCount():p(new int(1)) {} //默认构造函数，将p所指的整形初始化为1
            refCount(const refCount & r) : p(u.p) {++*p;}   //复制构造函数，用一个引用计数对象构造新一个，应该将引用计数值加1
            refCount & operator=(const refCount & r) {}
            bool only() {return *p==1;}     //为了方便定义的一个判断引用是否唯一的函数
            ~refCount() //析构函数，当引用计数为0时，释放计数值
            {
                if(--*p==0)
                    delete p;
            }
        }
       
        class Handle    //baseClass的句柄类
        {
            baseClass *baseObj; //基类的指针
            refCount count;     //引用计数对象，这就是句柄类与代理类的关键区别，避免不必要的复制
        public:
            Handle() : baseObj(new baseClass) {};   //由于没有显式调用refCount类的构造函数，将调用其默认构造函数，将引用计数置1
            /*下面的构造函数应与baseClass基类中的构造函数相对应，即将基类的所有构造方法所需参数在句柄类中定义，然后new一个新对象，将参数传给基类构造函数*/
            ...
            /*默认的复制构造函数按值复制成员，所以会复制指针的值和引用对象，而引用对象的复制构造函数是复制了那个引用计数指针，并将其+1，完成了所有需要的步骤，所以不需要显式定义复制构造函数*/
            ~Handle()
            {
                if(count.only())
                    delete baseObj;
            }

        }
类模板：
    声明一个类模板，在通常类的定义上一行加：template <class Type>或template <typename Type>
    其中Type是泛型的类型名（可以自定义），class表示这是一个泛型类型名，然后在类的所有泛型类型用Type替换
    类模板的类定义和类方法的具体实现（函数定义）必须放在同一个文件（头文件.h）
    对所有在类定义外的类函数（方法），添加一行template <class Type>，并将限定名从 className::改成className<Type>::，如：
        template <class Type>   //template <typename Type>
        returnType className<Type>::func(paraType para) {...}
    对于类内定义的函数（内联函数），不需要改限定名
    使用这个类模板定义一个新对象：
        className <type> object;//定义了一个type类型的className模板类对象object
    非类型参数：在定义模板时，可以有非类型参数，在具体化时将非类型参数的值代替模板类中的值
        定义模板类：template <class Type, int n>    //n是非类型参数
                    class className
                    {
                        ...
                    }
        定义模板类对象：className <typeName, 3> object; //定义了一个模板类className的对象object，其中className类中Type类型替换为typeName，所有的n替换为3
        其中n是非类型参数，将代替className模板类中n的值
    多个类型参数：模板可以包含多个类型参数（特别是需要在一个类中包含多种不同类型的成员时）
        template <class T1, class T2>
        class className {...}
    隐式实例化：用定义好的模板类的类名和一对尖括号<>指出所需类型来定义对象，编译器将所需类型替换掉模板中的类型参数生成具体类定义，并用这个具体的类定义初始化变量
        className <type> object;    //定义了一个className模板类对象object，其中用type替换掉模板中的Type，发生隐式实例化
    显示实例化：用template关键字、类、指出所需类型，译器将所需类型替换掉模板中的类型参数生成具体类定义
        template class className <type>;    //生成了具体的class className的定义，其中用type替换掉模板中的Type
    显式具体化：是为具体类型而不是泛型提供定义（特别是有的特殊类型的类，需要对模板修改，使其行为不同）
        所以显式具体化是针对与类而言
        template <>
        class className <type>
        {
            ...
        }
    部分具体化：给一部分模板参数指定具体类型（目的仍然是使有的特殊类型修改模板，使其行为不同）
        template <class T1, class T2> class className {...} //完全通用模板
        template <class T1> class className <T1, type> {...}    //部分具体化模板，第二个类型参数设定为type类型
        此时用模板来定义对象，将选择具体化程度最高的模板，即转换次数最少，且部分具体化类型参数符合指定需要最多的模板
        注意，不能使得对象的所需类型需求与多个部分具体化的模板匹配程度相同
    模板类和友元：分为三类
        非模板友元：模板类中的友元函数不包含模板参数，是常规函数
            void func();    //注意在friend部分声明了func()并没有声明func()函数本身，还需要在类外声明，在实现文件cpp中实现
            template<typename T>
            class HasFriend
            {
                friend void func(); //由于不包含模板参数，func()是非模板友元，定义方法与普通函数一样，注意在friend部分声明了func()并没有声明func()函数本身，还需要在类外声明，在实现文件cpp中实现
            };
            由于是友元函数，就肯定需要访问类的成员，而由于是非模板函数，所以肯定不能有任何带模板参数的类对象
            所以这样的函数只能访问全局对象，使用全局指针访问非全局对象，访问自己创建的对象，访问独立于对象的模板类的静态数据成员
        约束模板友元：友元函数中带有模板参数，而且类的每一个具体化都获得与友元匹配的具体化，即T类获得T类参数的友元，类->友元
            类内定义法：
                template<typename T>
                class HasFriend
                {
                    friend void func(HasFriend &);
                };
                由于当模板类实例化之后就获得对应的实例化的友元函数，这个实例化的友元函数不是模板函数，所以可以发生隐式类型转换（如果模板类有一个可隐式类型转换的构造函数）
            类外定义法：
                先要在类模板前声明每个模板友元函数，然后再类中声明为友元，而且需要声明模板参数
                与模板函数一样，由于约束模板友元也是模板函数，所以要在同一个文件中声明和定义
                template<typename T>
                class HasFriend;        //先声明有这么一个模板类叫HasFriend

                template<typename T>
                void func(HasFriend<T>& );//再声明有这么一个模板函数，参数的类型是一个类模板

                template<typename T>
                class HasFriend
                {
                    friend void func<T>(HasFriend<T>& );    //声明这个模板函数是友元
                    //或者 friend void func<T>(HasFriend& );
                };

                template<typename T>
                void func(HasFriend<T>& hf)
                {
                    //func的定义
                }
                由于这个友元函数是模板函数，所以不会发生隐式类型转换
        非约束模板友元：在模板类内声明的带有模板参数的友元函数，每个函数具体化都是每个类具体化的友元，即任何一个具体化之后的函数，都是所有具体化类的友元
            所以这样的友元函数可以访问任何一个具体化类
            template<typename T>
            class HasFriend
            {
                template<typename TT>
                friend void func(TT& );
            }

            template<typename TT>
            void func(TT& hf)
            {
                //func的定义
            }
    模板别名：可以为模板具体化（指定了类型参数的模板类的类名）指定别名
        旧方法使用typedef：typedef className<type> alias;   //将alias作为className的type类型的具体化的别名
        C++11新方法：using alias=className<type>;   //将alias作为className的type类型的具体化的别名

友元：
    单向友元：如果A类对象要控制（发送信息给B类）应考虑在B类定义中用friend关键字将A类声明为友元类，友元类声明的位置无关紧要，可以在public private protected中声明，不改变友元类的访问权限
        class B
        {
            friend class A;
        }
        注意顺序，由于要在A类中处理B类的成员，所以需要先定义B类，再定义A类，也可以使用前向声明的方法
        而友元类（A）不需要前向声明，因为声明友元类的语句已经指出友元类A是一个类
        大多数情况下，只需要A类中的某些方法称为B类的友元，这些方法称为友元成员函数，在普通函数原型前加friend关键字
        class B
        {
            friend returnType A::func(B & b);   //由于要在A类处理B类，所以这个函数肯定需要一个B类对象的引用参数
        }
        此时要特别注意顺序，由于这里使用了作用域解析运算符作用于A类，所以需要A类的定义，而这个方法的参数又有B类的引用，所以应该将B类前向声明
        class B;
        class A {...};
        class B {... friend ...};
    双向友元：有时需要两个类能互相控制
        如果A类中需要使用B类的信息（修改B类成员，调用B类方法），则需要在B类定义后再定义
        所以正确的顺序是先定义A类（B类是他的友元类），对于要使用B类信息的方法只提供原型，然后定义B类（A类是他的友元），此时要使用A类信息的方法可以直接定义（因为A类已经定义了），然后定义那些A类中要使用B类信息的方法
        class A
        {
            friend class B;
            ...
            returnType somefunc(B & b);
        };
        class B
        {
            friend class A;
            ...
        };
        returnType A::somefunc(B & b) {...}
    同时是两个类友元的函数：同时在两个类里加关键字friend声明为友元函数
        注意顺序，由于这样的函数需要两个类对象的引用，所以需要把后定义的类做前向声明使得编译器知道这个类的存在
        class B;
        class A
        {
            friend returnType friendfunc(A & a, B & b);
        };
        class B{...};
智能指针：
    #include <memory>
    智能指针就是在声明时分配堆内存，并在指针变量退出所在作用域后自动释放分配的内存
    1.unique_ptr
        声明方法：unique_ptr<Type> pt(new Type);  //创建了一个Type类型的智能指针pt
            unique_ptr<Type[]> pt(size_t size); //创建了一个大小为size个Type类型的智能指针pt
            unique_ptr<Type>pt=std::make_unique<T>();
            unique_ptr<Type>pt=std::make_unique<T[]>();
        unique_ptr对象重点在于所有权的概念，即不允许复制（避免了auto_ptr在复制时导致两个指针指向同一块内存，然后超出作用域后释放同一块内存两次的问题）
        例外是可以将一个临时指针变量赋值给另一个，如：
        unique_ptr<Type> Create()
        {
            return unique_ptr<Type> (new Type);
        }
        int main()
        {
            unique_ptr<Type> pt=Create();   //将临时变量复制给pt
        }
        或者：
        unique_ptr<Type> Create()
        {
            unique_ptr<Type>tmp(new(Type));
            return tmp;
        }
        int main()
        {
            unique_ptr<Type> pt=Create();
        }
        作为函数实参时，如果形参是同样的智能指针，由于会发生复制，所以产生错误，正确的方法是将形参声明为引用
        方法：
            get()返回unique_ptr所管理的对象的指针
            reset(*ptr=nullptr)释放当前所管理的对象，如果参数ptr是一个nullptr（同时也是缺省参数），则调用reset后当前的unique_ptr不拥有任何对象，如果ptr非空，则拥有ptr所指的对象（常用与重新分配一块新内存给当前的unique_ptr)
        3.unique_ptr<T> make_unique<Type>(para)
        make_unique模板函数将para传递给Type类型的构造函数来构造一个堆区对象，然后返回一个unique_ptr
        这个函数的效果与return unique_ptr<T>(new T(para));  一致
    2.shared_ptr
        当程序会使用多个指向同一个对象的指针，就用shared_ptr
        允许复制和赋值，在复制时会增加引用计数，退出作用域后将指向同一内存的shared_ptr的引用计数减少1，当引用计数减少到0时释放这一块内存
        在类内包含使用shared_ptr的成员可能造成循环引用的问题，如：
        struct A
        {
            shared_ptr<B> ptr_to_B;
            //A(shared_ptr<B> ptr):ptr_to_B(ptr){}
        };
        auto ptr_A=make_shared(A);
        auto ptr_B=make_shared(A);
        ptr_A.ptr_to_B=ptr_B;
        ptr_B.ptr_to_B=ptr_A;   //此时ptr_A与ptr_B内包含的shared_ptr指针造成循环引用，彼此都引用另一个A的对象，所以当退出作用域后内存无法释放，造成内存泄漏      
    3.weak_ptr
        不参与引用计数的shared_ptr
        方法:
            long int use_count() const //返回这个weak_ptr所指向的对象被多少个shared_ptr所共有
            
STL
    容器：
        顺序容器：
            list：template < class T, class Alloc = allocator<T> > class list;
                是用双链表实现的，所以插入和删除和移动元素效率较高（比如用于排序操作，需要频繁移动元素），可以双向访问（迭代器）
                由于每个节点要储存指针，所以对于元素很多而元素本身占用空间又很小时开销就不划算
                list自带sort()方法，不能使用STL的sort()函数
                方法：
                    remove_if(func);    //参数func是一个谓词
            array：template <class T, size_t N > class array;
                与普通数组相似，在内存中严格使用线性顺序，长度在编译时固定，访问元素时采用偏移的方法，所以随机位置访问效率较高
                可以用数组表示方法[]访问array元素，有越界检查（越界时直接引起异常）
            vector：template < class T, class Alloc = allocator<T> > class vector; 
                与array类似，也是在内存中使用连续的空间线性存储，所以随机位置访问效率高，不同的是vector大小可变，当空间不够时重新分配一段连续内存并拷贝原来的数据
                vector类的性能优化方法：
                    当预先知道大概会在vector容器中存储几个对象时，可以先定义一个vector对象，然后用成员函数reserve(size_t numberOfElements)方法，避免过多的自动重新分配resize()
                    由于push_back()函数首先调用类构造函数来构造一个临时对象，再用复制构造函数复制这个临时对象到容器中，然后释放这个临时对象，造成浪费，所以使用emplace_back()函数直接就在容器内空间构造来优化性能 
            deque：template < class T, class Alloc = allocator<T> > class deque;
                是双端队列，内部实现可能不同，但是要求在队头和队尾插入和删除元素效率高，通常不能使用一个随机访问迭代器，因为内存分配可能不是连续的空间
                功能上与vector类似，但当队列很大时，vector重新分配整块内存开销很大，而deque开销较小
            forward_list：template < class T, class Alloc = allocator<T> > class forward_list;
                是用单链表实现的，与list类似，也是对插入、删除、移动元素效率较高，只能单向访问（迭代器）
                与list不同，是唯一一个没有size()成员函数的容器
        关联容器：
            set：
            multiset：
            map：
            multimap：
        容器适配器：
            stack：template <class T, class Container = deque<T> > class stack;
                实现栈操作，后入先出，底层实现通常是deque
                成员函数函数：
                    empty();    //返回栈是否为空的布尔值
                    size();
                    top();      //注意这个函数不删除栈顶元素，只是返回栈顶元素的引用
                    push();
                    emplace();  //具有push()的全部功能，而且emplace()可以接受这个桟所储存的对象类型的构造函数所需的参数，然后自动调用这个对象类的构造函数构造新对象并压入栈
                    pop();      //注意这个函数不返回值，直接删除栈顶元素
                    swap();

            queue：
            priority_queue：
        其他：
            pair：
                #include <utility>
                构造函数：
                    pair <type1, type2> name;   //默认构造函数，创建一个长度为0
                    pair <type1, type2> name(value1, value2);   //初始化一个pair类型的对象name，并用type1类型的值value1和type2类型的值value2初始化name
                成员函数：
                    first();    //返回pair对象第一个元素的值
                    second();
            tuple：
                #include <tuple>
                    
    迭代器：
        当使用函数实现某一算法时，由于参数的确定性，就需要为各种数据容器写不同的函数，为了简化，可以将函数写成模板，对容器的访问通过传入迭代器实现，从而将数据结构和算法分开，只为一个算法写一个函数，访问所有支持的容器
        每个STL容器类都定义了一个迭代器，能用某种方式遍历容器中存储的各个元素
        指针也是迭代器的一种
        每个容器类都有begin()和end()方法，分别返回一个指向容器第一个元素和最后一个元素的下一个位置（超尾）的迭代器
        迭代器种类：输入    输出    正向    双向    随机访问
        解除引用读取√       X       √       √       √
        解除引用写入X       √       √       √       √
        正向++     √       √       √       √       √
        反向--     X       X       X       √       √
        随机访问[] X       X        X       X       √
                                                还有加减任意整数来跳跃到前后位置
        定义：由于每个容器类都定义了迭代器，所以迭代器的类型是 容器名<存储的数据类型>::iterator
            vector<int>::iterator a;    //定义了一个存储整形的vector容器的迭代器
            如果希望不能通过迭代器修改容器的值，可以声明只读迭代器：vector<int>::const_iterator a;  //类比const T*
            如果希望不能修改迭代器本身，可以声明常量迭代器：const vector<int>::iterator a;         //类比T* const
    迭代器适配器：
        ostream_iterator:
            #include <iterator>
            声明：ostream_iterator <dataType, outType> out_iter(cout,char c);    //声明了一个输出流迭代器out_iter，参数dataType指定输出的数据类型，outType表示输出流使用的字符类型，一般为char或wchar_t
                参数c表示每个数据后的分隔符
            这个输出流迭代器可以用作copy()的第三个参数，使得可以输出一个容器的指定范围
        reverse_iterator：反向迭代器，对反向迭代器执行递增会使其递减
            vector类定义了rbegin() 返回指向超尾的反向迭代器和rend() 返回指向第一个元素的反向迭代器
    迭代器特性：#include <iterator> http://c.biancheng.net/view/471.html
        对于使用迭代器作为参数的函数模板，存在一个问题，就是我们不知道在调用函数（实例化后）传给形参的迭代器所指的数据的类型
        template<typename Iter>
        void my_swap(Iter a, Iter b)
        {
            ? temp=*a;      //这里temp的类型应该是Iter a解除引用后的数据类型，当然，这里我们可以使用auto
            *a=*b;
            *b=temp;
        }

        然而有时候auto可能不能使用，为了这些情形，可以要求每种迭代器都包含一个公共定义的类型别名，这样就可以在模板函数中使用这些类型别名
        比如要求所有迭代器都定义一个其所指向对象的类型的类型别名value_type
        template<typename Iter>
        void my_swap(Iter a, Iter b)
        {
            typename Iter::value_type temp=*a;      //这里的typename表示Iter::value_type是一个类型，而不是Iter类中的某个静态变量或静态方法名
            *a=*b;
            *b=temp;
        }
        class my_int_iterator   //自定义的一个类，模仿一个迭代器
        {
            typedef int value_type; //将value_type作为我自定义的类的int的别名，这样可以在上面的swap函数中获得这个Iter对象的value_type的类型，这个类型是int
            //...
        }
        然而这种的方法的缺陷是原始指针无法使用，因为原始指针不是类，不包含value_type的定义，为了解决这个问题，C++标准在<iterator>头文件中定义了一套标准类型别名，使得算法既可以用迭代器，也可以用原始指针
            template<typename Iter>
            struct iterator_traits
            {
                typedef typename Iter::difference_type difference_type; //将differnece_type作为模板参数Iter::difference_type的别名
                typedef typename Iter::value_type value_type;
                typedef typename Iter::pointer pointer;
                typedef typename Iter::reference reference;
                typedef typename Iter::iterator_category iterator_category;
            };
            /*下面针对原始指针也提供iterator_traits的偏特化*/
            template<typename T>
            struct iterator_traits<T*>  //T*指针的偏特化iterator_traits
            {
                typedef std::ptrdiff_t difference_type;
                typedef T value_type;
                typedef T* pointer;
                typedef T& reference;
                typedef random_access_iterator_tag iterator_category;
            }
            由于优先匹配的原则，对原始指针实例化的iterator_traits会优先使用偏特化的版本
        这样，对于任何定义了这五种typedef的迭代器，都可以在接受迭代器的算法函数中使用std::iterator_traits<迭代器形参类型>获得相应需要的类型，从而提供统一的获得迭代器的各种类型参数的接口
        所以上面的swap函数可以写成：
        template<typename Iter>
        void my_swap(Iter a, Iter b)
        {
            typename std::iterator_traits<Iter>::value_type temp=*a;
            *a=*b;
            *b=temp;
        }
    自定义迭代器类：
        为了能让自定义的迭代器类兼容既有STL的算法，就应该在其中定义五种typedef
        在<iterator>头文件中定义了一个迭代器模板，包含了这五种typedef的定义，只需在自定义迭代器类中public继承这个类模板，并赋值给相应的模板参数，就可以省去全部重写typedef和名称的麻烦
        template <class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&>
        struct iterator 
        {
            typedef T         value_type;
            typedef Distance  difference_type;
            typedef Pointer   pointer;
            typedef Reference reference;
            typedef Category  iterator_category;
        };
        class my_int_iterator: public std::iterator<std::random_access_iterator_tag, int>
        {...}   //此时my_int_iterator中的value_type为int，pointer为int*, reference为T&, iterator_category为random_access_iterator_tag
    方法：
        #include <algorithm>
        排序：
            排序算法中的函数对象参数comp必须是一个接受两个参数的函数，并返回第一参数<第二参数的真值（或是第一参数在第二参数之前）
            comp函数对象不能修改参数，所以comp的形参可以声明为const引用，或者是可以被复制的值传递类型（比如各种基本类型）
            形参的类型应该是对迭代器解除引用后的类型或者能被隐式转换的类型
            sort()：
                template <class RandomAccessIterator>
                void sort (RandomAccessIterator first, RandomAccessIterator last);
                需要两个迭代器参数，分别是容器的第一个元素和指向超尾的迭代器
                由于指针也是迭代器，所以可以对普通数组运用sort方法
                    const int size=100;
                    double data[size];
                    sort(data,data+size);   //或sort(&data[0],&data[size]);
                sort()函数需要使用<运算符，所以对于自定义结构体、对象，需要sort的话需要定义一个重载<运算符函数
                template <class RandomAccessIterator, class Compare>
                void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
                需要三个参数，最后一个参数是一个自定义比较函数
            partial_sort(): 将从[first,last)中的元素按从小到大的顺序排到[first,middle)中，剩余的元素的顺序未定义
                template< class RandomIt >
                void partial_sort( RandomIt first, RandomIt middle, RandomIt last );

                template< class RandomIt, class Compare >
                void partial_sort( RandomIt first, RandomIt middle, RandomIt last, Compare comp );

                可选参数comp是一个自定义的比较函数
            stable_sort():

            nth_element():将第n个元素（索引n-1）放到正确的位置，并且保证从[first,n-1)的元素都不比[n,last)大
                template< class RandomIt >
                void nth_element(RandomIt first, RandomIt nth, RandomIt last );

                template< class RandomIt, class Compare >
                void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp );
            sort_heap():
            inplace_merge():
            is_sorted():
            is_sorted_until():
        查找：
            accumulate():求从[first,last)的和
#include <numeric>
                template< class InputIt, class T >
                T accumulate( InputIt first, InputIt last, T init );    //使用元素的operator+

                template< class InputIt, class T, class BinaryOperation >
                T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );    //使用一个接受两个参数的函数
                函数的原型需符合：returnType fun(const Type1& a, const Type2& b);   //不一定需要const&限定，但T需要可以被隐式转换为Type1和Type2
            equal():
                比较从[first1,last1)的元素是否与[first2, first2+(last1-first1-1) )的相同
                如果first2迭代器所指向的容器的元素比first1的多，则只比较与first1到last1相等个数的元素
                如果first1迭代器所指向的容器元素比first2的多，一定返回false
                template <class InputIterator1, class InputIterator2>
                bool equal (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
                相当于：
                {
                    while(first1 != last1)
                    {
                        if(*first1 != *first2)
                            return false;
                        ++first1;
                        ++first2;
                    }
                }
            advance(InputIterator& it, Distance n)
                将迭代器it向前推进n个元素的位置
                如果it是随机存取迭代器，函数直接用迭代器运算+或-，否则用++或--移动n次
        复制：        
            copy()方法需要三个迭代器参数，第一和第二个迭代器参数指向源的范围（包括第一参数，而不包括第二参数），第三个迭代器参数指向目的地
            copy_backward()
        裸内存：
            尚未构造内部元素的容器（只定义了大小，用默认构造函数构造内部元素），可以就地构造增加性能
            #include <memory>
            uninitialized_fill()
            uninitialized_copy()
            uninitialized_move()
        值修改：
        remove()：需要2个迭代器参数，第3参数为需要remove的值，容器中等于第3参数的值被remove，容器中多余的空间是未定义的值
            返回一个指向最后一个有效值的迭代器，所以应该用erase()方法删掉后面的值
        distance()：
            template< class InputIt >
            typename std::iterator_traits<InputIt>::difference_type distance( InputIt first, InputIt last );
            返回从first迭代器到last迭代器需要++（向前迭代）的次数
            从C++11开始，如果迭代器是随机访问迭代器，则当可以从first通过--（向后迭代）到达last迭代器时（此时last在位置上比first前）返回--操作的次数
        unique()方法需要两个迭代器参数，分别是容器的第一个元素和指向超尾的迭代器，返回的迭代器指向最后一个不重复的元素的下一个元素（超尾元素）
            所以包含的不重复元素的个数是容器起始位置的迭代器-unique返回的超尾元素
            应当在使用unique方法用resize()函数后对容器重新调整大小，所以这个容器包含的都是不重复的元素
            resize(distance(容器.begin,unique返回的迭代器))
            使用unique方法前需要保证数组有序，所以无序容器需要先sort()
            如：1 2 99 99 99 -1 -2 99 0 1
                1 2 99 -1 -2 99 0 1 X X 最后两个X是未定义的值，与remove()相同也应该对容器使用erase()方法
        merge()方法需要五个迭代器参数，第一和第二个是第一个容器的头尾迭代器，第三和第四个是第二个容器的头尾迭代器，最后一个迭代器指向合并后输出的迭代器
        fill()：需要两个迭代器参数，将[first,last)的范围用value填满
            template< class ForwardIt, class T >
            void fill(ForwardIt first, ForwardIt last, const T& value)
        fill_n()：需要1个迭代器参数，从first开始的连续n个元素填充为value
            template< class OutputIt, class Size, class T >
            void fill_n( OutputIt first, Size count, const T& value );
    for_each()循环:
        #include <algorithm>
    transform():
        template <class InputIterator, class OutputIterator, class UnaryOperation>
        OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op);
            将函数op作用于[first1, last1)区间的所有元素，并将输出结果保存到result迭代器所指的容器中，函数op应该接受一个InputIterator解除引用后的类型的参数，并返回一个OutputIterator解除引用的类型的值
        template <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>
        OutputIterator transform (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);
            与上面类似，函数op接受两个参数，分别是InputIterator1和InputIterator2解除引用后的参数，并返回一个值
    Allocator 分配器：
    函数符（函数对象）：是可以以函数方式与一对圆括号()结合使用的任意对象，包括函数名、函数指针和重载了()运算符的类对象（即定义了operator()函数的类）
        生成器：不用参数就可以调用的函数符
        一元函数：用一个参数就可以调用的函数符，可以作为for_each()的第三个参数
        二元函数：用两个参数可以调用的函数符
        返回bool的一元函数是谓词
        返回bool的二元函数是二元谓词，可以作为sort()方法的第三个参数


RTTI:运行阶段类型识别
    dynamic_cast运算符：只能用于继承体系，不能用于改变常量性
        将指针pt转化为指向类型为Type的指针并返回，若不安全或不能转化，则返回空指针
        (Type *)base_ptr=dynamic_cast<Type *>derived_pt; //将derived_pt指针的类型转化为Type*，并赋值给base_ptr指针 
        也可将引用ref转化为类型为Type的引用，若不成功或不能转化，抛出异常
        Type& base_ref=dynamic_cast<Type&>derived_ref;
        常用于将指向派生类对象的指针转化为基类的指针，来调用虚方法，也可以将new分配的派生类对象结果赋值给了基类指针或引用，再转换回派生类指针或引用
    typeid运算符：比较两个表达式的类型是否相同，返回一个type_info类对象的引用
        #include <typeinfo>
        typeid(className)==typeid(*ptr);    //比较ptr所指向的对象的类型是否为className
        typeinfo的对象包含一个name()成员，该函数通常返回一个字符串：这个表达式的类型（通常是类）的名称
            typeid(className).name();   //返回"className"
    static_cast运算符：与dynamic_cast不同的是当且仅当expression能转换为typeName类型或typeName能转换为expression的类型才进行转换
        static_cast <typeName> (expression)
        static_cast与旧式C风格类型转换的能力基本相同
        可以用static_cast将非const转换为const，单不能将const转换为非const
    const_cast运算符：将const变非const或非const变const
        假设有const Type *const_ptr;
        (Type *)ptr=const_cast<Type *>const_ptr;    //将声明为常量的Type*类型指针转化为非常量，这样可以通过ptr修改数据
        反向转换同理，然而非const变const简单方法就是声明一个const类型引用指向非const，然后用这个const引用
    reinterpret_cast运算符：用于天生危险的转换（例如毫不相关类型的转换）
        reinterpret_cast <typeName> (expression)
        常用于函数指针的转换，因为这种类型转换是安全的，比如将一个不同参数和返回值类型的函数赋值给类型不同的函数指针
        typedef void (*FuncPtr)();  //定义了一个函数指针类型FuncPtr，这个类型的函数指针指向无参且返回值为空的函数
        FuncPtr funcPtrArray[10];
        int somefunc();
        funcPtrArray[0]=reinterpret_cast<FuncPtr>(&somefunc); 
        这个类型转换运算符几乎总是与编译平台有关，所以不具有移植性
    可以用std::is_same<type1, type2>在模板函数中判断类型type1与type2是否相同
        #include <type_traits>
        template<typename T>
        void func()
        {
            if(is_same<T, int>::value)
            //...
        }
string类：C++标准类
    #include <string>
    template<class charT, class traits=char_traits<charT>, class Allocator=allocator<charT>>
    class basic_string {...}
    basic_string是一个模板类，其中模板参数charT指定字符串中字符的类型，traits是一个类，定义了字符串类型必须具备的特征（方法、成员）
    有4种预定义的初始化：
    typedef basic_string<char> string;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
    typedef basic_string<wchar_t> wstring;
    构造函数：
        string(const char *s)               //用一个C风格字符串初始化一个string对象
        string(size_type n, char c)         //size_type是一个依赖于实现的整形，用n个字符c初始化一个string对象
        string(const string & str)          //复制构造函数
        string()                            //默认构造函数，创建一个长度为0 string对象
        string(const char *s, size_type n)  //将对象初始化为s所指向的C风格字符串的前n个字符
    方法：
        begin() 指向字符串第一个字符的迭代器
        cbegin() 指向字符串第一个字符的输入迭代器（只读）
        end() 指向超尾的迭代器
        cend() 指向超尾的输入迭代器（只读）
        rbegin() 指向超尾的反向迭代器
        crbegin()
        rend() 指向第一个字符的反向迭代器
        crend()
        size() 返回字符串中的元素数，等于begin()到end()之间的距离
        length() 与size()相同
        capacity() 给字符串分配的元素数，可能大于实际的字符数，capacity()-size()的值表示在字符串末尾附加多少字符后需要分配更多内存
        max_size() 字符串的最大长度
        data() c_str() 这两个方法都返回指向第一个字符的const char*指针，故不能通过这个指针修改数据，c_str()指向的数组以'\0'空字符结束，data()不一定
        find():
            size_type find(const basic_string& str, size_type pos=0) const noexcept;  //搜索从第pos个字符（pos从0开始）起第一次出现str字符串（子串）的位置（匹配的第一个字符的索引），如果没找到，返回string::npos
            size_type find(const charT* s, size_type pos=0) const;  //与上条功能相同，参数s是个c风格字符串
            size_type find(const charT* s, size_type pos, size_type n) const;     //搜索从第pos个字符起第一次出现s所指的C风格字符串的前n个字符（n从1开始）的位置
                这个方法与先用构造函数string(const char *s, size_type n)用s所指的字符串的前n个字符构造成一个string对象a，再对被查找的字符串调用find(a,0)的效果完全相同
            size_type find(charT c, size_type pos=0) const noexcept;    //搜索从第pos个字符起第一次出现字符c的位置
        rfind(): 与find()使用方法相同，返回pos之前最后一次出现相应字符串或字符的位置，默认参数npos表示一个size_type最大值，表示默认从字符串最结尾开始往前找
            size_type find(const basic_string& str, size_type pos=npos) const noexcept;     //搜索从第pos个字符往前找第一次出现str字符串的位置
            size_type find(const charT* s, size_type pos=npos) const;
            size_type find(const charT* s, size_type pos, size_type n) const; 
            size_type find(charT c, size_type pos=npos) const noexcept;
        find_first_of()：查找从被搜索字符串的pos位置开始第一次出现str，s所指的字符串中任何一个字符的位置
            size_t find_first_of (const string& str, size_t pos = 0) const noexcept;
            size_t find_first_of (const char* s, size_t pos = 0) const;
            size_t find_first_of (const char* s, size_t pos, size_t n) const;  //被搜索的字符串中在pos之后第一次出现s所指的字符串的前n个字符中的任意一个字符的位置	
            size_t find_first_of (char c, size_t pos = 0) const noexcept;   //与find(c,pos)相同
        find_last_of()：查找从被搜索字符串的pos位置之前最后一次出现str,s所指的字符串中任何一个字符的位置
            size_t find_last_of (const string& str, size_t pos = npos) const noexcept;
            size_t find_last_of (const char* s, size_t pos = npos) const;
            size_t find_last_of (const char* s, size_t pos, size_t n) const;
            size_t find_last_of (char c, size_t pos = npos) const noexcept;
        find_first_not_of()：查找被搜索的字符串中pos位置之后的第一次出现不是str，s所指的字符串中的字符的位置
            size_t find_first_not_of (const string& str, size_t pos = 0) const noexcept;
            size_t find_first_not_of (const char* s, size_t pos = 0) const;
            size_t find_first_not_of (const char* s, size_t pos, size_t n) const;
            size_t find_first_not_of (char c, size_t pos = 0) const noexcept;
        find_last_not_of()：查找被搜索的字符串中pos位置之前最后一次出现不是str，s所指的字符串中的字符的位置
            size_t find_last_not_of (const string& str, size_t pos = npos) const noexcept;
            size_t find_last_not_of (const char* s, size_t pos = npos) const;
            size_t find_last_not_of (const char* s, size_t pos, size_t n) const;
            size_t find_last_not_of (char c, size_t pos = npos) const noexcept;
        compare()：	比较调用字符串和参数字符串，如果调用字符串的第一个比参数字符串的不同字符的ascii值大，返回1，否则返回-1
            如果调用字符串或参数字符串其中一个比完了，调用字符串短，返回-1，否则返回1
            如果都相同，返回0
            string s1="apple", s2="ban", 则s1.compare(s2)返回-1
            int compare (const string& str) const noexcept;	
            int compare (size_t pos, size_t len, const string& str) const;  //只使用调用字符串从pos开始的连续len个字符比较
            int compare (size_t pos1, size_t len1, const string& str,size_t pos2, size_t len2) const;//只使用调用字符串从pos1开始的len1个字符的子串和参数字符串从pos2开始的len2个字符的子串进行比较
            int compare (const char* s) const;  //参数字符串是一个C风格字符串
            int compare (size_t pos, size_t len, const char* s) const;  //只使用调用字符串从pos开始的len个字符串与s所指的字符串比较
            int compare (size_t pos, size_t len, const char* s, size_t n) const;    //注意这个函数没有pos2参数，只使用调用字符串从pos开始的len个字符串与s所指的字符串的前n个字符比较
        operator+=()：把string字符串，字符，或C风格字符串追加到调用字符串的后面，如果得到的字符大于最大字符串长度，将引发length_error异常
        operator+()：创建一个新字符串，新字符串是将右操作数（第二字符串）追加到左操作数（第一字符串）构造的
            可以将字符串与字符串、字符串与C风格字符串、字符串与字符相加
        append():
            string& append (const string& str);
            string& append (const string& str, size_t subpos, size_t sublen);	//追加字符串str从subpos位置开始的连续sublen个字符
            string& append (const char* s);	
            string& append (const char* s, size_t n);   //追加s所指的字符串的前n个字符
            string& append (size_t n, char c);  //追加n个c字符
            template <class InputIterator>
            string& append (InputIterator first, InputIterator last);   //追加迭代器first到last所指容器的内容
        assign()：将整个字符串、字符串的一部分或相同字符组成的字符串赋给string对象
            basic_string& assign(const basic_string& str);
            basic_string& assign(basic_string&& str);   //移动语义
            basic_string& assign(const basic_string& str, size_type pos, size_type n);  //将字符串str从pos开始的n个字符赋值调用字符串
            basic_string& assign(const charT* s, size_type n);  //将s所指向的C风格字符串的前n个字符赋值给调用字符串
            basic_string& assign(const charT* s);
            basic_string& assign(size_type n, charT c);     //将n个字符c赋值给调用字符串
            template<class InputIterator>
                basic_string& assign(InputIterator first, InputIterator last);
        insert()：将字符串、C风格字符串或几个字符插入到调用字符串中
            下面方法如果pos1超过了调用字符串的结尾，或者pos2超过了要插入的字符串的结尾，将引发out_of_range异常
            basic_string& insert(size_type pos1, const basic_string& str);  //将字符串str插入到调用字符串pos位置字符的前面（左边）
            basic_string& insert(size_type pos1, const basic_string& str, size_type pos2, size_type n); //将字符串str从pos2字符开始的连续n个字符插入到调用字符串pos位置字符的前面
            basic_string& insert(size_type pos, const charT* s, size_type n);   //将s所指的C风格字符串的前n个字符插入到调用字符串pos位置字符的前面
            basic_string& insert(size_type pos, const charT* s);
            basic_string& insert(size_type pos, size_type n, charT c);
        erase()：
            basic_string& erase(size_type pos=0, size_type n=npos); //从pos开始删除n个字符（默认参数npos表示一直删除到字符串尾部）
            void pop_back();    //删除字符串中的最后一个字符
        replace()：替换字符串指定的部分
            basic_string& replace(size_type pos1, size_type n1, const basic_string& str);   //将调用字符串从pos1开始的连续n1个字符替换为str的内容
            basic_string& replace(size_type pos1, size_type n1, const basic_string& str, size_type pos2, size_type n2); //将调用字符串从pos1开始的连续n1个字符替换为str从pos2开始的连续n2个字符，如果n2大于字符串str的长度，将产生npos异常
            basic_string& replace(size_type pos1, size_type n1, const charT* s, size_type n2);   //将调用字符串从pos1开始的连续n1个字符替换为s所指的C风格字符串从开始的连续n2个字符
            basic_string& replace(size_type pos1, size_type n1, const charT* s);
            basic_string& replace(size_type pos1, size_type n1, size_type n2, charT c); //将调用字符串从pos1开始的连续n1个字符串替换为n2个字符c
        copy():
            size_type copy(charT* s, size_type n, size_type pos=0) const;   //将调用字符串从pos开始的连续n个字符复制到s所指的内存空间，如果调用字符串到达末尾则停止复制，函数返回复制的字符数，该方法不检查s的空间是否足够，也不追加结尾空字符'\0'
        swap()：使用一个时间恒定的算法来交换两个string对象的内容
            void swap(basic_string& str);
    stringstream字符串流
        #include <sstream>
        stringstream类继承自iostream类，所以继承了iostream类的所有方法
        注意，stringstream类当完成了一次>>输出后，会将eof置1，此时不可再向stringstream对象输入，否则会引起failbit和badbit置1，应当使用clear()成员方法清空eof位
            float b{ 3.14 };
            stringstream ss;
            ss << b;
            ss << "abcd";       //可以多次向同一个stringstream对象输入数据
            if (ss.eof())
                cout << "eof";
            if (ss.fail())
                cout << "fail";
            if (ss.bad())
                cout << "bad";
            if (!ss)
                cout << "!";
            string s;
            ss >> s;            //此时eof置1，不可再继续输入
            cout << endl;
            if (ss.eof())
                cout << "eof";
            if (ss.fail())
                cout << "fail";
            if (ss.bad())
                cout << "bad";
            if (!ss)
                cout << "!";
            ss << "abcd";       //此时"abcd"字符串并没有输入到ss中，而且eof、badbit、failbit都置1，且重载的!操作符返回true
            cout << endl;
            if (ss.eof())
                cout << "eof";
            if (ss.fail())
                cout << "fail";
            if (ss.bad())
                cout << "bad";
            if (!ss)
                cout << "!";
        常见应用：类型转换
        成员方法：
            string str() const;         //返回一个字符串，是当前stringstream内容的拷贝
            void str(const string& s);  //丢弃当前stringstream的内容，并将s的值拷贝进stringstream内，常用于调用str("")的方法来释放内存
    string_view
        由于string的构造在大多数情况下需要分配堆区内存，而且在使用string的大多数情况下只是需要获取其中的内容，所以大多数情况下可以避免新创建一个string，C++17以前可以通过char数组来解决，但是损失了string的灵活接口
        string_view是这样的一个类，他只包括一个指向所需string部分内容的起始的指针，和一个大小，所以他无需构造新string
        string_view有所有的string只读的常用方法

<chrono> C++11:
    所有的chrono函数都在std::chrono名称空间内
    1.时间段：
        seconds类：
            class seconds
            {
                int64_t sec_;   //或long long
                ...
            }
            默认构造函数：sec_赋值为0
            构造函数为explicit，不能从int隐式转换为seconds类
                seconds s=3;  //错误，应为seconds s(3)或统一初始化方法{3}
            重载的各种算数运算符：
            重载的各种比较运算符：
            范围：用seconds::min()和seconds::max()返回，通常为+-2920亿年
            输出：count()成员函数返回成员变量sec_的值，然后用cout<<s.count();输出
        milliseconds类：
            与seconds类相同
            范围是2920万年
            允许从seconds类到milliseconds类的隐式类型转换（由于这是不损失精度的转换），但不允许从milliseconds到seconds的隐式类型转环
        hours类：
        minutes类：
        microseconds类：
        nanoseconds类：
    所有时间段类都重载了6中比较运算符
    所有时间段类都重载了+-*/运算符
    2.duration_cast<type>函数
        将不允许隐式类型转换的转换（损失精度的转换）用向下取整的方式转换
        只有当隐式类型转换不允许时才用duration_cast<type>函数
        如seconds s=duration_cast<seconds>(milliseconds(3400));   //s=3s
    3.自定义内部数据类型
        如果默认采用long long成员类型的seconds类占空间过多，可以用chrono的duration模板来建立自定义的内部数据类型，如：
            using seconds32=chrono::duration<int32_t>  //使用32位整形来创建seconds类，然后用using声明来声明类型别名
        如果要对其他类型（milliseconds类...）也使用自定义的数据类型，格式为：
            using alias=duration<type, ratio>   //将alias作为duration模板类的别名，其中第一参数type是要自定义内部数据类型的类型，ratio是其他时间段类相对于标准seconds的比例，已经预定义为nano, milli, micro
                using nano=ratio<1,1'000'000'000>;
                using micro=ratio<1,1'000'000>;
                using milli=ratio<1,1000>;
            对于minutes类和hours类，没有预定义名称，所以显示使用ratio模板来定义：
                ratio<60>
                ratio<3600>
            所以using seconds32=chrono::duration<int32_t>声明又可以写为：using seconds32=chrono::duration<int32_t, ratio<1>>
            std::ratio类是一个表示比例的模板，第一模板参数N表示分子，第二模板参数D表示分母
                template<intmax_t N, intmax_t D=1> class ratio;
                ratio类包含两个静态成员常量num和den，分别表示化简后的分子和分母，比如ratio<2,10>::num==1, ratio<2,10>::den==5
        所有的时间段类都是以下形式的实例化：
        template<typname Type, typename Period=ratio<1>> //模板参数Period的默认参数时ratio<1>，所以自定义seconds类时不需要ratio参数
        class duration
        {
            Type rep_;   //自定义的内部数据类型
        public:
            using rep = Rep;        //两个using声明的类型别名
            using period =Period;
        }
        由于duration模板类中用using定义了类型别名，所以可以通过提取duration模板类的实例中的数据类型
            milliseconds::rep a; //int64_t a;
            milliseconds::period::num //1
            milliseconds::period::den //1000
    4.通用化时间段单位
        可以通过ratio模板参数来控制一个自定义时间段的长度
        using frame_time=duration<float, ratio<1,60>>   //将1/60秒作为一个frame_time类
    6.时钟类
        时钟类是联系一个时间点（表示这个时钟的绝对时间原点）和时间段长度（表示计时精度）的一个数据结构
        一个通用的时钟类的表达：
        struct some_clock
        {
            using duration = chrono::duration<...>
            using rep = duration::rep;
            using period = duration::period;
            using time_point = chrono::time_point<some_clock>;
            static constexpr bool is_steady = false;
            static time_point now() noexcept;
        };
        system_clock: 表示系统时间
            静态成员函数：
                time_point now()                            //返回一个当前时间的time_point<system_clock, nanoseconds>对象，即now是用纳秒做单位的
                time_t to_time_t(const time_point& tp)      //将tp表示的时间点转换为time_t类型
                time_point from_time_t(time_t t)            //将t表示的时间转换为一个时间点
        steady_clock:
            静态成员函数：
                time_point now()
        以上两个时钟的区别在于system_clock可以手动更改，比如直接在系统时间设置内修改，所以可能会两次得到的时间与实际程序运行的顺序不同（时间倒流），但是system_clock可以表示实际的日历时间
        而steady_clock一定以稳定的速率前进，一定与程序运行的顺序关联，所以要度量一段时间的话最好采用steady_clock
        high_resolution_clock通常是system_clock或steady_clock的其中之一的类型别名
    5.时间点
        时间点与时间段的内部实现可能类似，但时间点表达的是某个具体时刻
        对于一个时间点，肯定需要一个另一个时间点做参考，然后计算从参考点开始到这个时间点之间的时间段，才能得出这个时间点
        所以时间点需要两个模板参数，第一个模板参数是时钟的类型表示计时原点，第二个模板参数是时间段的类型，所以时间点的意义由Duration控制，时间点的原点由Clock控制
        template<class Clock, class Duration=typename Clock::duration>
        class time_point
        {
            Duration d_;
        public:
            using clock=Clock;
            using duration=Duration;
            //...
        }
        成员函数：
            duration time_since_epoch() const;  //返回从Clock的原点到内部Duration d_所记录的时间段之间的时间段
        构造函数：
            默认构造函数：

        重载了各种操作符：
            两个时间点可以相减，结果是一个时间段 duration
            一个时间点可以与一个时间段相加，结果是一个新时间点 time_point
            两个时间点不能相加，因为没有意义
        转换函数：
            两个使用不同时钟（不同计时原点）的时间点不能转换，使用同一个时钟的可以转换，如果转换不损失精度，可以隐式转换，如果损失精度，需要显式转换
            template<class ToDuration, class Clock, class Duration>
            constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t)   //constexpr C++14
    7.暂停程序：
        std::this_thread::sleep_for(duration<type> t)   //参数是一个时间段
        
<random>C++11
    1.随机数生成引擎 random engine
        随机数引擎是一种状态机，状态决定所生成的随机数，所以如果状态一样，生成的随机数也一样
        随机数引擎生成的随机数的最小和最大值不能更改
        std::default_random_engine
        std::mt19937（推荐）
        构造函数：接受一个无符号整形数参数作为随机数种子（通常可以用chrono::steady_clock::now().time_since_epoch().count()作为随机数种子）
        成员函数：
            min()
            max()   //返回当前随机数生成引擎的所生成的随机数的最大最小值
            operator()  //生成一个随机数
            seed(unsigned int seed)   //用seed作为引擎的随机数种子
            operator==(const default_random_engine& e2)    //比较两个随机数引擎的状态是否相同
        非成员函数：
            operator<< 通常用于保存当前引擎的状态
            operator>> 通常用于从保存了当前引擎状态的stringstream恢复之前的状态
    2.随机数分配器
        std::uniform_int_distribution<int>  //int是缺省模板参数，C++17后可省略<int>
            构造函数：接收两个整数参数int a, int b，产生范围是[a,b]的随机分布的整数
            成员函数：
                operator(engine& e) //用随机引擎e生成一个随机数
        std::uniform_real_distribution<double>
            构造函数：接收两个double参数double a, double b，产生范围是[a,b)的随机分布小数
            
范围for循环
    double a[5]={...};
    for(double x:a) {...}
    for循环的圆括号内声明一个与容器存储内容的类型相同的变量，后跟冒号和容器名，花括号内的语句用这个声明的变量一次访问容器中的各个元素
    不同于for_each循环，for循环可以在括号内声明一个引用参数来修改容器存储的值
    常用auto或auto& 来声明循环变量的类型
    范围for循环适用于任何带有begin(), end()方法的类
    注意begin()和end()方法应该返回一个迭代器类型（包括指针）
    工作原理：
    for(range_declaration : range_expression)
    {
        ... 
    }
    与下面的普通for循环完全等价
    {
        auto&& range=range_expression;  //注意这里的range由于用auto&&声明，所以是一个通用引用，可以是左值引用也可以是右值引用
        for(auto b=beginExpr, e=endExpr; b!=e; ++b)
        {
            range_declaration=*b;
        }
    }
    这里的beginExpr和endExpr分为三种情况：
        1）若range_expression是一个普通数组类型，则beginExpr为range，endExpr为range+数组大小
        2）若range_expression是一个带有begin()和end()方法的类，则beginExpr为range_expression.begin()，endExpr为range_expression.end()
        3）不满足上述两种情况的，在当前名称空间内查找begin(range)和end(range)函数
            如果range是一个内置类型，则在std名称空间中查找
            所以可以在一个range_expression类中不定义begin和end方法，而在类外定义一个函数或函数模板叫begin end，接受一个这个类的对象
C++11:
    新类型：
        longlong, unsigned longlong 64位整形
        wchar_t的字面值用L做前缀：wchar_t title[]=L"something"; 一个wchar_t占用2字节
        char16_t的字面值用u做前缀，表示UTF-16
        char32_t的字面值用U做前缀，表示UTF-32
    用户定义字面值：
        字面值是一种常量
        C++自带的四种字面值：整数、浮点数、字符、字符串
        定义用户字面值函数的格式：
            returnType operator"" _标识符(paraType para){...}
        对应的字面值变量的声明：
            returnType 变量名=para_标识符;
        标识符一定是以下划线开头的名称，字面值是以数值+相应标识符后缀组成，实际的值由字面值函数（将值代入形参para）计算的返回值确定
        假如有字面值函数：long double operator"" _cm(long double x){return x*10;} 
        则有：long double height=3.4_cm;  //long double height=34;
        也有接收两个参数的字面值函数，第二个参数一定是size_t类型，此时的字面值都是常量字符指针类型，所以第二参数的值是这个字面值字符串的长度
        字面值的形参只能是以下的类型：
            char const* (常量字符指针，C风格字符串)
            unsigned long long
            long double
            char const*, size_t
            wchar_t const*, size_t
            char16_t const*, size_t
            char32_t const*, size_t

    统一的初始化：
        初始化的类型：
            默认初始化 default initialize：不给定初始化的值，对于内置类型，其值是未定义的，访问这样的变量造成未定义行为，对于类，将调用默认构造函数
                int a;
            复制初始化 copy initialize: 由赋值符=开始的初始化，按值传递的函数参数，返回值的函数
                int i=2;
                int square(int i);  //形参i和返回值都是复制初始化
                当复制初始化的类型不符时，会发生可能的类型转换
            聚合初始化 aggregate initialize: 发生在(聚合)结构体、数组的初始化赋值时
                int i[4]={0,1,2,3};
                struct Foo
                {
                    int i,j;
                };
                Foo foo={1,2};
                当初始化器的个数少于成员个数时，结构体或数组剩余的成员将用0值初始化
                    Foo foo2={1};   //foo.j==0
                当聚合体嵌套聚合体时，初始化器将按顺序初始化聚合体中的元素，嵌套的大括号可以省略
                    struct Bar
                    {
                        Foo f;
                        int k
                    };
                    Bar b={1,2};    //Equivalent to Bar b={{1,2},0};
            直接初始化 direct initialize: 使用圆括号()的初始化器
                Foo foo(1,2);
                int i(3);
                auto* foo_ptr = new Foo(2,3);
                直接初始化与复制初始化的区别：
                    1.对于内置类型，没区别
                    2.对于类，直接初始化能接受多于一个的参数，将使用重载函数的语法来调用合适的构造函数
                由于使用圆括号，直接初始化会造成解析问题，最常见的问题是声明了一个函数而不是进行初始化
                    struct Foo{};
                    struct Bar
                    {
                        Bar(Foo);   //使用一个Foo对象来初始化Bar
                    }；
                    Bar bar(Foo()); //本意是使用一个临时的Foo对象来初始化一个bar，但是C++将解析成声明了一个返回Bar的函数bar()，这个函数接受一个返回Foo的函数作为参数
            值初始化 value initialize: 使用空的圆括号()的初始化器
                int i()=int();    //int i=0;
                如果有用户定义的默认构造函数，调用默认构造函数，如果没有，将用0值初始化
                所以C++11后一个类如果使用=default编译器生成的默认构造函数，由于它不是用户定义的，所以将使用0值初始化类内成员
                    struct A
                    {
                        A()=default;
                        int i;
                    };  //调用A()将使得i=0
                注意，如果在类外使用default定义默认构造函数，这个函数将属于用户定义的，尽管定义是编译器生成的，所以不会使用0值初始化类内成员
                    struct A
                    {
                        A();
                        int i
                    };
                    A::A()=default; //调用A()将使得i的值不确定
            列表初始化 list initialize: 使用用花括号{}的初始化器
                直接列表初始化 direct list initialize: 不使用赋值符=
                复制列表初始化 copy list initialize: 使用赋值符=，形式上与聚合初始化相同，但聚合初始化不调用构造函数
                   {}初始化规则：
                    当一个结构体或类没有定义接收std::initializer_list的构造函数时，使用{}与()初始化作用相同
                    当定义了默认构造函数和std::initializer_list构造函数，但实参是空的花括号初始化器时，调用默认构造函数
                    当定义了接收std::initializer_list的构造函数时，编译器会高优先级选中这个构造函数，除非这个std::initializer_list的参数类型完全无法与实参匹配
                    struct Widget
                    {
                        Widget(std::initializer_list<long double>);
                        float operator();   //Widget -> float的转换函数
                    };
                    Widget w1;
                    Widget w2(w1);  //复制构造函数
                    Widget w3{w2};  //w2转换为float，强制转换成long double再调用Widget(std::initializer_list)构造函数
                    编译器选中std::initializer_list的优先级是如此之高，以至于在发生精度损失的情况下都要选中，又由于{}初始化不能精度损失赋值，所以会发生编译器错误
                    struct Widget
                    {
                        Widget(int i, bool b);
                        Widget(std::initializer_list<bool>);
                    };
                    Widget w{10,5.0};   //调用Widget(std::initializer_list<bool>)，发生精度损失，所以错误
            委托初始化 C++20 designated initialize: 是聚合体初始化的变种，可以在花括号内用句点.加成员名的方式初始化成员
                与C相似，但不同的是成员顺序必须一致（可以跳过某些成员，跳过的使用0值初始化），不能混合其他初始化方法（所有成员都要用委托初始化），不能对数组使用
                    struct Foo
                    {
                        int a,b,c
                    };
                    Foo foo{.a=1, .c=3};    //.b=0
                    Foo foo{.a=3, 2};       //混合其他初始化方法，Error

        C++11前（C++98 C++03）：
            int i1;     //未定义的值
            int i2=0;   //内置类型的C风格初始化，注意不是赋值运算符
            int i_arr[]={1,2,3};    //内置类型的C风格数组初始化
            class A_int{public: A(int v){} }; A_int a(1);   //圆括号的对象构造函数初始化
            于是对于内置类型也增加了原本用于对象的圆括号初始化
            int i3(4);      //后增加的圆括号初始化
            int i4=int();   //后增加的圆括号默认值初始化，i4=0
            注意，不能int i4() 因为这是声明一个函数
            不要用圆括号初始化一个变量，因为只要是圆括号内没有参数，就会被认为声明了一个函数
        这产生了一个问题，由于存在typedef类型别名，无法知道这是一个内置类型（可以用圆括号、赋值符）或是类（可以用圆括号）或是数组（可以用花括号）
        C++11后：
            用花括号列表初始化所有内置类型、用户定义类型（类、结构体），初始化列表可以加=号，也可以不加
            用花括号初始化方法如果有赋值缩短（赋值的范围超过变量的类型所能存储的范围）或精度损失，将产生编译错误
            对内置类型的花括号初始化，如果没有参数，将初始化为默认0以及可能被转换为0的值，如布尔值被默认初始化为false
            bool b{};   //b==false
            对结构体初始化，将按顺序线性初始化，如：
            struct A
            {
                int a;
                char b[2];
            };
            A a{1,2}; //a.a=1,a.b[0]=2,a.b[1]=0;
            初始化列表可以用作函数参数，要包含头文件
            #include <initializer_list>
            returnType func(std::initializer_list<type> para)
            {
                //函数中使用类似容器和迭代器的方法
            }
        最佳选择：
            默认构造时，不使用初始化器
            默认使用{}初始化器直接初始化
            当定义了std::initializer_list的时候谨慎使用，如果不是想调用这个构造函数，使用圆括号()初始化
        与auto关键字合用的特殊情况：
            auto i5{5};     //C++11: std::initializier_list<int>, C++14: int
            auto i6={6};    //std::initializer_list<int>
        所以最好不要将auto = {} 连用，最好不要在花括号初始化里用=
            auto i7=int{7}  //i7=7
    auto关键字：根据显式初始化所赋值的类型自动判断变量的类型
        auto x{initializer};
        当需要显式指明一个类型时 auto x=type{initializer};
    std::enable_if：
        C++11引入一个概念SFINAE (substituion failure is not an error)匹配失败不是错误，意思是当编译器根据函数调用来实例化模板函数时，可能会有几个函数模板在推导模板参数时无法编译通过，但只要有一个可以正确推导出来，就不会产生编译错误
        enable_if与函数模板和type_traits配合，可以实现这个目的，让只满足特定要求的模板函数的调用才能让模板函数实例化，不满足要求的调用就阻止函数模板实例化
        enable_if是一个模板结构体，一个可能的实现：
            template<bool b, typename T=void>
            struct enable_if{};

            template<typename T=void>
            struct enable_if<true, T=void>
            {
                typedef T type;
            }
        第一个是通用模板，第二个是部分具体化后的模板，所以当模板参数b为false时将匹配通用模板，此时这个结构体为空，当模板参数b为true时，按优先原则将匹配第二个部分具体化后的模板，这个模板内将类型type作为模板参数T的别名
        例如想要一个模板函数在形参为整数时才实例化，而且返回TYPE类型，可以
        template<typename T>
        typename std::enable_if<std::is_integral<T>::value, TYPE>::type func(T a) {...}
        根据enable_if的模板定义，当形参T的类型是整数时，is_integral<T>的value为true，所以type的值就是TYPE，如果不指定TYPE，则根据定义，type的值是void
        当形参T的类型不是整数时，is_integral<T>的value为false，所以与enable_if的第一个通用模板匹配，此时这个结构体中没有定义type，所以编译出错，函数不会实例化
    constexpr关键字：
        constexpr值：
            定义对象（包括内置类型）
            定义静态数据
                对于常量，constexpr声明的变量需要一个初始化器，所以允许类内静态常量的初始化，旧标准的类中静态常量成员需要类内声明类外定义
                class A
                {
                    static const int a;
                    static constexpr b=10; 
                };
                A::a=3;
            定义字面值
        constexpr计算：
            定义函数
                constexpr还可以作用于函数，使得函数成为一个常量表达式，在编译期就调用并计算结果
                所以被声明为constexpr的函数调用必须能在编译期被计算为常量
                由于函数调用成为了常量表达式，所以可以用作数组的大小
            定义构造函数

    static_assert(布尔常量表达式,"消息")：在编译期进行的断言检查
        当表达式为false时，在编译期中编译期会发出错误，错误内容是消息字符串
    decltype关键字：将y声明为与表达式x的类型相同
        decltype(x) y;
        C++14：当decltype()与auto连用时分为两种情况
            用decltype(auto)声明变量的类型时，变量需要被立即初始化（就是必须定义赋值），此时所声明的变量的类型是用初始化的值替换auto关键字所得的decltype
                即：decltype(auto) 变量名=初始化值; 相当于 decltype(初始化值) 变量名=初始化值;
            用decltype(auto)声明函数的返回值类型时，与声明变量的情况类似，相当于将返回语句替换掉auto关键字
                即：decltype(auto) func() {return 表达式;} 相当于 decltype(表达式) func() {return 表达式;}
    返回类型后置：可以在函数名前加auto关键字，将返回值类型用一个指针运算符放到函数头后面
        auto func() ->  returnType
        多与decltype合用在模板里
    类型别名：using 别名=类型名，可以用在模板部分具体化之后的类型，但typedef不能
        using strv_it=std::vector<std::string>::iterator;
        用于模板部分具体化：using arr12=std::array<T,12>;
    空指针：nullptr，更安全
        如果有个重载函数，一个重载版本接受指针，另一个重载版本接受整数，如果将一个NULL指针作为实参调用函数，将会引起多义错误，而新的nullptr则不会
        void foo(int i) {...}
        void foo(char* pt) {...}
        foo(NULL);      //多义错误
        foo(nullptr);   //调用void foo(char*)
    作用域内枚举：传统的枚举在作用域内枚举成员不能重名，由于底层实现可能不同所以可能不可移植
        还有个潜在的类型安全问题是由于枚举成员被视为整数，所以可以在两种不同的枚举类型、枚举类型与整数之间比较
        C++11在作用域内枚举，用enum class 枚举名{枚举值}或enum struct 枚举名{枚举值}定义
        enum class seasons{spring, summer, autumn, winter};
        enum struct freq{never, sometimes, often, always};
        新型枚举需要显式用作用域运算符来引用枚举值，如: seasons::spring
        新型枚举类、枚举结构体不能隐式转换为整数、不能与整数比较、也不能与不同枚举类的枚举值比较，否则发生编译期错误
        指定枚举类的数据类型：
            新型枚举类还能指定枚举类的类型，语法与类继承类似
            比如要指定枚举类My_Enum的数据类型是Type类型
            enum class My_Enum:Type {value1=(Type),...};
    类内初始化：在定义类时对成员初始化赋值
    新STL的const方法：cbegin()和cend()，与begin()和end()一样，返回指向第一个元素和指向超尾的迭代器，不过他们将元素视为const，不能使用迭代器修改元素
    尖括号嵌套：之前为了避免和抽取运算符>>混淆，C++11不要求在嵌套的尖括号（尤其是模板类型的指定）中使用空格分开
        std::vector<std::list<int> > v1;    //可以去掉右尖括号之间的空格
    右值引用：
        右值：所有的C++的值要么是左值，要么是右值，左值是表达式结束后依然存在的持久化对象，右值是表达式结束后就不存在的临时对象
            所有的具名变量、对象都是左值，而右值没有命名
            能取地址的值是左值，不能的是右值
            常见的右值包括常量表达式、变量表达式（等号右边的表达式）、函数返回的临时对象（包括返回的临时变量）注意：永远不要将函数的返回值定义为返回右值引用！
            用将右值赋给一个类型名+两个取地址符&&+变量名，得到一个命名的右值，名字是变量名，这就形成了一个新的左值，多用于移动构造
                如：int &&a =1;   int && b=c+d;     int && e=somefunc();    //somefunc()返回一个int
            将右值赋值给右值引用后将延长这个右值的生存周期，在右值引用退出所在的作用域后才失效
            左值引用（一个取地址符）只能绑定左值，右值引用（两个取地址符）只能绑定右值
            而常量左值引用可以绑定右值、非常量左值、常量左值，而且也可以延长所绑定的对象的生存期
            const int & a=1;    //绑定常量右值
            const int & b=x;    //绑定非常量左值（复制构造函数的参数就是常量左值引用绑定非常量右值）
            const int y=2; const int & b=y; //绑定常量左值
            例如：
                class A{};
                A Return_temp_A()
                {
                    return A();
                }

                A Return_local_A()
                {
                    A a;
                    return a;
                }

                void func(A a)
                {
                    cout << "Standard.\n";
                }

                void func(A& a)
                {
                    cout << "Lvalue ref.\n";
                }

                void func(const A& a)
                {
                    cout << "Const Lvalue ref.\n";
                }

                void func(A&& a)
                {
                    cout << "Rvalue ref.\n";
                }

                int main()
                {
                    A a;
                    func(a);    //可以匹配A, A&, const A&
                    const A b;
                    func(b);    //可以匹配A, const A&
                    func(Return_local_A()); //可以匹配A, A&&
                    func(Return_temp_A());  //可以匹配A, A&&
                }
        通用引用：
            两个&&符不一定就是右值引用，当且仅当发生类型推断时（函数模板实例化、用auto&&声明一个变量的类型），&&可能会是一个左值引用，规则如下，而且形式必须是T&&中的T发生类型推断
            引用折叠：
                T& &    T& &&   T&& & -> T& 左值引用
                T&& && -> T&& 右值引用或通用引用
            由于发生类型推断时的&&可以成为左值引用也可以成为右值引用，所以称为通用引用
            auto&& x=0;             //右值引用
            int i=0;   auto&& x=i;  //左值引用
            template<typename T>
            void func(T&& x)        //通用引用，实例化时可以绑定左值也可以绑定右值
        完美转发：所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的
            不完美转发：在一个接收右值引用参数的函数func1内将这个参数直接传给另一个函数func2，就是不完美转发，这是由于func1的右值引用参数有名字，所以在func1函数体他是一个左值，传递给另一个函数是作为左值或左值引用来传递的，改变了原有特性
            std::forward()模板函数：将具名的右值引用（左值）仍然作为右值引用传递给另一个接受右值引用参数的函数，而不改变左值引用的性质
                然而只有forward并不能完美转发，因为在非模板函数中引用参数只能是左值引用或右值引用中的一种，要实现两种都接受，必须借助模板实现通用引用参数
            将std::forward()与函数模板结合，使得函数既能接受左值引用，又能接收右值引用
            void somefunc(int&& a);
            void somefunc(int& a);  //假设有一个重载函数，既能处理右值引用也能处理左值引用
            template <typename T>
            void myforward(T&& a)   //自定义一个函数，既能接受左值引用又能接受右值引用，并转发给somefunc()处理
            {
                somefunc(std::forward<T>(a));
            }
        移动构造函数：形式上类似于用右值表达式做引用参数的构造函数，由于移动构造函数要修改引用参数的内容，所以不能将形参声明为const
            移动语义：将一个对象所占有的资源（常常是动态分配所得的指针）转移到自身，将对方对象的这个指针设置为nullptr，本质上是偷过来，由于这个指针所指向的内存区域没有变化，所以避免了不必要的复制
            原型：className(className && exp);
            定义：className::className(className && exp) {} 
            定义了移动构造函数后，exp就可以作为右值引用，避免不必要的复制，常发生在exp作为函数返回临时变量时
            例如：vector<string>a;  a.push_back(string("hello")); //这里string类定义了移动构造函数，当用hello构造一个string的临时对象后，可以用移动构造函数对vector中存储的新对象进行构造
                如果没有移动构造函数，就需要先用hello构造一个string临时对象，然后使用复制构造函数对vector中存储的新对象进行构造
            将移动构造函数定义为noexcept，进一步节约移动时间
            className(className && exp) noexcept;
        移动赋值运算符：
            原形：className& operator=(className && exp);
            定义：className& className::operator=(className && exp) {}
        std::move()：对于使用左值来构造对象，通常是调用复制构造函数，然而有的左值生存周期很短，复制的开销大，可以使用move()函数强制转换为右值，进而使用移动构造函数
            例如：vector<string> a; string temp("hello"); a.push_back(move(temp));  //将temp强制转换为右值，从而调用移动构造函数对vector中存储的新对象进行构造
            使用了move()函数后的左值不应该再继续使用，因为其中的动态分配的内存已经失效，例如此时不应该再输出temp字符串的值
            如果对象所属的类没有定义移动构造函数，move将使用复制构造函数，这是由于常量左值引用可以绑定右值，此时被复制的源对象没有失效，可以继续使用
        C++11中的所有容器都实现了移动构造，所以容器之间的赋值会使用移动赋值函数，从而不需要将整个容器中存储的所有对象一个个的复制 
        悬空引用：
            注意常见的悬空引用的发生情况：
                1.引用一个临时对象的部分成员
                    struct MyStruct
                    {
                        int v=0;
                        int const &getData() const { return v; }
                    };
                    MyStruct getMyStruct()
                    {
                        return MyStruct();
                    }
                    auto&& data=getMyStruct().v;    //悬空引用，因为getMyStruct()返回的临时对象将被删除，返回这个临时对象的内部的数据的引用
                    auto&& data2=getMyStruct().getData();   //也是悬空引用
                    
    override和final管理虚方法：
        如果在继承类中包含与基类同名且特征标相同的函数，基类这个函数被声明为虚的，则可以用基类指针或引用来调用派生类的相应方法
        如果特征标不同，会导致基类的方法被隐藏，从而无法调用基类方法
        可以在派生类的这样的特征标与基类相同的方法的定义的函数头后显式加override关键字，表明要覆盖基类虚函数，这样编译器会检查特征标是否相同
        可以在派生类与基类相同特征标的函数的定义的函数头后显式加final关键字，表明禁止以后从这个派生类继续派生的类覆盖这个方法
    final关键字管理派生体系：
        可以在类定义时在类名后加final关键字，表明禁止任何类从这个类派生
        class someClass final
        {
            ...
        }
        class anotherClass: someClass {...} //错误
    lambda表达式：在需要函数指针、函数符的地方可以用lambda函数，有点类似于内联函数，在用lambda函数的地方需要完整定义整个函数
        lambda函数的一般形式的定义：中括号 [] (参数列表) {函数体}
            [](int a) {return a%3==0;}  //一个用于判断参数是否可以被3整除的lambda函数，将返回一个布尔值
        可以用auto关键字自动判断其类型并赋值给一个标识符作为别名
        lambda函数的真正类型是：[](paraType)->returnType
        例如可以将上面的lambda函数赋值给mod_3，使之成为函数的别名
            auto mod_3=[](int a ){return a%3==0;};
        或：[](int)->bool mod_3=[](int a){return a%3==0;};
        调用时就像正常函数调用的形式那样调用lambda函数：mod_3(6);
        lambda函数可以捕获定义它的作用域内的变量，在中括号内指定变量名可以按按值传递，在中括号内指定变量名+引用可以按引用访问，只填一个&符号可以按引用访问所有变量，只填一个=号可以按值传递所有变量
        还可以混合使用&指定变量和按值传递的方式

    函数包装器：
        #include <funtional>
        将返回类型相同，参数类型相同的函数赋值给一个函数包装器，常用于减少模板实例化版本的个数
        std::function<returnType(paraType)> name;   //定义了一个叫name的可以用来包装返回值类型为returnType，参数类型为paraType的函数的函数包装器
        然后可以赋值给这个函数包装器相应类型的可调用物（任何返回值和参数类型个数相同的函数的函数名、对象的成员函数、lambda表达式等）
        然后像使用普通函数一样使用函数包装器，调用
        std::mem_fn:
            template<class ReturnType, class T>
            mem_fn(ReturnType T::*function_ptr)
            将指向T类的成员函数的指针转换为一个函数对象
    可变参数模板：
        定义：
            template<typename... Args>
            returnType func(Args... args)
            {...}
        然而一个可能的问题是函数将无限递归调用自己
        所以需要一种每次提取一个参数的手段来避免无限递归调用，比如可以将参数列表中的第一个参数具体化，然后将剩下的放在args列表里，每次递归减少一个
        template<typename T, typename... Args>
        returnType func(T a, Args...agrs)
        {
            //处理第一个参数a
            func(args...);//递归调用自己
        }
        template<typename T>
        returnType func(T a)
        {
            //...
            return ...;
        }
        注意应当再额外定义一个函数只有一个参数的函数模板，有时还需要空参数的模板
        例如求一个可变参数的参数的和的函数，应当定义一个只有一个参数的函数模板，返回参数自己，否则会在参数减少到1的时候找不到要使用的函数
    delete关键字：在类定义的函数原型后加=delete，表明此方法禁止产生和调用（也可以禁止编译器隐式提供的各种默认函数，常用于禁止复制和赋值重载）
        由于C++在函数调用时优先调用最佳匹配函数，如果没有最佳匹配，则可能进行隐式类型转换，所以可以在一个方法后加delete关键字，来禁止调用已声明为delete的方法，从而阻止隐式类型转换
        class someClass
        {
        public:
            void func(int a) {}
            void func(double b)=delete;
        }
        someClass a;
        a.func(2);
        a.func(2.0);    //由于已经存在void func(double)，所以2.0不会被隐式转换为int然后调用void func(int)，而void func(double)被声明为delete，所以调用错误
    default关键字：有时可能希望使用自动生成的默认函数（构造、复制构造、重载赋值），可以写出函数原型后加=default，表明使用这些方法的默认版本
        someClass()=default;//使用默认构造函数的同时也可以自定义其他的构造函数
    委托构造函数：有时由于定义了多个构造函数，可能产生重复代码，所以可以在一个构造函数中用成员初始化列表的方法调用一个已经定义的另一个构造函数，然后在函数体中再执行别的操作
        C++11之前的常见做法是定义一个private的init()方法，做一些所有构造函数都要执行的公共操作，然后在构造函数中调用这个方法
        class someClass
        {
            int a;
        public:
            someClass():a(0) {...}
            someClass(int v):someClass() {//do other things}
        }

C++14:
    1.函数返回值类型auto
        auto func(paraType para)
        {
            return ...
        }
    2.二进制字面值
        二进制字面值用0b或0B开头 int a=0b110;   //a=6
        八进制字面值用0开头 int b=011;  //b=9
        十六进制字面值用0x或0X开头 int c=0x11;  //c=17
    3.字面值分隔符
        可以在数字字面值上用一个单引号'来分割一个长数   int a=100'000;
        注意，分隔符前面必须要有除了二进制字面值标志的其他数位，不能在标志符后紧跟一个分隔符
    4.变量模板
        可以对单个变量定义成模板，变量的取值在编译器根据模板参数生成
        template<typename T>
        T pi=T(3.1415926535897L);

        cout<<pi<int>;      //输出3
        cout<<pi<float>;    //输出3.1415...
        cout<<pi<double>;   //输出3.1415926...

C++17：
    1.结构化绑定
        绑定指定名称到初始化器的子对象或元素
        三种形式：
            attr(可选) cv-auto ref-运算符(可选) [ 标识符列表 ] = 表达式;
            attr(可选) cv-auto ref-运算符(可选) [ 标识符列表 ] { 表达式 };
            attr(可选) cv-auto ref-运算符(可选) [ 标识符列表 ] ( 表达式 );
        cv-auto是可能使用const限定的auto关键字
        ref-运算符是可能使用的引用符号（右值引用或左值引用）
        标识符列表是需要绑定名称的子对象的名称
        表达式是可以是返回数组、元组、结构体的函数，或相应的数组、元组、结构体
        绑定数组：
            标识符列表 中的每个标识符均成为指代数组的对应元素的左值。标识符的数量必须等于数组的元素数量。每个标识符的被引用类型都是数组的元素类型
            int a[2] = {1,2};
            auto [x,y] = a; // 创建 e[2]，复制 a 到 e，然后 x 指代 e[0]，y 指代 e[1]
            auto& [xr, yr] = a; // xr 指代 a[0]，yr 指代 a[1]
        绑定元组：
        绑定数据成员：
            标识符列表 中的各个标识符，按声明顺序依次成为指代 e 的各个成员的左值的名字    
            struct A
            {
                int a;
                int b;
            }t;
            ...//初始化t
            auto [x,y]=t;   //x=a,y=b
    2.std::optional<Type>
        #include <optional>
        一个带有返回值的函数如果某些情况下会出错而不能返回一个有效值，可以使用optional模板
            将原先接收函数返回值的变量类型改为optional<Type>，或者由于函数的返回值已经确定，可以使用auto关键字
            原先的可能返回无效值的函数将返回一个默认构造的optional对象，此对象无值
            Type不能是引用类型，因为引用肯定有值，所以不需要optional
        optional模板类还可以做函数形参
        方法：
            has_value()：当有值的时候返回true
            ParaType value_or(para)：当没有值的时候将para传递给optional内存储的类型的构造函数并返回这个构造的对象，当有值的时候返回这个值
            重载的比较运算符：比较两个optional对象，仅当lhs和rhs都有值，才比较容纳的值，这时将调用容纳的对象的类中定义的比较运算符
                当有一个操作数没值时，有值的optional对象大于没值的
                当两个optional对象都没值，则相等
    3.std::variant
        #include <variant>
        variant是一个可以存储多种可能类型的对象，与union作用类似，但union只能存储内置类型（比如不能存std::string），union的大小与所存储的最大的成员相同，而variant则是所有所存储的类型的大小相加
        variant<Types...> var;  //定义一个可能存Types...(尖括号内的所有Type)类型的variant对象var
        当variant对象中实际存的是T类型的数据时，可以使用
            auto* pt=std::get_if<T>(&var)   //这样当var中实际存储的确实是T类型时，返回一个指向这个数据的指针，如果类型不符，或者没有数据，返回一个nullptr
            auto& rf=std::get<T>(var)       //这样当var中实际存储的确实是T类型时，返回一个这个数据的引用，如果类型不符，抛出std::bad_variant_access异常
            bool std::holds_aternative<T>(var)  //查询var是否实际存储了T类型的数据，如果是，返回true，否则返回false
        template<class callable, class... variants>
        std::visit(callable f, variants var1...)
            相当于将variant var1...中的数据传递给可调用对象f（函数、函数对象（重载了()操作符的结构体、类）），然后调用这个可调用对象f
            visit的返回值就是可调用对象f的返回值
    4.std::any
        #include <any> 
        any是一个可以存储任何类型的对象，可以在构造any对象时初始化赋值，也可以先定义后赋值
        any var;    //定义了一个没有存储任何数据的any对象var  
        当any对象中实际存的是T类型的数据时，可以使用any_cast<T>(var)运算符来返回一个所存储的对象的拷贝，如果是T*则返回指针，T&则返回引用，如果类型不符，则抛出bad_any_cast异常
            bool has_value()
            const type_info& type(); //返回一个type_info对象的引用，有name()方法可以返回一个类型的C风格字符串
    5.返回值优化
        C++17中，函数返回局部变量（对象）有两种情况
        假设有类A
        class A
        {
            int value;
        public:
            A() { cout << "default constructor! value=" << value<<endl; }
            A(const A& a) :value(a.value) { cout << "Copy constructor! value=" << value << endl; }
            A(A&& a) { cout << "Move constructor! value=" << value << endl; }
            ~A() { cout << "Destructor!\n"; }
        };
        当调用返回具名局部变量的函数时，有可能有优化从而就地构造（在函数被调用的地方直接构造），也可能没有优化，从而先调用构造函数构造函数内的局部变量，再在被调用的地方调用移动构造函数
        当然，如果这个局部变量被在函数中被改动，还有其他操作，肯定是调用移动构造函数
        如果没有定义移动构造函数，就调用复制构造函数
            A Return_local()
            {
                A a;
                return a;
            }   //VS2019输出"default constructor!" "Move constructor!"
        当调用直接返回临时变量的函数时，一定会发生返回值优化
            A Return_temp()
            {
                return A();
            }   //VS2019输出"default constructor!"
        所以无论如何也不应该定义一个函数返回右值引用
C++20：
    1.模块
        模块名：[模块名]

多线程C++11 std::thread：
    1.一个最简单的多线程（用第二个线程打印hello world）
        #include<iostream>
        #include<thread>
        void hello()
        {
            std::cout<<"Helloworld!"<<std::endl;
        }
        int main()
        {
            std::thread t(hello);   //创建一个线程对象t，并赋值给hello函数（这里可以用任何可调用的函数对象赋值）
            t.join();               //显式地表明要等待线程执行完毕，可以确保在函数退出前该线程执行完毕
        }
        std::thread 的构造函数可以接收可调用对象（函数、lambda、可调用对象（重载了()操作符的类、结构体））
        而对线程对象调用detach(void)方法表明这个函数不等待线程的完成，函数返回时线程可能还在运行
        detach()打破了thread对象与线程的联系，确保thread对象被销毁时terminate()不会被调用
        如果对thread对象既不适用join()又不使用detach()，则在线程对象因为主线程main退出作用域被销毁时，新线程会terminate
        可以用joinable()方法检查这个线程是否可以与thread对象结合或分离，已经分离的线程不能再与任何thread对象结合，称为守护进程，joinable()函数返回一个布尔值
        每个线程都有一个独特的id，获取当前线程的id，使用std::this_thread::get_id()函数
        获取线程对象的id，使用get_id()成员方法
    2.获取资源即初始化
        当thread对象绑定的函数有参数时，需要在thread对象的构造函数内传值调用，这是由于默认情况下创建新线程时，参数是拷贝到新线程的独立内存中
        如果函数参数是引用，需要将构造函数内的参数用std::ref()显式转换
        void add(int & a) {++a;}
        int main() 
        {
            int x=0;
            std::thread t(add,std::ref(x));  //x->1
        }
        当然，也可以用指针的方式来实现
        void add(int* a){++(*a);}
        int x=0;
        std::thread t(add,&x);
        对于可调用对象而言，thread的构造函数的传递一个成员函数指针作为线程函数，第二参数是一个合适的对象的指针，后面的参数是线程函数的参数
    3.线程数的理想上限
        当创建的线程数多于CPU核心数时，会带来多余的上下文切换降低性能
        使用unsigned int std::thread::hardware_concurrency()函数获取CPU线程数，返回一个无符号整形值
    4.资源竞争
        当同一个对象被多个线程共有，就会造成资源竞争问题，最简单的解决方法是对共享资源采取某种保护机制，确保只有修改资源的线程才能看到不变量被破坏的中间状态，其余线程要访问时，要么修改已经完成了，要么还没开始修改（用互斥量延迟访问）
        保护数据的最基本方式，是C++标准库中的互斥量，std::mutex
        
    5.死锁
        有锁情况：
            当两个线程A、B以相反的顺序锁两个mutex M1、M2时，可能发生如下清醒：
            A               B
            lock(M1)        
                            lock(M2)
            lock(M2)
                            lock(M1)
            //...           //...
            这时便发生了死锁，由于A线程先lock了M1，然后尝试lock M2，此时B线程又lock了M2，所以A线程无法继续，由于A线程先lock了M1，所以B线程尝试lock M1也不成功，所以B线程也无法继续
        无锁情况：
            当两个线程A、B互相调用join()
            A                   B
            ...                 ...
            thread(B).join()    thread(A).join()
            这时也发生了死锁，由于A线程等待B线程执行完毕才能执行完，B线程等待A线程执行完毕才能执行完，所以A、B线程都在互相等待对方执行完毕
    6.避免死锁的方法
        1）永远让线程使用相同的顺序来锁多个mutex
        2）尽量只同时锁一个mutex，锁住之后做一些操作，释放这个mutex，再锁另一个mutex
        3）使用std::lock()来锁mutex对象，std::lock()包含避免死锁的算法
    7.各种C++ mutex包装器
        std::mutex
            C++标准库中的互斥量的类型
        std::lock_guard<Mutex>(mutex& m)模板
            在定义时自动锁上mutex m，在超出作用域后自动解锁mutex m，但是没有lock()和unlock()函数，锁和解锁的过程完全由所在的作用域决定
        std::unique_lock<Mutex>(mutex& m)模板
            可以人为调用lock()和unlock()任意次
            可选的第二参数：unique_lock<Mutex>(mutex& m, std::defer_lock)表示在定义时不自动加锁
            unique_lock比lock_guard更灵活，但成本更高
            unique_lock和lock_guard都不可复制，只可移动
        std::once_flag+std::call_once(once_flag& flag, Fn&& function) 
            std::once_flag是一个多线程环境中只能被改变一次的对象，作为call_once()函数模板的第一参数，第二参数是一个函数对象，确保在多线程环境中function函数对象只被调用一次
        std::condition_variable
            #include <condition_variable>
            当一个线程在做
        std::promise+std::future+std::async
            子线程->主线程传递信息
                假设想要在子线程中接收来自主线程的一个引用参数来传递信息，比如子线程将处理结果返回给主线程，一个可能的做法是给子线程函数增加一个引用参数，然后主线程创建thread对象时用ref传递这个参数
                然而此处需要保证在子线程写入这个引用参数时，主线程没有同时访问他，所以需要在两个线程分别写入和访问时上锁
                然而还需要保证主线程访问这个参数前，子线程已经完成写入操作了，所以不会读取到无用数据，所以还可能需要一个condition_variable来使得子线程写入后唤醒主线程来访问
                这使得代码变得复杂
                template <class Fn, class... Args>
                std::future<typename result_of<Fn(Args...)>::type> std::async(Fn&& fn, Args&&... args)
                template <class Fn, class... Args>
                std::future<typename result_of<Fn(Args...)>::type> std::async(launch policy, Fn&& fn, Args&&... args)
                async函数接收一个函数对象Fn，并将args传递给函数Fn，返回一个std::future对象，这个future对象的模板参数类型是函数Fn的返回值类型
                此时可以通过async函数返回的future对象来获取函数的返回值
                async函数的第一参数控制新线程的创建方式
                    默认值为std::launch::async|std::launch::deferred，表示新线程的创建与否取决于实现，也可能不创建新线程
                    如果确实要创建新线程，用std::launch::async
                    std::launch::deferred 表示不创建新线程，而且延迟执行，直到调用了所返回的future对象的get()方法，才执行函数Fn
                
                template <class T> future
                template <class R&> future<R&>
                template <> future<void>
                future表示一个可以在未来获取其内容的对象
            主线程->子线程传递信息
                假设需要在主线程中传递信息给子线程，除了通过在创建新线程时直接将参数传递给函数，还可以在创建新线程之后先让新线程做别的事情，然后主线程继续执行，准备新线程所需的数据，完成后子线程从需要这个数据的地方开始继续执行
                将子线程函数定义为接收std::future参数
                returnType func(std::future<paraType>&& para)  //注意这里应该是右值引用，因为promise的get_future函数返回临时变量，或者就直接值传递
                {
                    //做一些其他事情
                    paraType value=para.get();  //如果主线程此时没准备好信息，就暂停在此处，直到主线程传来信息
                    ...//继续做另一些事情
                }
                int main()
                {
                    std::promise<paraType> p;   //表示当前数据还未准备好，但是将来某时刻会准备好，然后让子线程继续执行
                    auto result=std::async(std::launch::async, func, p.get_future());   //async函数返回一个std::future<returnType>对象
                    ...//主线程做别的事，准备数据给p
                    p.set_value(...);    //数据准备好了，子线程此时继续执行
                    ...//主线程可以继续做别的事，或者等待子线程返回
                    auto result_value=result.get(); //主线程获取子线程的结果
                }
        std::packaged_task<>
        st

Effective C++
    1.C++的四个子语言
        C：
        面向对象C++：类、封装、继承、多态，面向对象的古典守则在C++的实施
        模板：泛型编程、模板元编程
        STL：容器、迭代器、算法、函数对象
    2.以const、enum、inline替换#define
        用define宏定义无法定义常量的类型，而且由于编译时宏定义直接做文本替换，所以编译错误信息中会直接出现替换后的内容，导致出错原因难以追踪
        在类内定义类专属常量的方法：(VC支持)
            class someClass
            {
                static const int a=5;   //类内直接声明类专属常量，注意这是声明而不是定义
                int b[a];   //可以直接使用这个类专属整形常量作为数组长度 
            }
        如果对类内常量取地址，则必须要求定义式，也可能有的编译器要求必须所有对象提供定义式，所以此时需要在类中声明这个常量，然后在实现文件cpp中再提供一次定义式，这个定义式不能再重新赋值
            /*someClass.h*/
            class someClass
            {
                static const int a=5;   //声明式
                int b[a];
            }
            
            /*someClass.cpp*/
            const int someClass::a; //定义式

        有的编译器不允许静态成员声明时赋值，所以需要现在类中声明这个常量，然后在实现文件.cpp中定义这个值
            /*someClass.h*/
            class someClass
            {
                static const int a;
            }

            /*someClass.cpp*/
            const int someClass::a=5;
        然而这种方法声明的类专属常量无法作为数组长度，可以使用下面的enum hack代替
            class someClass
            {
            private:
                enum {NUM=5};
                int b[NUM]; 
            }
            这种方法的原理是enum枚举值名可以充当整形常量使用，然而不能对其取地址。由于通常不会对常量取地址，所以enum是更好的办法
    4.确定对象被使用前已经被初始化
        如果在一个多文件项目中，有一个cpp文件内定义了一个non-local static非局部静态对象（位于全局global作用域、名称空间namespace或在类内被声明为静态static），而这个对象又在其他文件中被引用，则可能由于编译顺序的问题导致没有被初始化
        /*a.cpp */
        int a=0;    //全局变量a
        /*b.cpp */
        extern a;   //在b.cpp中使用使用extern声明a，使得可以在此文件内使用变量a
        int b=a;    //此时a.cpp可能还没有被编译，导致b没能被初始化
        解决方法是创建一个专门的函数，在函数内定义这样的对象，将他声明为static，并对其初始化，函数返回对这个对象的引用，然后在其他使用这个对象的cpp文件中加入这个函数声明的头文件，将所有使用这个对象的地方加上一对圆括号
        思想是将non-local static转换为local static，可以确保在使用这个对象前就一定被初始化了
        /*a.h */
        int& a();
        /*a.cpp */
        int& a()
        {
            static int a=0; //将这个对象声明为静态
            return a;
        }
        /*b.cpp */
        #include <a.h>
        int b=a();  //将int b=a改为int b=a(); 然后几乎无需改动任何原来的用法
    9.绝不在构造函数和析构函数中调用虚函数
        如果基类的构造函数调用了虚函数，则在派生类的构造函数执行时，因为在派生类对象构造的过程中总是先调用基类的构造函数来调用基类成分，所以此时是基类对象，所以基类构造函数中调用的虚函数一定是基类的函数，而不是派生类中的函数
        如果基类这个虚函数是个纯虚函数，纯虚函数没有定义，会引发连接期错误
        析构函数同理，因为在派生类对象析构的过程中总是先析构派生类的成分再调用基类的析构函数，所以如果基类的析构函数中调用了虚函数，实际调用的也一定是基类的函数
    17.以独立语句将new产生的对象放入智能指针
        假如有个函数，接受一个智能指针和另一个参数，比如int
        void func(std::shared_ptr<Widget>pt,int a);
        int anotherFunc();
        在调用这个函数的时候，可能会将另一个函数anotherFunc()调用的返回值作为参数a传递进func，然后在同一个语句内将pt初始化为一个新new的Widget对象并调用函数anotherFunc()
        func(new Widget, anotherFunc());
        由于C++编译器可以自主决定new，anotherFunc()，调用shared_ptr构造函数初始化智能指针pt三件事，所以如果先执行了new，然后执行了anotherFunc()，而anotherfunc()执行异常，则会导致new Widget对象没有被放进智能指针中，程序结束后又没有被释放，导致内存泄漏
        解决方法是在一个独立的语句中将new放入智能指针，使得new分配的新对象马上能被管理
        std::shared_ptr<Widget>pt(new Widget);
        func(pt,anotherFunc()); //此时即使anotherFunc()异常，pt也会被自动析构，从而释放分配的内存
    18.让接口容易被正确使用，不容易被误用
        case 1:假如有个Date类表示年月日
            class Date
            {
            public:
                Date(int year, int month, int day); //设计一
            }
            Date d(2019,2,30);  //客户不小心将2月20日输入成30日，一个可能的原因是键盘上2与3相邻
            许多客户端错误可以通过自定义新类型来预防
            比如可以为年月日各创建一个结构体，构造函数声明为explicit，进一步降低被误用的可能
            struct Day
            {
                explicit Day(int d):val(d){}
                int val;
            }
            class Date
            {
            public:
                Date(const Year& year, const Month& month, const Day& day); //设计二
            }
            这样，调用Date类构造函数时需要： Date d(Year(2019),Month(2),Day(20));
            甚至可以更进一步，用静态成员函数返回静态变量
            class Month
            {
            public:
                static Month Jan() {return Month(1);}
                static Month Feb() {return Month(2);}
                ...
                static Month Dec() {return Month(12);}
            private:
                explicit Month(int m): month(m){}  //设计三
                int month;
            }
            Date d(Year(2019),Month::Feb(),Day(20));
        case 2:工厂函数（返回新对象的指针或引用的函数）直接返回智能指针来防止客户忘记delete造成的内存泄漏
    20.以const引用传递代替值传递
        对于类、结构体，以const引用作为函数形参显然能减少构造和拷贝的次数，提高效率
        对于类中禁用了复制构造函数，则以const引用传递是唯一作为函数形参的方法，比如std::unique_ptr
        如果派生类对象以值传递的方式传递给一个基类类型形参，则失去多态性质，成为切割
    21.必须返回对象时不要返回引用
        注意不要犯返回一个指向临时对象的引用的错误
        假如有个有理数类Rational，我们会希望两个有理数可以相乘，相乘的结果是一个新的有理数对象
        class Rational
        {
        public:
            Rational(int _numerator=0, int _denominator=1): numerator(_numerator), denominator(_denominator) {}
            friend Rational& operator*(const Rational& lhs, const Rational& rhs);    //错误的设计一，函数返回引用
        private:
            int numerator;
            int denominator; 
        }
        Rational& operator*(const Rational& lhs, const Rational& rhs)
        {
            return result(lhs.numerator*rhs.numerator, lhs.denominator*rhs.denominator);    //返回一个临时对象的引用
        }
        错误的设计二：返回一个临时对象的指针
        错误的设计三：返回一个堆区new对象，这会导致客户不知情，没有调用delete释放内存
        const Rational& operator*(const Rational& lhs, const Rational& rhs)
        {
            Rational* result=new Rational(lhs.numerator*rhs.numerator, lhs.denominator*rhs.denominator);
            return *result;
        }
        Rational a=b*c; //a是*result，result指针无法再被释放，除非delete &a，不过客户对这个实现方式应该是一无所知的

        //不过有了右值引用？
    24.若所有参数都需要类型转换，定义一个非成员函数
        还是以Rational有理数类作为例子，我们希望不仅能两个有理数对象之间可以相乘，我们还希望一个有理数对象和一个整数之间也可以相乘，如果将operator*作为成员函数则只能是有理数*整数的形式，反之错误
        假设Rational类的*号运算符是作为成员函数
        class Rational
        {
        public:
            ...//构造函数
            Rational& operator*(const Rational& rhs);   //作为成员函数
        }
        Rational oneHalf(1,2);  //定义了一个有理数对象oneHalf
        Rational result=oneHalf*2;  //正确，函数调用式为oneHalf.operator*(2)，由于Rational类的构造函数有默认参数，2被隐式转换为Rational对象
        Rational result=2*oneHalf;  //错误，int没有这样的运算符重载
        实际上，只有位于参数列表中的实参才能被隐式类型转换
        解决方法是将这个函数定义为非成员函数，就像上面21那样
    26.尽可能延后变量定义式的出现时间
        以下这个函数过早定义变量encrypted
            std::string encryptPassword(const std::string& password)
            {
                using namespace std;
                string encrypted;
                if(password.length()<MinimumPassoerdLength)
                    throw logic_error("Password is too short"); //假如此处抛出异常，encrypted完全未被使用，而白白付出了一次构造和析构，应当延迟encrtyped的定义，直到确实需要它
                ...
                return encrypted;
            }
        延后了encrypted的定义时间
            std::string encryptPassword(const std::string& password)
            {
                if(password.length()<MinimumPassoerdLength)
                    throw logic_error("Password is too short");
                std::string encrypted;  //使用了默认构造函数
                encrypted=password;     //使用了赋值运算符，浪费了默认构造函数所做的工作，最好应该在有初值的情况下直接赋值，即使用std::string encrypted(password);
                ...
                return encrypted
            }
        对于循环
            className obj;  //构造一次
            for(int i = 0; i < n; ++i)
                obj=(取决于i的某个值)   //赋值n次
            ...     //析构一次

            for(int i = 0; i < n; ++i)
                className obj(取决于i的某个值)  //构造n次，析构n次

            如果已知一次赋值成本低于一次构造+一次析构，应当选择第一种，否则选择第二种，因为第一种方法扩大了obj的作用域，可能会降低程序的可维护性
    27.尽量少类型转换
        C风格转型：(T)expression    //将表达式expression转换为T类型
        函数风格转型：T(expression) 
        C++新式转型：RTTI的四种cast，应尽量使用新式转型，因为他们更容易被识别
        转型并不只是告诉编译器将一种类型视为另一种类型，编译器可能为转型生成了代码，甚至有时会将转型后的指针附加了偏移值
            class Base{};
            class Derived: public Base{};
            Derived d;
            Base* pb=&d;
            Derived* pd=&d; //pb和pd的值可能不同
        不要尝试对类对象指针做指针运算，没有移植性
        不要在派生类中用类型转换的方法来调用基类中的方法，这是因为这修改的是对象的副本的基类成分而不是对象本身的基类成分
            class Base
            {
                int a = 0;
            public:
                virtual void dostuff()
                {
                    cout << "Base class a++" << endl;
                    ++a;
                }
                void show()
                {
                    cout <<"In base: "<< a << endl;
                }
            };

            class Derived: public Base
            {
                int b = 1;
            public:
                void dostuff()
                {
                    static_cast<Base>(*this).dostuff(); //正确的做法是：调用基类的方法，使之作用在this指针所指的对象上 Base::dostuff();
                }
            };

            int main()
            {
                Derived b;
                b.show();       //输出a=0
                b.dostuff();    //b的Base类副本中的a被加1，但是b本身的基类成分没有改变
                b.show();       //输出a=0
            }
        dynamic_cast的成本可能很大，尤其是继承层次深时，所以不要使用dynamic_cast在存储继承层次的指针容器中使用链式判断能否转型然后再调用各自的函数，应当使用虚函数方法
    31.将文件间的编译依存关系降至最低
        https://www.cnblogs.com/jerry19880126/p/3551846.html
        一种常见的存在很高依存性的组织方式：
            省略以下各类的具体实现：Date.cpp Address.cpp Person.cpp
            /*Date.h*/
            class Date{...}

            /*Address.h*/
            class Address{...}

            /*Person.h*/            //假设Person类是面向客户的类，是实际的对外接口
            #include <string>       //标准库可以认为是不会被修改的
            #include "Date.h"
            #include "Address.h"
            class Person
            {
            private:
                std::string Name;
                Date Birthday;
                Address address;
            }
            如果类中存放了某种对象，编译器需要知道这个对象的大小从而分配内存，所以需要这个对象所属类的完整定义
            而指针和函数的参数不需要，编译器只需要知道这个类型存在即可，所以可以使用前向声明的方法
            如此一来按照上面这种组织关系，如果Date或Address更改了数据结构（即Person.h发生了改变，因为包含的头文件发生了改变），那么Data.cpp、Address.cpp和Person.cpp和所有使用了Person.h的cpp文件就需要重新编译
        要降低这种编译依存关系，关键是要想办法分离接口Person.h和底层实现的关系，使得Date和Address改变时不影响Person.h，这样使用Person.h的cpp文件就不需要重新编译
        方法一：Handle Class句柄类：将Person类的所有数据成员放到另一个类PersonImpl中，在Person类的private部分中只留下一个指向PersonImpl类的指针，public部分保留原来的类方法
            由于Person类的数据成员只有一个指针，所以在Person.h中可以PersonImpl前向声明的方法，无需包含它的定义，而在Person.cpp中包含PersonImpl.h来实现相应的Person方法
            /*Date.h*/
            class Date{...}

            /*Address.h*/
            class Address{...}

            /*Person.h*/        //假设Person类是面向客户的类，是实际的对外接口
            class PersonImpl; 
            class Person
            {
            private:
                PersonImpl* person;
            public:
                ...//成员函数
            }

            /*PersonImpl.h*/
            #include "Date.h"
            #include "Address.h"
            #include <string>
            class PersonImpl
            {
            private:
                std::string Name;
                Date Birthday;
                Address address;
            }
            //省略PersonImpl.cpp（应该与Person.h中原先提供的方法对应）

            /*Person.cpp*/
            #include "Person.h"
            #include "PersonImpl.h"
            ... //调用PersonImpl中的方法
            
            此时即使Date或Address发生了改变，而Person的对外接口无需变化时，只需修改PersonImpl，并重新编译PersonImpl.cpp和Date.cpp或Address.cpp，所有使用Person类的cpp文件都无需重新编译
        方法二：Interface Class接口类：将Person类声明为抽象基类，只包含虚函数，没有数据成员，而将数据成员放在这个类的继承类中，利用虚函数方法使得实际调用的函数是继承类中的函数
            /*Date.h*/
            class Date{...}

            /*Address.h*/
            class Address{...}

            /*Person.h*/        //假设Person类是面向客户的类，是实际的对外接口
            ... //只前向声明函数的参数和返回值需要用到的类
            class Person        
            {
            private:            //私有数据成员放在派生类中
            public:
                ... //virtual 成员函数=0;
            }       //由于都是纯虚函数，Person类甚至不需要实现文件.cpp

            /*RealPerson.h*/
            #include "Date.h"
            #include "Address.h"
            #include "Person.h"
            #include <string>
            class RealPerson: public Person
            {
            private:
                std::string Name;
                Date Birthday;
                Address address;
            public:
                ... //Person类中的函数，由于是虚函数多态，注意名字、返回值、参数都要与Person类中的纯虚函数相同
            }       //省略RealPerson类的实现文件RealPerson.cpp

            客户在使用Person类时由于抽象基类不能实例化对象，所以需要用new的方法实例化RealPerson对象并用Person类的指针调用它的方法，而实例化RealPerson需要调用RealPerson类的构造函数，如此一来就破坏了编译独立性
            这里目标是不在使用Person类的cpp文件中包含RealPerson头文件
            解决方法是在Person类中声明一个静态成员函数，这个函数返回一个Person类指针，这样可以在RealPerson类中实现它
            /*Person.h*/
            class Person
            {
            public:
                static Person* CreatePerson(const std::string& name, const Date& birthday, const Address& addr);
                ... //上面所说的纯虚函数
            }

            /*RealPerson.h*/
            #include "Date.h"
            #include "Address.h"
            #include "Person.h"
            #include <string>
            class RealPerson
            {
            private:
                ... //上面所说的Person类的数据成员
            public：
                static Person* CreatePerson(const std::string& name, const Date& birthday, const Address& addr);
                ... //派生类多态函数
            }       
           
            /*RealPerson.cpp*/
            #include "Person.h"
            #include "RealPerson.h"
            Person* Person::CreatePerson(const std::string& name, const Date& birthday, const Address& addr) //在RealPerson.cpp中实现CreatePerson函数
            {
                return new RealPerson(name, birthday, addr);
            }
            如此一来按照上面这种组织关系，如果Date或Address更改了数据结构，只需要重新编译RealPerson.cpp，而作为接口的Person类和使用Person类的cpp文件都无需重新编译，代价是虚函数存在开销
    33.避免遮掩继承而来的名称
        派生类中与基类同名的函数会遮掩基类中的所有函数，无论是否基类这些函数重载，也无论是public继承还是private继承
        但是被遮掩的函数可以通过作用域解析运算符访问
        公有继承中，如果希望基类的同名重载函数在没有被派生类重写的情况下在派生类中可用，可以通过using声明
        class Base
        {
        public:
            virtual void mf1()=0;
            virtual void mf1(int);  //这里加不加virtual无所谓
            virtual void mf2();
            void mf3();
            void mf3(double);
        }
        class Derived: public Base
        {
        public:
            virtual void mf1();
            void mf3();
            void mf4();
        }//省略函数的实现
        Derived d;
        d.mf1();    //Derived::mf1
        d.mf1(x);   //错（Derived中的mf1覆盖了Base::mf1(int)）      可以通过在Derived类中加入using Base::mf1;   使得Base中的mf1（包括其重载）在Derived类中可用
        d.mf2();    //Base::mf2
        d.mf3();    //Derived::mf3
        d.mf3(2.0); //错（Derived中的mf3覆盖了Base::mf3(double)）   可以通过在Derived类中加入using Base::mf3;   使得Base中的mf3（包括其重载）在Derived类中可用，而由于Derived中定义了无参的mf3，所以Base中的mf3只有有参版本的可用
        d.Base::mf3(2.0);   //Base::mf3(double)
        在私有继承中，由于基类所有函数在派生类中都成为了private，所以对外不可用，如果希望某些基类函数可用，可以通过转交函数的方法，即定义一个同名同参数函数，通过作用域解析运算符调用基类的同名函数
        class Base
        {
        public:
            virtual void mf1(); //这里加不加virtual无所谓
        }
        class Derived: private Base
        {
        public:
            virtual void mf1()  //希望使得基类的mf1()可用，所以定义一个同名同参数的转交函数，调用基类的函数
            {
                Base::mf1();    
            }
        }
    34.区分接口继承和实现继承
        纯虚函数：
            不提供定义的纯虚函数是为了继承接口，要求派生类必须提供这个方法的定义
            提供定义的纯虚函数是为了继承接口+继承一份缺省的实现，派生类必须提供这个方法的定义，然而也可以在定义中通过作用域解析运算符来调用抽象基类中这个缺省的实现
        虚函数：为了继承接口+继承一份缺省的实现，派生类不一定提供这个方法的定义，如果不提供，就使用缺省的实现
            只要一个类可能被作为基类，就应该包含虚函数
        非虚函数：为了继承接口+强制性继承实现，表明所有派生类都不应该覆盖这个方法
    35.考虑virtual函数意外的其他选择

    36.绝不重新定义继承而来的非虚函数
        如果派生类重新定义了继承而来的非虚函数
        class Base
        {
        public:
            void mf1();
        }        
        class Derived: public Base
        {
        public:
            void mf1();
        }
        则假如有个Derived类对象的指针或引动pd，则对其调用mf1()方法时调用的是Derived::mf1，而将这个对象赋值给Base类指针或引用再调用mf1()方法时却调用的是Base::mf1
        而对同一个对象调用同一个函数，不应该因为指针或引用的类型的不同而表现出不同的性质，重写非虚函数会破坏这种行为
        这破坏了公有继承的严格is-a关系，即每一个Derived都是一个Base对象，非虚函数表明Derived必须表现出与Base相同的性质的要求
    37.绝不重新定义继承而来的缺省参数
        函数的缺省参数是静态绑定的，无论这个函数是不是virtual
        class Shape
        {
        public:
            enum Color{R, G, B};
            virtual void Draw(Color _color = R) const = 0 ;  //Shape作为抽象基类，由于各个Shape派生类的Draw方法区别可能很大，所以把Draw作为纯虚函数，这里有个默认缺省参数
        }
        class Rectangle: public Shape
        {
        public:
            void Draw(Color _color = G) const;   //派生类Rectangle的Draw函数重新定义了默认缺省参数
        };

        Rectangle r;
        r.Draw();   //调用Rectangle::Draw(G)
        Shape *pr=&r;
        pr->Draw(); //调用Rectangle::Draw(R)
        由于函数的缺省参数是静态绑定，所以如果在派生类中重新定义了缺省参数，那么就会因为指针或引用的静态类型不同，而使用不同的默认参数的值，会导致同一个对象由于指针或引用静态类型的不同而表现出不同行为
        这破坏了虚函数的本意，所以不应该在派生类中重新定义函数的缺省参数（尤其是对于虚函数），只在基类中定义缺省参数，而派生类不定义
        也不应该在派生类中重新定义与基类一样的缺省参数，因为如果基类的缺省参数改写，就要改写所有派生类的这个缺省参数
    38.通过包含塑造has-a或is-implemented-in-terms-of关系
        包含可以形成两种关系
            如果是一个类包含多个其他类的对象，用来实现复合功能，通常是在应用域，形成has-a关系，比如一个Person类包含name、address、birthday
            如果是一个类包含一个（通常是一个）或多个其他类的对象，用来实现一个功能，通常是在实现域，形成is-implemented-in-terms-of关系，比如一个queue类是用deque作为底层来实现的
    39.如何使用私有继承
        如果Derived类私有继承于Base类，则编译器不会讲Derived对象转化成Base对象，即不能将一个Base类的引用或指针指向Derived对象
        基类的public和protected的成分私有继承后都成为派生类的private成分
        由于子类无论是公有继承还是私有继承父类，子类总是只能访问父类的public和protected方法，所以子类公有或私有继承父类不会影响子类的函数的访问权限，但是子类的子类无论是私有还是公有继承，都无法访问子类私有继承而来的父类的任何成分
        因此，私有继承是只继承实现而不继承接口，形成is-implemented-in-terms-of关系
        然而包含也可以形成is-implemented-in-terms-of的关系，应该在以下两种情况下选择私有继承，而不是包含：
            一个类需要访问另一个类的protected成员而不成为友元时（因为友元类能访问private成员），则只能让这个类从另一个类私有继承出来
            一个类需要重新定义另一个类的protected或private的虚函数
                什么时候使用private虚函数？
                    可能需要在基类的public函数中根据派生类的不同而调用继承层次中的private中的某些函数，那么这些函数需要成为虚函数，常见于一些函数执行真正任务前的验证处理和执行后的清理工作
        还有一个极端的情况是，私有继承可能比包含节省空间
            一个没有数据成员（没有虚函数，没有非静态成员变量、没有虚基类）的空类的大小通常不为0，因为编译器通常会加入一个字节的占位符
            如果一个类使用包含来包含一个空类的对象，不仅会增加这个占位符的大小，还可能由于内存对齐的要求占用更多空间，而私有继承一个空类通常不会增大空间占用（与不继承的大小相同）
    40.如何使用多继承
        使用多继承的通常情形是：需要公有继承某个抽象基类，由于抽象基类只描述接口，所以需要继承这些接口，同时又要私有继承某个类（私有继承是继承实现）来利用这个类的实现
        由于多继承常常会继承两个类，这两个类又同时继承于同一个基类，所以这两个类通常需要虚继承于这个公共基类，来避免最后的子类中包含了两个公共基类的副本，这会增加成本，所以这个公共基类最好是不带任何数据
    42.typename的双重意义
        在模板声明中：
            template<class T>
            template<typename T>    没有任何区别，都表示一个模板参数
        在模板类和模板函数的定义中：
            由于模板在实例化之前，编译器无法知道模板参数具体是什么，所以对于嵌套从属类型，C++假设其不是一个类型
            在模板定义中，嵌套从属类型前需要加typename关键字，来告诉编译器这是一个嵌套从属类型，而不是一个普通类型或变量
            template<typename T>
            void func(const T& container)   //T是一个容器的类型
            {
                typename T::const_iterator iter=container.begin();  //T::const_iterator是一个嵌套从属类型，因为他是一个取决于类型T的整体，而不是T类中的某个静态成员
                typename T::const_iterator* x;                      //如果此处不加typename关键字，编译器会将T::const_iterator解析成一个静态成员乘以x，而不是一个迭代器指针
                ...
            }
            在模板派生类继承的声明中，基类不可以加typename关键字，在成员初始化列表中也不可以加
            template<typename T>
            class Derived: public Base<T>::Nested   //这里Derived类继承了Base<T>类下public成分中嵌套的Nested类，Base<T>::Nested是一个取决于T的嵌套从属类型，但是不加typename关键字
            {
            public:
                Derived():Base<T>::Nested() //这里成员初始化列表中的嵌套从属类型也不加typename关键字
                {...}
            };
    43.处理模板化基类的名称
        由于同样的原因，在模板化基类没有实例化前，编译器无法知道模板化基类中的定义，所以C++默认不进入模板化的基类中查找基类的函数名
        还有可能由于模板可以全具体化，全具体化针后的模板可以针对某一个模板参数执行不同的函数，所以不一定派生类中所调用的所有名称都能在模板化基类（可能全具体化后的模板基类中根本没有）中找到
        有三种方法使得编译器假定这个名称在模板化基类中存在（如果真的不存在，会在实际调用时发生编译期错误）
            this指针：在所有基类名称前加this->
            using：在派生类的public部分加using声明，声明所有在派生类中使用的基类名称：using 基类::所用名称
            显式使用作用域解析运算符：在所用的名称前加基类类名和作用域解析运算符
    44.将与参数无关的代码抽离模板
    45.运用成员函数模板使得模板类函数接受所有兼容类型
    46.需要类型转换时在模板内定义非成员函数
        在模板类的类型推导过程中，隐式类型转换不能被自动推导出来，因为如果需要类型转换，就需要函数（构造函数、类型转换函数），而这些函数本身就是模板类的一部分，所以又需要先将模板类的类型参数推导出来，模板类的类型又需要根据实参推导，形成循环
        注意，类型参数推导只发生在函数模板，类模板从不进行类型推导，都需要手动显式指出
        假如有一个有理数类Rational
        template<typename T>
        class Rational
        {
        public:
            Rational<T>(const T& numerator = 0, const T& denominator =1 ); //Rational模板类的构造函数
            ...
        };
        template<typename T>
        const Rational<T> operator* (const Rational<T>& lhs, const Rational<T>& rhs) {...}
        我们希望可以让让两个Rational对象相乘，也可以让Rational对象与int相乘，而不用将int显式转换为Rational类，即：
        Ratioanl<int>oneHalf(1,2);
        Rational<int>result=oneHalf*2;  //而这里会发生错误，找不到函数，这是由于2这个int需要隐式转换为Rational类对象�������能参与运算，而模板类不能推导隐式转换函数，所以2只能被推导为int，而此处没有一个Rational<int>类与int相乘的函数
        解决方法是在模板类内定义非成员函数，如友元函数，这里友元函数不是为了访问类中的proteced或private成员，而是为了让模板类具体化之后这个友元函数也能自动随着模板类具体化而具体化
        而友元函数的定义也需要随着模板类的具体化而具体化，所以需要在这个函数中将完整的定义写出来
        友元函数只是为了能让这个函数随着模板类的具体化而具体化出来
        template<typename T>
        class Rational
        {
        public:
            Rational<T>(const T& numerator = 0, const T& denominator =1 ); //Rational模板类的构造函数
            friend const Rational<T> operator*(const Ratioanl<T>& lhs, const Ratioanl<T>& rhs)
            {
                ... //这个友元函数的完整定义
            }
            ...
        };
        而类模板中模板类名+类型参数与模板类名相同，所以可以省略类型参数，即Ratioanl<T>与Rational相同，所以又可以写为：
        template<typename T>
        class Rational
        {
        public:
            Rational(const T& numerator = 0, const T& denominator =1 ); //Rational模板类的构造函数
            friend const Rational operator*(const Ratioanl& lhs, const Ratioanl& rhs)
            {
                ... //这个友元函数的完整定义
            }
            ...
        };
    49.自定义new和delete
    50.

More Effective C++
    3.不要用多态来处理数组
        假设有个Base类，Derived类继承自Base类
        class Base{...}
        class Derived: public Base {...}
        有个函数，参数包含一个Base类对象的数组，如果将Derived类对象作为实参，则会发生切割问题，原因同Effective C++ 条款20
        void func(const Base array[], int numberOfElements)
        {
            for(int i=0; i<numberOfElements; ++i)
            {dosomething(array[i]);}   //如果在循环中遍历这个被切割后的Derived对象数组，则由于循环时array[i]指针每次移动的距离是根据Base类对象的大小计算的，对于Derived类对象数组，移动的距离就会不正确，造成错误
        }
        应该用指向对象的指针数组的方法处理派生结构中的对象数组
    4.是否需要默认构造函数
        默认构造函数是指不需要提供实参就能调用的构造函数（包括带默认参数的有参构造函数、无参构造函数）
        如果一个类没有定义默认构造函数，则不能用通常的方法构造对象数组
        class A
        {
        public:
            A(int val):a(val){}
        private:
            int a;
        }
        A a_array[10];          //错误，栈对象数组
        A* a_array=new A[10];   //错误，堆对象数组
        正确的方式：
        int a1, a2, a3... a10;
        A a_array[]={
            A(a1),
            A(a2),
            ...
            A(a10)
        };  //正确，栈对象数组
        而对于堆对象数组，则无法一次性全部初始化，解决方式是使用指向对象的指针的数组，而非对象数组，要注意对这些数组中的指针new分配对象之后要用循环分别delete释放
        A* a_pt_array[10];  //声明了10个指向A类对象的指针形成的数组
        A** a_pt_array=new A*[10];  //同上
        这种方法的缺点是要额外的内存空间来存储指针，解决方法是可以使用operator new运算符来分配裸内存，然后再用定位new来在这块裸内存上构造对象
        void *rawMemory=operator new[](10*sizeof(A));   //分配了10个A类对象所需的裸内存
        A* a_array=static_cast<A*>(rawMemory);          //将这块裸内存的指针类型转换为指向A对象的指针
        for(int i=0; i<10; ++i)
            new(&a_aray[i])A(整数);                    //用定位new在这块内存上构造10个A类对象
        ... //现在可以用跟栈对象一样的下标访问法a_array[i]来使用这些对象
        for(int i=9; i>=0; --i)
            a_array[i].~A();    //无论A类有没有缺省虚构函数，都需要显式调用来析构裸内存中构造的对象
        operator delete[](rawMemory);   //释放裸内存
    5.对类型转换函数保持警觉
        对于自定义的类，有两种隐式类型转换
            没有被声明为explicit的只需要一个实参的构造函数：
            类型转换函数operator Type()：
        防止不希望发生的类型转换（除了单参数构造，其他的转换）：
        在C++中，任何转换都只能最多包含一次由用户定义的转换（包括上面两种）
        利用这个原理，如果旧版本编译器不支持带explicit关键字的构造函数，可以在原本的类中的public部分嵌套定义一个新类，这个新类包含一个只需一个实参的构造函数，然后在原来的类的只需一个实参的构造函数中将那个参数改为这个类的对象
        这样，仍然可以使用单个参数来构造对象，因为首先这个参数被用于隐式类型转换构造一个新类，然后旧类通过这个新类构造对象
        而其他情况下，如比较表达式中，由于一个参数不可能先被用于隐式类型转换构造新类再构造旧类，然后再通过旧类中的其他转换函数来转换，所以就避免了不希望发生的类型转换被执行
    24.了解虚函数、多继承、虚基类、RTII的成本
        虚函数：
            大部分编译器使用virtual tables（vtbl）和virtual table pointers（vptr）
            每个使用了虚函数的类，都有一个vtbl，其中的条目就是该类的各个虚函数的函数指针（只有被声明为虚的函数才在条目里）
            每个有虚函数的类对象，都含有一个隐藏的数据成员vptr，指向类的vtbl
            当通过一个对象指针或引用调用一个函数时，会通过对象的vptr访问所属类的vtbl，再通过vtbl找出所调用的函数的函数指针，然后调用相应的函数
                如：base_ptr->fun();    //有一个指向基类对象的指针base_ptr，调用虚函数fun();
                实际生成的代码类似于：(*base_ptr->vptr[i])(base_ptr);   //vptr[i]是虚函数表中的第i个条目，由编译决定，圆括号中的参数时类方法所需的this指针，this就是当前的base_ptr
            由于inline是将调用的函数通过函数本体定义取代，而通过指针或引用是动态绑定，在运行期才能知道是哪个函数被调用，所以虚函数通过指针或引用调用，不能被inline
        多继承与虚基类：
            每个虚继承的类中都包含一个指向基类的指针，来防止基类成分生成了多个拷贝
            所以如果有这样的继承结构：B类和C类都虚继承与A类，D类同时继承了B类和C类，则每个D类对象的B类、C类成分中个包含一个指向A类成分的指针
        RTII：
            RTII使得程序可以在运行期获得对象的相关类型信息，所以需要一个地方来存储这些信息
            通常的实现方法是在类的vtbl中增加一个这个类对应的type_info对象的指针
    26.限制某个类产生的对象数
        不要inline一个产生静态对象的函数，因为inline使得每个函数调用替换为函数的定义，而static的目的是只产生这一个对象，inline会造成这个对象产生了多个
        写一个对象计数类模板，这个计数类应由私有继承的方式被要计数的类继承，并具体化
        template<class BeingCounted>
        class Counter
        {
            static int numObjects;          //静态成员变量需要类外定义
            static const size_t maxObject;  //最大对象数，如果不需要限制最大可以产生的对象数，可以不要，由于这是类中的静态常量，需要在源文件中定义赋值
            void init()                     //由于构造函数和赋值构造函数都执行同样的步骤，所以单独提出来一个函数，减少重复代码
            {
                if(numObjects>maxObjects)
                    throw TooMvariantObjects();//超出最大对象数抛出异常，如果不需要可以省略
                ++numObjects;
            }
        public:
            class TooMvariantObjects    //自定义一个异常，超过最大对象数时抛出，也可以不要
            {
                ...
            }
            static int objectCount(){ return numObjects; } //public方法，返回此模板的对象个数
        protected:
            Counter() { init();}
            Counter(const Counter& rhs) {init();}   //当与之捆绑的类对象被复制时，Counter成分也会被自动复制，所以需要定义一个复制构造函数
            ~Counter() {--numObjects;}  
        }
        template<class BeingCounted>
        int Counter<T>::numObj=0;   //静态成员变量需要类外定义

        class someClass: private Counter<someClass> 
        {...}
        /*someClass.cpp */
        const size_t Counter<someClass>::maxObjects=10; //注意，要在someClass的某个源文件cpp中定义Counter类中的maxObjects，
1.高级数据类型
    为了统一成大写，VC++给很多类型取了大写的typedef
    INT->int
    UINT->unsigned int
    CHAR->char
    WCHAR->wchar_t
    
    WinDef.h:
    BYTE 8位无符号
    DWORD 32位无符号
    INT32
    INT64
    LONG 32位有符号
    LONGLONG 64位有符号

    UINT32
    UINT64
    ULONG
    ULONGLONG
    WORD 16位无符号
    windows里P开头表示是指针，LP开头表示长指针（为了便于将给16位计算机设计的代码移植到32位），现在P和LP没有区别，与变量类型*的指针表示也没有区别
    指针的长度是编译时决定的，所以64位系统中运行32位的程序，指针长度仍然是32位

    BOOL {FALSE->0, TRUE->1}

    LRESULT->long (winnt.h:typedef long LONG    windef.h:typedef LONG LRESULT)
    HRESULT->long (winnt.h)初始化COM库的函数的返回值
    LPTSTR 字符串指针
    LPTCSTR 常量字符串指针
2.函数参数的类型
    T快照snapshot，每次函数被调用时都会拷贝一次当前的值    T const 
    T&修改modify，由于引用不能是空值引用，所以这个T&要求调用时被引用的对象一定要存在      T const&观察view observe
    T&&丢弃sink，表示调用这个函数后不再需要被引用的值
    T*可选optional，表明可以是空指针nullptr      T* const
    T vs T const&：值传递需要拷贝，引用需要间接读取一次内存，所以当对象的拷贝操作昂贵时，选用T const&，否则选用T，编译器可能对拷贝有优化，但是对于引用，无论如何都要多访问一次内存
    T* vs std::optional<T>：optional<T>要求可复制，而且传指针可以在函数内修改参数T，所以T*的适用面更广

#include <iostream>
#include <array>
#include <vector>

using namespace std;

struct A_value
{
	int v;
	A_value(int _v) :v(_v) { cout << "value struct!\n"; }
};

class A
{
	int value;
public:
	A() { cout << "default constructor! value=" << value<<endl; }
	A(A_value b) :value(b.v) { cout << "Value constructor! value=" << value<<endl; }
	//A(int v) :value(v) { cout<<"Explicit constructor! value="<<value<<endl; }
	A(const A& a) :value(a.value) { cout << "Copy constructor! value=" << value << endl; }
	A(A&& a) { cout << "Move constructor! value=" << value << endl; }
	~A()
	{
		cout << "Destructor!\n";
	}
};

A Return_temp_A()
{
	return A();
}

A Return_local_A()
{
	A a(3);
	return a;
}

int main()
{
	
	cout << "/*std::array*/\n";
	array<A, 5> A_array;
	
	cout << "\n/*std::vector without anything.*/\n";
	vector<A> A_vector;
	A_vector.reserve(3);
	cout << "/*std::vector push_back A()*/\n";
	//A_vector.push_back(3);
	cout << "\n/*std::vector emplace_back A()*/\n";
	A_vector.emplace_back(4);
	
	cout << "\n/*Out of scope*/\n";
}